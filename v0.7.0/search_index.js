var documenterSearchIndex = {"docs":
[{"location":"publicAPI/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"Pages = [\"publicAPI.md\"]","category":"page"},{"location":"publicAPI/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"publicAPI/#Creating-an-aerodynamic-derivatives-solver","page":"Public API","title":"Creating an aerodynamic derivatives solver","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.AD","page":"Public API","title":"AeroBeams.AD","text":"AD (Automatic Differentiation) DerivationMethod composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.FD","page":"Public API","title":"AeroBeams.FD","text":"FD (Finite Differences) DerivationMethod composite type\n\nFields\n\nmethod::FiniteDifferenceMethod\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-an-aerodynamic-solver","page":"Public API","title":"Creating an aerodynamic solver","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.QuasiSteady","page":"Public API","title":"AeroBeams.QuasiSteady","text":"QuasiSteady AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.Indicial","page":"Public API","title":"AeroBeams.Indicial","text":"Indicial AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.BLi","page":"Public API","title":"AeroBeams.BLi","text":"Incompressible modified Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.BLo","page":"Public API","title":"AeroBeams.BLo","text":"Original Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.Inflow","page":"Public API","title":"AeroBeams.Inflow","text":"Inflow AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.TableLookup","page":"Public API","title":"AeroBeams.TableLookup","text":"TableLookup FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.ThinAirfoilTheory","page":"Public API","title":"AeroBeams.ThinAirfoilTheory","text":"ThinAirfoilTheory FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.IndicialGust","page":"Public API","title":"AeroBeams.IndicialGust","text":"IndicialGust GustAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-an-airfoil","page":"Public API","title":"Creating an airfoil","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_Airfoil","page":"Public API","title":"AeroBeams.create_Airfoil","text":"create_Airfoil(; kwargs...)\n\nAirfoil constructor\n\nArguments\n\nname::String: name of the airfoil\nRe::Real: Reynolds number\nMa::Real: Mach number\nU::Real: relative airspeed\nb::Real: semichord\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_flapped_Airfoil","page":"Public API","title":"AeroBeams.create_flapped_Airfoil","text":"create_flapped_Airfoil(; kwargs...)\n\nAirfoil constructor (with a trailing-edge flap) \n\nArguments\n\nname::String: name of the airfoil\nflapSiteID::Int64: flap site ID\nRe::Real: Reynolds number\nMa::Real: Mach number\nU::Real: relative airspeed\nb::Real: semichord\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.update_Airfoil_params!","page":"Public API","title":"AeroBeams.update_Airfoil_params!","text":"update_Airfoil_params!(airfoil::Airfoil; kwargs...)\n\nUpdates the airfoil parameters\n\nArguments\n\nairfoil::Airfoil\n\nKeyword arguments\n\nRe::Real: Reynolds number\nMa::Real: Mach number\nU::Real: reference relative airspeed\nb::Real: reference semichord\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-an-aerodynamic-surface","page":"Public API","title":"Creating an aerodynamic surface","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_AeroSurface","page":"Public API","title":"AeroBeams.create_AeroSurface","text":"create_AeroSurface(; kwargs...)\n\nAerodynamic surface constructor\n\nKeyword arguments\n\nsolver::AeroSolver: aerodynamic solver for pitch-plunge-induced loads\nflapLoadsSolver::FlapAeroSolver: aerodynamic solver for flap-induced loads\ngustLoadsSolver::GustAeroSolver: aerodynamic solver for gust-induced loads\nderivationMethod::DerivationMethod: method for calculation of aerodynamic derivatives\nairfoil::Airfoil: airfoil section\nc::Union{<:Function,Real}: chord\nΛ::Union{<:Function,Real}: sweep angle\nφ::Union{<:Function,Real}: twist angle\nnormSparPos::Union{<:Function,Float64}: normalized position of the spar (beam reference line) on the chord\nnormFlapSpan::Union{Nothing,Vector{<:Real}}: normalized position of the trailing-edge flap along the span (beam arclength)\nnormFlapPos::Union{Nothing,Float64}: normalized position of the trailing-edge flap hinge on the chord\nδIsTrimVariable::Bool: flag for trailing-edge deflection being a trim variable\nδ::Union{Nothing,<:Function,Real}: trailing-edge deflection [rad]\nflapSiteID::Union{Nothing,Int64}: trailing-edge flap site ID\nupdateAirfoilParameters::Bool: flag to update airfoil parameters with local airspeed\nhasTipCorrection::Bool: flag to employ a tip correction on aerodynamic coefficients\ntipLossFunction::String: respective tip loss function\ntipLossDecayFactor::Float64: respective tip loss factor\nsmallAngles::Bool: flag to employ small angles approximation on the calculation of the angle of attack\nhasInducedDrag::Bool: flag to include induced drag generated by the lifting surface\nhasSymmetricCounterpart::Bool: flag to indicate the surface has a symmetric counterpart (for the computation of aspect ratio)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-an-atmosphere","page":"Public API","title":"Creating an atmosphere","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.standard_atmosphere","page":"Public API","title":"AeroBeams.standard_atmosphere","text":"standard_atmosphere(altitude::Real)\n\nAtmosphere constructor based on the International Standard Atmosphere (https://en.wikipedia.org/wiki/InternationalStandardAtmosphere)\n\nArguments\n\naltitude::Real: altitude\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-boundary-conditions","page":"Public API","title":"Creating boundary conditions","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_BC","page":"Public API","title":"AeroBeams.create_BC","text":"create_BC(; kwargs...)\n\nBC constructor\n\nKeyword arguments\n\nname::String: name of the BC\nbeam::Beam: beam at which the BC is applied\nnode::Int64: node of the beam at which the BC is applied\ntypes::Vector{String}= types of BCs applied to the node (generalized forces and displacements)\nvalues: corresponding values of the applied BCs (constants or functions of time)\ntoBeTrimmed::Union{BitVector,Vector{Bool}}: TF on whether the BC is to be trimmed\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-beam","page":"Public API","title":"Creating a beam","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_Beam","page":"Public API","title":"AeroBeams.create_Beam","text":"create_Beam(; kwargs...)\n\nBeam constructor\n\nKeyword Arguments\n\nname::String: name of the beam\nlength::Real: (arc)length of the beam\nrotationParametrization::String: type of rotation parametrization to define basis b\np0::Vector{<:Real}: rotation parameters from basis A to basis b\nk::Union{Vector{<:Real},<:Function}: undeformed beam's curvatures per unit length\ninitialPosition::Vector{<:Real}: initial position of the beam's first node relative to the beam's origin (which may be another beam's node)\nnElements::Int64: number of elements for discretization\nnormalizedNodalPositions::Vector{Float64}: normalized nodal positions of beam elements\nS::Vector{<:Matrix{<:Real}}: array of sectional stiffness matrices\nI::Vector{<:Matrix{<:Real}}: array of sectional inertia matrices\nconnectedBeams::Union{Nothing,Vector{Beam}}: array of beams to which this beam is connected (a non-recursive property)\nconnectedNodesThis::Vector{Int64}: nodes of this beam which are connected to other beams' nodes\nconnectedNodesOther::Vector{Int64}: respective nodes of the other beams\npointInertias::Vector{PointInertia}: attached point inertias\nhingedNodes::Vector{Int64}: nodes with a hinge\nhingedNodesDoF::Union{Vector{Vector{Bool}},Vector{BitVector}}: respective hinged degrees-of-freedom\nu0_of_x1::Union{Vector{<:Real},<:Function,Nothing}: initial displacement (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\np0_of_x1::Union{Vector{<:Real},<:Function,Nothing}: initial rotation parameters (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\nudot0_of_x1::Union{Vector{<:Real},<:Function,Nothing}: initial displacement's rates (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\npdot0_of_x1::Union{Vector{<:Real},<:Function,Nothing}: initial rotation parameters' rates (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\nf_A_of_x1t::Union{Nothing,<:Function}: distributed dead forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nm_A_of_x1t::Union{Nothing,<:Function}: distributed dead moments initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nf_b_of_x1t::Union{Nothing,<:Function}: distributed dead forces initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nm_b_of_x1t::Union{Nothing,<:Function}: distributed dead moments initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nff_A_of_x1t::Union{Nothing,<:Function}: distributed follower forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nmf_A_of_x1t::Union{Nothing,<:Function}: distributed moments forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nff_b_of_x1t::Union{Nothing,<:Function}: distributed follower forces initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nmf_b_of_x1t::Union{Nothing,<:Function}: distributed follower moments initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\naeroSurface::Union{Nothing,AeroSurface}: attached aerodynamic surface\nsprings::Vector{Spring}: array of attached springs\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.update_beam!","page":"Public API","title":"AeroBeams.update_beam!","text":"update_beam!(beam::Beam)\n\nValidates and updates the beam construction\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_point_inertias_to_beam!","page":"Public API","title":"AeroBeams.add_point_inertias_to_beam!","text":"add_point_inertias_to_beam!(beam::Beam; inertias::Vector{PointInertia})\n\nAdds point inertias to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\ninertias::Vector{PointInertia}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_loads_to_beam!","page":"Public API","title":"AeroBeams.add_loads_to_beam!","text":"add_loads_to_beam!(beam::Beam; loadTypes::Vector{String},loadFuns::Vector{<:Function})\n\nAdds loads to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nloadTypes::Vector{String}\nloadFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_initial_displacements_and_velocities_to_beam!","page":"Public API","title":"AeroBeams.add_initial_displacements_and_velocities_to_beam!","text":"add_initial_displacements_and_velocities_to_beam!(beam::Beam; conditionTypes::Vector{String},conditionFuns::Vector{<:Function})\n\nAdds initial generalized displacements and velocities to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nconditionTypes::Vector{String}\nconditionFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_springs_to_beam!","page":"Public API","title":"AeroBeams.add_springs_to_beam!","text":"add_springs_to_beam!(; beam::Beam,springs::Vector{Spring})\n\nAdds simply-attached springs to a beam\n\nKeyword arguments\n\nbeam::Beam\nsprings::Vector{Spring}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_spring_to_beams!","page":"Public API","title":"AeroBeams.add_spring_to_beams!","text":"add_spring_to_beams!(; beams::Vector{Beam},spring::Spring)\n\nAdds a doubly-attached spring to the beams\n\nKeyword arguments\n\nbeams::Vector{Beam}\nspring::Spring\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.remove_all_springs_from_beams!","page":"Public API","title":"AeroBeams.remove_all_springs_from_beams!","text":"remove_all_springs_from_beam!(; beams::Vector{Beam})\n\nRemoves all springs attached to the beams\n\nKeyword arguments\n\nbeams::Vector{Beam}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-gust","page":"Public API","title":"Creating a gust","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_SharpEdgedGust","page":"Public API","title":"AeroBeams.create_SharpEdgedGust","text":"create_SharpEdgedGust(; kwargs...)\n\nCreates a sharp-edged gust\n\nKeyword arguments\n\ninitialTime::Real: time when the gust begins\nduration::Real: duration of the gust\nconvectiveVelocity::Real: convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Real: peak vertical velocity of the gust (in lift direction)\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_OneMinusCosineGust","page":"Public API","title":"AeroBeams.create_OneMinusCosineGust","text":"create_OneMinusCosineGust(; kwargs...)\n\nCreates a one-minus-cosine gust\n\nKeyword arguments\n\ninitialTime::Real: time when the gust begins\nduration::Real: duration of the gust\nconvectiveVelocity::Real: convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Real: peak vertical velocity of the gust (in lift direction)\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous1DGust","page":"Public API","title":"AeroBeams.create_Continuous1DGust","text":"create_Continuous1DGust(; kwargs...)\n\nCreates a continuous 1D gust\n\nKeyword arguments\n\nspectrum::String: spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\ngenerationMethod::String: method for generation of gust velocity (\"sinusoids\" or \"whiteNoise\")\ninitialTime::Real: time when the gust begins\nduration::Real: duration of the gust\ngenerationDuration::Real: duration of the gust considered for its generation\ncomponents::Vector{Int}: components of gust velocity to consider\nL::Real: turbulence length scale [m]\nωmin::Real: minimum frequency of the PSD [rad/s]\nωmax::Real: maximum frequency of the PSD [rad/s]\nUref::Real: reference airspeed\nconvectiveVelocity::Real: convective velocity of the gust (in longitudinal direction)\nσ::Real: turbulence intensity (RMS) of gust velocity component\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64: seed for random numbers generation (reproducibility)\nplotPSD::Bool: flag to plot the PSD\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_DiscreteSpaceGust","page":"Public API","title":"AeroBeams.create_DiscreteSpaceGust","text":"create_DiscreteSpaceGust(; kwargs...)\n\nCreates a discrete space gust\n\nKeyword arguments\n\ntype::String: type of gust\ngustLength::Real: length of the gust (in longitudinal direction)\ngustWidth::Real: width of the gust (in spanwise direction)\nconvectiveVelocity::Real: convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Real: peak vertical velocity of the gust (in lift direction)\nc0::Vector{<:Real}: position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous1DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous1DSpaceGust","text":"create_Continuous1DSpaceGust(; kwargs...)\n\nCreates a continuous 1D space gust\n\nKeyword arguments\n\nspectrum::String: spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\ngustLength::Real: length of the gust (in longitudinal direction)\nN::Int64: number of nodes for length discretization\nL::Real: turbulence length scale\nσ::Real: turbulence intensity (RMS) of gust velocity components\nc0::Vector{<:Real}: position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64: seed for random numbers generation (reproducibility)\nplotPSD::Bool: flag to plot the PSD\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous2DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous2DSpaceGust","text":"create_Continuous2DSpaceGust(; kwargs...)\n\nCreates a continuous 2D space gust\n\nKeyword arguments\n\nspectrum::String: spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\ngustLength::Real: length of the gust (in longitudinal direction)\ngustWidth::Real: width of the gust (in lateral direction)\nNx::Int64: number of nodes for length discretization\nNy::Int64: number of nodes for width discretization\nL::Real: turbulence length scale\nσ::Real: turbulence intensity (RMS) of gust velocity component\nc0::Vector{<:Real}: position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Real}: Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64: seed for random numbers generation (reproducibility)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-link","page":"Public API","title":"Creating a link","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_TrimLoadsLink","page":"Public API","title":"AeroBeams.create_TrimLoadsLink","text":"create_TrimLoadsLink(; masterBC::BC,slaveBCs::Vector{BC})\n\nTrim loads link constructor (a link between trim loads so that they are equal)\n\nKeyword arguments\n\nmasterBC::BC: master BC\nslaveBCs::Vector{BC}: slave BCs\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_FlapLink","page":"Public API","title":"AeroBeams.create_FlapLink","text":"create_FlapLink(; kwargs...)\n\nFlap link constructor (a link between flapped surfaces)\n\nKeyword arguments\n\nmasterBeam::Beam: beam of the master surface\nslaveBeams::Vector{Beam}: beams of the slave surfaces\nδMultipliers::Vector{<:Real}: multiplication factors of flap deflection in slave surfaces relative to the master surface\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-model","page":"Public API","title":"Creating a model","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_Model","page":"Public API","title":"AeroBeams.create_Model","text":"create_Model(; kwargs...)\n\nCreates a model\n\nKeyword arguments\n\nname::String: name of the model\nunits::create_UnitsSystem: units system\nbeams::Vector{Beam}: beams in the assembly\ninitialPosition::Vector{<:Real}: initial position vector of the first node of the first beam, resolved in the inertial frame I\ngravityVector::Vector{<:Real}: gravity vector\nBCs::Vector{BC}: boundary condtions\np_A0::Vector{Float64}: initial rotation parameters that bring basis I to basis A\nu_A::Union{Vector{<:Real},<:Function,Nothing}: displacement of basis A relative to basis I\nv_A::Union{Vector{<:Real},<:Function,Nothing}: velocity of basis A relative to basis I\nω_A::Union{Vector{<:Real},<:Function,Nothing}: angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Real},<:Function,Nothing}: acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Real},<:Function,Nothing}: angular acceleration of basis A relative to basis I\naltitude::Union{Nothing,Real}: altidude\natmosphere::Union{Nothing,Atmosphere}: atmosphere\ngust::Union{Nothing,Gust}: gust\ntrimLoadsLinks::Vector{TrimLoadsLink}: links between trim loads\nflapLinks::Vector{FlapLink}: links between flapped surfaces\nhingeAxisConstraints::Vector{HingeAxisConstraint}: hinge axis constraints\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.update_model!","page":"Public API","title":"AeroBeams.update_model!","text":"update_model!(model::Model)\n\nUpdates the model with its current settings\n\nArguments\n\nmodel::Model \n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.set_motion_basis_A!","page":"Public API","title":"AeroBeams.set_motion_basis_A!","text":"set_motion_basis_A!(; kwargs...)\n\nSets the motion of basis A into the model\n\nKeyword arguments\n\nmodel::Model: model\nu_A::Union{Vector{<:Real},<:Function,Nothing}: displacement of basis A relative to basis I\nv_A::Union{Vector{<:Real},<:Function,Nothing}: velocity of basis A relative to basis I\nω_A::Union{Vector{<:Real},<:Function,Nothing}: angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Real},<:Function,Nothing}: acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Real},<:Function,Nothing}: angular acceleration of basis A relative to basis I\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-point-inertia","page":"Public API","title":"Creating a point inertia","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.PointInertia","page":"Public API","title":"AeroBeams.PointInertia","text":"PointInertia composite type\n\nFields\n\nelementID::Int64: local element ID to which the point inertia is attached\nmass::Real: mass\nη::Vector{Real}: position relative to element's midpoint's reference line\nIxx::Real: mass moment of inertia about the x1-axis\nIyy::Real: mass moment of inertia about the x2-axis\nIzz::Real: mass moment of inertia about the x3-axis\nIxy::Real: mass product of inertia with respect to the x1-axis and x2-axis\nIxz::Real: mass product of inertia with respect to the x1-axis and x3-axis\nIyz::Real: mass product of inertia with respect to the x2-axis and x3-axis\ninertiaMatrix::Union{Matrix{Real},Matrix{Nothing}}: mass moment of inertia matrix (tensor)\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-a-hinge-axis-constraint","page":"Public API","title":"Creating a hinge axis constraint","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_HingeAxisConstraint","page":"Public API","title":"AeroBeams.create_HingeAxisConstraint","text":"HingeAxisConstraint(; kwargs...)\n\nHinge axis constraint constructor\n\nKeyword arguments\n\nbeam::Beam: beam\nlocalHingeAxis::Vector{<:Real}: three-element vector defining the hinge axis, resolved in the undeformed (b) basis of the beam\npHValue::Union{Real,Nothing}: constrained value for the rotation at the hinge\nsolutionMethod::String: solution method for the constraint (\"addedResidual\" or \"appliedMoment\")\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-and-solving-a-problem","page":"Public API","title":"Creating and solving a problem","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.InitialVelocitiesUpdateOptions","page":"Public API","title":"AeroBeams.InitialVelocitiesUpdateOptions","text":"InitialVelocitiesUpdateOptions composite type\n\nDefines variables for the update of the initial velocities states\n\nFields\n\nΔt::Real: time step\nmaxIter::Int64: maximum number of iterations\nrelaxFactor::Float64: relaxation factor\ntol::Float64: convergence tolerance\ndisplayProgress::Bool: flag to display progress\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.create_SteadyProblem","page":"Public API","title":"AeroBeams.create_SteadyProblem","text":"create_SteadyProblem(; kwargs...)\n\nSteady problem constructor\n\nKeyword arguments\n\nmodel::Model: model\nsystemSolver::systemSolver: nonlinear system solver\ngetLinearSolution::Bool: flag to solve for linear structural solution\nx0::Vector{Float64}: initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_TrimProblem","page":"Public API","title":"AeroBeams.create_TrimProblem","text":"create_TrimProblem(; kwargs...)\n\nTrim problem constructor\n\nKeyword arguments\n\nmodel::Model: model\nsystemSolver::systemSolver: nonlinear system solver\ngetLinearSolution::Bool: flag to solve for linear structural solution\ngetInertiaMatrix::Bool: flag to compute inertia matrix\nx0::Vector{Float64}: initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_EigenProblem","page":"Public API","title":"AeroBeams.create_EigenProblem","text":"create_EigenProblem(; kwargs...)\n\nEigen problem constructor\n\nKeyword arguments\n\nmodel::Model: model\nsystemSolver::systemSolver: nonlinear system solver\ngetLinearSolution::Bool: flag to solve for linear structural solution\nnModes::Int64=Inf64: number of modes to be computed\nfrequencyFilterLimits::Vector{Float64}: limits of the frequency filter\nnormalizeModeShapes::Bool: flag to normalize mode shapes\nx0::Vector{Float64}: initial states\nrefTrimProblem::Union{Nothing,TrimProblem}: reference trim problem containing steady solution\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_DynamicProblem","page":"Public API","title":"AeroBeams.create_DynamicProblem","text":"create_DynamicProblem(; kwargs...)\n\nDynamic problem constructor\n\nKeyword arguments\n\nmodel::Model: model\nsystemSolver::systemSolver: nonlinear system solver\ngetLinearSolution::Bool: flag to solve for linear structural solution\ninitialTime::Real: initial time\nΔt::Union{Nothing,Real}: time step\nfinalTime::Union{Nothing,Real}: final time\ntimeVector::Union{Nothing,Vector{Float64}}: time vector\nadaptableΔt::Bool: flag for adaptable time step\nminΔt::Union{Nothing,Real}: minimum time step (when adaptable)\nmaxΔt::Union{Nothing,Real}: maximum time step (when adaptable)\nδb::Float64: discontinuities boundary convergence norm\nskipInitialStatesUpdate::Bool: flag to skip update of initial states\ninitialVelocitiesUpdateOptions::InitialVelocitiesUpdateOptions: options for the initial velocities update\ntrackingTimeSteps::Bool: flag to track time step solutions\ntrackingFrequency::Int64: frequency of time steps in which to track solution\ndisplayProgress::Bool: flag to display progress\ndisplayFrequency::Int64: frequency of time steps in which to display progress\nx0::Vector{Float64}: initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.solve!","page":"Public API","title":"AeroBeams.solve!","text":"solve!(problem::Problem)\n\nSolves a problem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.solve_eigen!","page":"Public API","title":"AeroBeams.solve_eigen!","text":"solve_eigen!(problem::EigenProblem)\n\nSolves an eigenproblem \n\nArguments\n\nproblem::EigenProblem\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-sample-model","page":"Public API","title":"Creating a sample model","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.geometrical_properties_Pazy","page":"Public API","title":"AeroBeams.geometrical_properties_Pazy","text":"geometrical_properties_Pazy()\n\nReturns the fixed geometrical (and discretization) properties of the Pazy wing\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.tip_loss_function_Pazy","page":"Public API","title":"AeroBeams.tip_loss_function_Pazy","text":"tip_loss_function_Pazy(type::String,θ::Real,U::Real,Λ::Real)\n\nComputes the tip loss function for the Pazy wing's tip correction function\n\nArguments\n\ntype::String: tip loss function type\nθ::Real: root pitch angle [rad]\nU::Real: airspeed [m/s]\nΛ::Real: sweep angle [rad]\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.typical_section_data","page":"Public API","title":"AeroBeams.typical_section_data","text":"typical_section_data(name::String)\n\nReturns the data of the typical section of given name\n\nArguments\n\nname::String: name of the typical section\n\nOutputs\n\na: position of elastic axis (semichords aft of midchord)\ne: position of mass axis (semichords aft of midchord)\nμ: mass ratio\nrα²: squared radius of gyration in pitch \nσ: ratio of plunge to pitch frequency in vacuo\nωα: pitch frequency in vacuo [rad/s]\nc: chord [m]\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Pazy","page":"Public API","title":"AeroBeams.create_Pazy","text":"create_Pazy(; kwargs...)\n\nCreates the Pazy wing\n\nReturns the wing model and geometrical properties\n\nArguments\n\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nwithSkin::Bool: flag for skin on\nsweepStructuralCorrections::Bool: flag to apply ad hoc structural corrections on sectional stiffness matrix with sweep angle\nupdateAirfoilParameters::Bool: flag to update airfoil parameters with airspeed\nupright::Bool: flag to set the wing in the upright position\nairfoil::Airfoil: airfoil section\nθ::Real: pitch angle at the root [rad]\nΛ::Real: sweep angle [rad]\nhasTipCorrection::Bool: flag for aerodynamic tip correction \nGAy::Real: shear stiffness in the x2 direction\nGAz::Real: shear stiffness in the x3 direction\naltitude::Real: altitude\ng::Real: acceleration of gravity\nairspeed::Real: airspeed\nsmallAngles::Bool: flag for small angles approximation\ntipLossType::String: tip loss function type\ntipMass::Real: mass of a point inertia added to the tip of the wing\nηtipMass::Vector{<:Real}: position vector of the tip mass relative to the tip of the spar, resolved in the local basis\ntipMassInertia::Matrix{<:Real}: mass moment of inertia matrix of the tip mass\nadditionalBCs::Vector{BC}: additional BCs (beyond the clamp)\ngust::Union{Nothing,Gust}: gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_PazyFFWT","page":"Public API","title":"AeroBeams.create_PazyFFWT","text":"create_PazyFFWT(; kwargs...)\n\nCreates a version of the Pazy wing with flared folding wingtip (FFWT)\n\nArguments\n\nsolutionMethod::String: solution method for the constraint (\"addedResidual\" or \"appliedMoment\")\nairfoil::Airfoil: airfoil section\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nwithSkin::Bool = flag for skin on\nsweepStructuralCorrections::Bool: flag to apply ad hoc structural corrections on sectional stiffness matrix with sweep angle\nhasTipCorrection::Bool: flag for aerodynamic tip correction\nGAy::Real: shear stiffness in the x2 direction\nGAz::Real: shear stiffness in the x3 direction\nhingeNode::Int64: hinge node\npitchAngle::Real: pitch angle [rad]\nΛ::Real: sweep angle [rad]\nfoldAngle::Union{Real,Nothing}: fold angle [rad]\nflareAngle::Real: flare angle [rad]\nkSpring::Real: stiffness of the spring around the hinge for folding (combination of OOP bending and twist)\nkIPBendingHinge::Real: stiffness of the rotational spring around the hinge for in-plane bending\ng::Real: local acceleration of gravity\naltitude::Real: altitude\nairspeed::Real: local airspeed\ntipLossType::String: tip loss function type\nflightDirection::Vector{<:Real}: flight direction vector, resolved in basis A\ntipMass::Real: tip mass for passive flutter control\nηtipMass::Vector{<:Real}: position vector of the tip mass, relative to the spar\ngust::Union{Nothing,Gust}=nothing: gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_SMW","page":"Public API","title":"AeroBeams.create_SMW","text":"create_SMW(; kwargs...)\n\nCreates the 16 meters wing (SMW) of the conventional HALE aircraft described by Patil, Hodges and Cesnik in: Nonlinear Aeroelasticity and Flight Dynamics of HALE (2001)\n\nReturns the wing model and its span\n\nArguments\n\naeroSolver::AeroSolver: aerodynamic solver\nflapLoadsSolver::FlapAeroSolver: aerodynamic solver for flap loads\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nairfoil::Airfoil: airfoil section\nθ::Real: pitch angle [rad]\nk1::Real: twisting curvature\nk2::Real: flapwise bending curvature\nnElem::Int64: number of elements for discretization\naltitude::Real: altitude\nairspeed::Real: airspeed\ng::Real: acceleration of gravity\nstiffnessFactor::Real: stiffness factor for beam structural properties\n∞::Real: value of rigid structural properties\nΨ::Real: torsion-IP-bending stiffness coupling factor\ntipF3::Union{Real,<:Function}: tip dead transverse force applied at the tip\ncd0::Real: parasite drag coefficient for the wing\ncnδ::Real: cn vs δ slope for the wing\ncmδ::Real: cm vs δ slope for the wing\ncdδ::Real: cd vs δ slope for the wing\nhasInducedDrag::Bool: flag to include induced drag\nδAil::Union{Nothing,Real,<:Function}: aileron deflection\nadditionalBCs::Vector{BC}: additional BCs (beyond the clamp and tip load)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_TDWing","page":"Public API","title":"AeroBeams.create_TDWing","text":"create_TDWing(; kwargs...)\n\nCreates the wing described by Tang and Dowell in: Experimental and Theoretical Study on Aeroelastic Response of High-Aspect-Ratio Wings (2001)\n\nReturns the wing model\n\nArguments\n\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nupdateAirfoilParameters::Bool: flag to update airfoil parameters with airspeed\nairfoil::Airfoil: airfoil section\nθ::Real: pitch angle\nnElem::Int64: number of elements for discretization\naltitude::Real: altitude\nairspeed::Real: airspeed\ng::Real: acceleration of gravity\n∞::Real: value of rigid structural properties\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Helios","page":"Public API","title":"AeroBeams.create_Helios","text":"create_Helios(; kwargs...)\n\nCreates a model based on the flying-wing aircraft described by Patil and Hodges in: Flight Dynamics of Highly Flexible Flying Wings (2006)\n\nKeyword arguments\n\naltitude::Real: altitude\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\ng::Real: local acceleration of gravity\nwingAirfoil::Airfoil: airfoil section of the wing\npodAirfoil::Airfoil: airfoil section of the pods\nbeamPods::Bool: flag to include pods\nstiffnessFactor::Real: stiffness factor for the wing structure\n∞::Real: value for rigid structural properties\nnElemStraightSemispan::Int64: number of elements in the straight section of the semispan\nnElemDihedralSemispan::Int64: number of elements in the dihedral section of the semispan\nnElemPod::Int64: number of elements in the pods\npayloadPounds::Real: payload, in pounds\nairspeed::Real: local initial/trim airspeed\nδIsTrimVariable::Bool: flag for flap deflection being a trim variable\nthrustIsTrimVariable::Bool: flag for motors' thrust being a trim variable\nδ::Union{Nothing,Real,<:Function}: flap deflection\nthrust::Union{Real,<:Function}: motors' thrust\nreducedChord::Bool: flag to employ a reduced (7 ft) chord\npayloadOnWing::Bool: flag to set the payload on the wing's reference line\nwingRootAoA::Real: root angle of attack for clamped wing model [rad]\ngust::Union{Nothing,Gust}: gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_conventional_HALE","page":"Public API","title":"AeroBeams.create_conventional_HALE","text":"create_conventional_HALE(; kwargs...)\n\nCreates a model based on the conventional HALE aircraft described by Patil, Hodges and Cesnik in: Nonlinear Aeroelasticity and Flight Dynamics of HALE (2001)\n\nKeyword arguments\n\naltitude::Real: altitude\naeroSolver::AeroSolver: aerodynamic solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nflapLoadsSolver::FlapAeroSolver: aerodynamic solver for flap loads\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nstabilizersAero::Bool: flag for stabilizers with aerodynamic surfaces\nincludeVS::Bool: flag to include a vertical stabilizer in the model\nwAirfoil::Airfoil: wing airfoil section\nsAirfoil::Airfoil: stabilizers airfoil section\nnElemWing::Int64: number of elements of the full wing\nnElemHorzStabilizer::Int64: number of elements of the horizontal stabilizer\nnElemTailBoom::Int64: number of elements of the tail boom\nnElemVertStabilizer::Int64: number of elements of the vertical stabilizer\n∞::Real=1e12: value of rigid structural properties\nstiffnessFactor::Real: stiffness factor for the wing structure\nk1::Real: undeformed wing torsional curvature\nk2::Real: undeformed wing flapwise bending curvature\nairspeed::Real: local initial/trim airspeed\nδElevIsTrimVariable::Bool: flag for elevator deflection being a trim variable\nδAilIsTrimVariable::Bool: flag for aileron deflection being a trim variable\nδRuddIsTrimVariable::Bool: flag for rudder deflection being a trim variable    \nthrustIsTrimVariable::Bool: flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Real,<:Function}: elevator deflection\nδAil::Union{Nothing,Real,<:Function}: aileron deflection\nδRudd::Union{Nothing,Real,<:Function}: rudder deflection\nthrust::Union{Real,<:Function}: motors' thrust\ng::Real: local acceleration of gravity\nwingCd0::Real: parasite drag coefficient for the wing\nwingcnδ::Real: cn vs δ slope for the wing\nwingcmδ::Real: cm vs δ slope for the wing\nwingcdδ::Real: cd vs δ slope for the wing\nstabsCd0::Real: parasite drag coefficient for the stabilizers\nstabscnδ::Real: cn vs δ slope for the stabilizers\nstabscmδ::Real: cm vs δ slope for the stabilizers\nstabscdδ::Real: cd vs δ slope for the stabilizers\nhasInducedDrag::Bool: flag to include induced drag\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_BWB","page":"Public API","title":"AeroBeams.create_BWB","text":"create_BWB(; kwargs...)\n\nCreates a model based on the blended-wing-body described by Weihua Su's PhD thesis\n\nKeyword arguments\n\naltitude::Real: altitude\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives \n∞::Real=1e12: value of rigid structural properties\nstiffnessFactor::Real: stiffness factor for the wing structure\nairspeed::Real = local initial/trim airspeed\nδElevIsTrimVariable::Bool: flag for elevator deflection being a trim variable\nthrustIsTrimVariable::Bool: flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Real,<:Function}: elevator deflection\nthrust::Union{Real,<:Function}: motors' thrust\ng::Real: local acceleration of gravity\nupdateAirfoilParameters::Bool: flag to update airfoil parameters with airspeed\nhasTipCorrection::Bool: flag to employ aerodynamic tip correction\ntipLossDecayFactor::Real: tip loss decay factor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_HealyFFWT","page":"Public API","title":"AeroBeams.create_HealyFFWT","text":"create_HealyFFWT(; kwargs...)\n\nCreates a version of Healy's wing with flared folding wingtip (FFWT). See Healy's PhD thesis, chapter 7.\n\nArguments\n\nsolutionMethod::String: solution method for the constraint (\"addedResidual\" or \"appliedMoment\")\nairfoil::Airfoil: airfoil section\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nhasTipCorrection::Bool: flag for aerodynamic tip correction\ntipLossDecayFactor::Real: tip loss decay factor, in case hasTipCorrection is true\npitchAngle::Real: root pitch angle [rad]\nwingtipTwist::Real: wingtip twist angle [rad]\nfoldAngle::Union{Real,Nothing}: fold angle [rad]\nflareAngle::Real: flare angle [rad]\nkSpring::Real: stiffness of the spring around the hinge for folding (combination of OOP bending and twist)\nkIPBendingHinge::Real: stiffness of the rotational spring around the hinge for in-plane bending\ng::Real: local acceleration of gravity\naltitude::Real: altitude\nairspeed::Real: local airspeed\nflightDirection::Vector{<:Real}: flight direction vector, resolved on basis A\nnElementsInner::Int64: number of elements for discretization of inner part of the wing\nnElementsFFWT::Int64: number of elements for discretization of the wingtip\ngust::Union{Nothing,Gust}=nothing: gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_HealyBaselineFFWT","page":"Public API","title":"AeroBeams.create_HealyBaselineFFWT","text":"create_HealyBaselineFFWT(; kwargs...)\n\nCreates a version of Healy's baseline wing with flared folding wingtip (FFWT). See Healy's PhD thesis, chapter 3.\n\nArguments\n\nsolutionMethod::String: solution method for the constraint (\"addedResidual\" or \"appliedMoment\")\nairfoil::Airfoil: airfoil section\naeroSolver::AeroSolver: aerodynamic solver\ngustLoadsSolver::GustAeroSolver: indicial gust loads solver\nderivationMethod::DerivationMethod: method for aerodynamic derivatives\nhasTipCorrection::Bool: flag for aerodynamic tip correction\ntipLossDecayFactor::Real: tip loss decay factor, in case hasTipCorrection is true\nhingeConfiguration::String: hinge hingeConfiguration (\"free\" or \"locked\")\nflareAngle::Real: flare angle [rad]\npitchAngle::Real: root pitch angle [rad]\nfoldAngle::Union{Real,Nothing}: fold angle [rad]\nkSpringHinge::Real: stiffness of the rotational spring around the hinge for folding (combination of OOP bending and twist)\nkIPBendingHinge::Real: stiffness of the rotational spring around the hinge for in-plane bending\naltitude::Real: altitude\nairspeed::Real: local airspeed\ng::Real: local acceleration of gravity\nnElementsInner::Int64: number of elements for discretization of inner part of the wing\nnElementsFFWT::Int64: number of elements for discretization of the wingtip\ngust::Union{Nothing,Gust}=nothing: gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-spring","page":"Public API","title":"Creating a spring","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_Spring","page":"Public API","title":"AeroBeams.create_Spring","text":"create_Spring(; kwargs...)\n\nCreates a spring\n\nKeyword arguments\n\nbasis::String: basis on which stiffnesses are defined (\"b\" or \"A\")\nelementsIDs::Vector{Int64}: local IDs of the element(s)' node(s) to which the spring is attached\nnodesSides::Vector{Int64}: sides (1 or 2) of the node(s) to which the spring is attached\nku::Vector{<:Real}: translational stiffness vector, resolved in basis A\nkp::Vector{<:Real}: rotational stiffness vector, resolved in basis A\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-system-solver","page":"Public API","title":"Creating a system solver","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_NewtonRaphson","page":"Public API","title":"AeroBeams.create_NewtonRaphson","text":"create_NewtonRaphson(; kwargs...)\n\nNewton-Raphson nonlinear system solver constructor\n\nKeyword arguments\n\nabsoluteTolerance::Float64: absolute convergence tolerance\nrelativeTolerance::Float64: relative convergence tolerance\nmaximumIterations::Int64: maximum number of iterations\ndesiredIterations::Int64: desired number of iterations\nmaximumAbsoluteError::Real: maximum absolute error for divergence detection\nmaximumRelativeError::Real: maximum relative error for divergence detection\ninitialLoadFactor::Real: initial load factor\nminimumLoadFactor::Float64: minimum load factor\nmaximumLoadFactorStep::Float64: maximum load factor step\nminimumLoadFactorStep::Float64: minimum load factor step\nρ::Real: relaxation factor for trim variables\ntrackingLoadSteps::Bool: flag to track partial load steps solutions\ndisplayStatus::Bool: flag to display status\nminConvRateAeroJacUpdate::Real: minimum convergence rate to skip computation of aerodynamic Jacobians\nminConvRateJacUpdate::Real: minimum convergence rate to skip computation of structural Jacobians\nalwaysUpdateJacobian::Bool: flag to update Jacobians on every iteration\nallowAdvanceThroughUnconvergedAeroStates::Bool: flag to allow the advancement of the algorithm through unconverged aerodynamic states\naeroStatesResidualRatioThreshold::Float64: threshold ratio of aerodynamic/total residuals in order to allow the above flag\naeroStatesRelativeErrorThreshold::Float64: threshold relative error in order to allow the above flag\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-units-system","page":"Public API","title":"Creating a units system","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.create_UnitsSystem","page":"Public API","title":"AeroBeams.create_UnitsSystem","text":"create_UnitsSystem(; kwargs...)\n\nCreates a system composed of length, force, angle, frequency and mass units (this is only for plotting purposes and does not influence calculations)\n\nKeyword arguments\n\nlength::String: length unit\nforce::String: force unit\nangle::String: angle unit\nfrequency::String: frequency unit\nmass::String: mass unit\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Utilities","page":"Public API","title":"Utilities","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.round_off!","page":"Public API","title":"AeroBeams.round_off!","text":"round_off!(x)\n\nRounds the array or number to input tolerance (defaults to machine epsilon)\n\nArguments\n\nx: array or number\ntol: tolerance\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rms","page":"Public API","title":"AeroBeams.rms","text":"rms(x)\n\nComputes the root mean square of an array\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.tilde","page":"Public API","title":"AeroBeams.tilde","text":"tilde(v)\n\nComputes the skew-symmetric matrix associated with a three-element vector\n\nArguments\n\nv: vector\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.axial","page":"Public API","title":"AeroBeams.axial","text":"axial(R)\n\nComputes the axial part of a 3x3 matrix\n\nArguments\n\nR: matrix\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.gauss_legendre7","page":"Public API","title":"AeroBeams.gauss_legendre7","text":"gauss_legendre7(f, a::Real, b::Real)\n\nComputes the Gauss-Legendre quadrature (integral) for the vector-valued function f in the interval from a to b, using 7 points\n\nArguments\n\nf: function\na::Real: lower limit\nb::Real: upper limit\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.isotropic_stiffness_matrix","page":"Public API","title":"AeroBeams.isotropic_stiffness_matrix","text":"isotropic_stiffness_matrix(; kwargs...)\n\nCreates a 6x6 sectional stiffness matrix for a cross-section made of isotropic material\n\nArguments\n\n∞: value for rigid properties\nEA: axial stiffness\nGAy: shear stiffness in the x2 direction\nGAz: shear stiffness in the x3 direction\nGJ: torsional stiffness\nEIy: bending stiffness in the x2 direction\nEIz: bending stiffness in the x3 direction\nt2: offset from reference line to tension center in the x2 direction\nt3: offset from reference line to tension center in the x3 direction\ns2: offset from reference line to shear center in the x2 direction\ns3: offset from reference line to shear center in the x3 direction\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.inertia_matrix","page":"Public API","title":"AeroBeams.inertia_matrix","text":"inertia_matrix(; kwargs...)\n\nCreates a 6x6 sectional inertia matrix\n\nArguments\n\nρA: mass per unit length\nρIy: mass moment of inertia per unit length about the x2-axis\nρIz: mass moment of inertia per unit length about the x3-axis\nρIs: mass moment of inertia per unit length about the x1-axis\nρIyz: mass product of inertia per unit length\ne2: offset from reference line to center of gravity in the x2 direction\ne3: offset from reference line to center of gravity in the x3 direction\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E321","page":"Public API","title":"AeroBeams.rotation_tensor_E321","text":"rotation_tensor_E321(p)\n\nComputes the rotation tensor according to Euler parameters sequence 3-2-1\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E213","page":"Public API","title":"AeroBeams.rotation_tensor_E213","text":"rotation_tensor_E213(p)\n\nComputes the rotation tensor according to Euler parameters sequence 2-1-3.\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E231","page":"Public API","title":"AeroBeams.rotation_tensor_E231","text":"rotation_tensor_E231(p)\n\nComputes the rotation tensor according to Euler parameters sequence 2-3-1.\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E313","page":"Public API","title":"AeroBeams.rotation_tensor_E313","text":"rotation_tensor_E313(p)\n\nComputes the rotation tensor according to Euler parameters sequence 3-1-3\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_WM","page":"Public API","title":"AeroBeams.rotation_tensor_WM","text":"rotation_tensor_WM(p)\n\nComputes the rotation tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.scaled_rotation_parameters","page":"Public API","title":"AeroBeams.scaled_rotation_parameters","text":"scaled_rotation_parameters(p)\n\nReturns the scaled (extended) Wiener-Milenkovic rotation parameters\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_angle","page":"Public API","title":"AeroBeams.rotation_angle","text":"rotation_angle(p)\n\nComputes the rotation angle given the Wiener-Milenkovic rotation parameters\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_angle_limited","page":"Public API","title":"AeroBeams.rotation_angle_limited","text":"rotation_angle_limited(p)\n\nComputes the rotation angle (in the range -360 to 360 degrees) given the Wiener-Milenkovic rotation parameters\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_parameters_WM","page":"Public API","title":"AeroBeams.rotation_parameters_WM","text":"rotation_parameters_WM(R)\n\nComputes the Wiener-Milenkovic rotation parameters given a rotation tensor\n\nArguments\n\nR: rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_parameters_Rodrigues","page":"Public API","title":"AeroBeams.rotation_parameters_Rodrigues","text":"rotation_parameters_Rodrigues(R)\n\nComputes the Rodrigues rotation parameters given a rotation tensor\n\nArguments\n\nR: rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.yrp_from_rotation_tensor","page":"Public API","title":"AeroBeams.yrp_from_rotation_tensor","text":"yrp_from_rotation_tensor(R; ϵround=1e-10,ϵsingularity=1e-3,assumeNullYawInSingularity=true)\n\nComputes the Euler angles from the sequence 3-2-1 (yaw, roll, pitch) given the rotation tensor\n\nArguments\n\nR: rotation tensor\n\nKeyword arguments\n\nϵround: tolerance for rounding off elements of R to zero\nϵsingularity: tolerance to consider singular case \nassumeNullYawInSingularity: flag to assume zero yaw angle in singularity\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.quaternion_from_rotation_tensor","page":"Public API","title":"AeroBeams.quaternion_from_rotation_tensor","text":"quaternion_from_rotation_tensor(R)\n\nComputes the quaternion (Euler parameters) given a rotation tensor. Derived from Bauchau's book section 13.3.4. \n\nArguments\n\nR: rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.WM_to_yrp","page":"Public API","title":"AeroBeams.WM_to_yrp","text":"WM_to_yrp(p)\n\nTransforms Wiener-Milenkovic parameters to Euler parameters of sequence 3-2-1 (yaw, roll, pitch)\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.yrp_to_WM","page":"Public API","title":"AeroBeams.yrp_to_WM","text":"yrp_to_WM(p)\n\nTransforms Euler parameters of sequence 3-2-1 (yaw, roll, pitch) to Wiener-Milenkovic parameters\n\nArguments\n\np: rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_between_WM","page":"Public API","title":"AeroBeams.rotation_between_WM","text":"rotation_between_WM(p1,p2)\n\nComputes the Wiener-Milenkovic parameters describing the rotation from p1 to p2, i.e., p12 such that R2(p2) = R12(p12)*R1(p1)\n\nArguments\n\np1: initial rotation parameters\np2: final rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.mode_tracking","page":"Public API","title":"AeroBeams.mode_tracking","text":"mode_tracking(controlParam::AbstractVector{<:Real},untrackedFreqs::Array{Vector{Float64}},untrackedDamps::Array{Vector{Float64}},untrackedEigenvectors::Array{Matrix{ComplexF64}})\n\nApplies mode tracking based on eigenvectors match and a greedy search\n\nArguments\n\ncontrolParam::AbstractVector{<:Real}: vector of control parameter\nuntrackedFreqs::Array{Vector{Float64}}: frequencies vector\nuntrackedDamps::Array{Vector{Float64}}: dampings vector\nuntrackedEigenvectors::Array{Matrix{ComplexF64}}: complex-valued eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.mode_tracking_hungarian","page":"Public API","title":"AeroBeams.mode_tracking_hungarian","text":"mode_tracking_hungarian(controlParam::AbstractVector{<:Real},untrackedFreqs::Array{Vector{Float64}},untrackedDamps::Array{Vector{Float64}},untrackedEigenvectors::Array{Matrix{ComplexF64}}; showProgress::Bool=false,α::Real=1.0,β::Real=0.01,γ::Real=0.01)\n\nApplies mode tracking based on eigenvectors match and frequency and damping continuity, with a Hungarian algorithm\n\nArguments\n\ncontrolParam::AbstractVector{<:Real}: vector of control parameter\nuntrackedFreqs::Array{Vector{Float64}}: frequencies vector\nuntrackedDamps::Array{Vector{Float64}}: dampings vector\nuntrackedEigenvectors::Array{Matrix{ComplexF64}}: complex-valued eigenvectors\n\nKeyword arguments:\n\nshowProgress::Bool: flag to show progress over control parameter\nα::Real: weight for eigenvector similarity\nβ::Real: weight for frequency continuity\nγ::Real: weight for damping continuity\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.moving_average","page":"Public API","title":"AeroBeams.moving_average","text":"moving_average(v::AbstractVector{<:Real}, n::Int)\n\nComputes the moving average of a series\n\nArguments\n\nv::AbstractVector{<:Real}: series\nn::Int: moving average window size\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.get_FFT_and_PSD","page":"Public API","title":"AeroBeams.get_FFT_and_PSD","text":"get_FFT_and_PSD(t::AbstractVector{<:Real},y::Vector{<:Real}; tol::Float=1e3*eps())\n\nComputes the FFT and PSD of signal y(t)\n\nArguments\n\nt::AbstractVector{<:Real}: time signal\ny::Vector{<:Real}: quantity signal\n\nKeyword arguments\n\ntol::AbstractFloat: tolerance for time signal being equally spaced\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.Newton_solver","page":"Public API","title":"AeroBeams.Newton_solver","text":"Newton_solver(f::Function, x0::AbstractArray; absTol::Real=1e-9, relTol::Real=1e-9, maxIter::Int=50)\n\nSolves a nonlinear algebraic system of equations $( f(x) = 0 $) using the Newton-Raphson method.\n\nArguments\n\nf::Function: the nonlinear system of equations to solve. Must return a vector of residuals for a given x.\nx0::AbstractArray: initial guess for the solution.\n\nKeyword arguments\n\nabsTol::Real: absolute tolerance for convergence (default: 1e-9).\nrelTol::Real: relative tolerance for convergence (default: 1e-9).\nmaxIter::Int: maximum number of iterations allowed (default: 50).\n\nReturns\n\nx::AbstractArray: the solution vector, if convergence is achieved.\nconverged::Bool: true if the solution converged within the given tolerances, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.backward_extrapolation","page":"Public API","title":"AeroBeams.backward_extrapolation","text":"backward_extrapolation(v::AbstractVector{<:Real}; order::Int=5)\n\nEstimates the values of an array from backward finite difference extrapolation\n\nArguments\n\nv::AbstractVector{<:Real}: vector\n\nKeyword arguments\n\norder::Int: order of the approximation\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.count_of_exceedance","page":"Public API","title":"AeroBeams.count_of_exceedance","text":"count_of_exceedance(time::AbstractVector{<:Real}, series::Vector{<:Real}, datum::Real, marker::Vector{<:Real})\n\nComputes the count of exceedance of the quantities in the marker vector above the datum for the given time series\n\nKeyword arguments\n\ntime::AbstractVector{<:Real}: time vector\nseries::Vector{<:Real}: time series\ndatum::Real: datum value for the time series\nmarker::Vector{<:Real}: markers for the count of exceedance computation\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.frequency_of_exceedance","page":"Public API","title":"AeroBeams.frequency_of_exceedance","text":"frequency_of_exceedance(timeLength::Real, count::Vector{<:Real})\n\nComputes the frequency of exceedance\n\nKeyword arguments\n\ncount::Vector{<:Real}: count of exceedance\ntimeLength::Real: length of time\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.NASA_frames_loader","page":"Public API","title":"AeroBeams.NASA_frames_loader","text":"NASA_frames_loader(frame::Union{Int,String})\n\nLoads dynamic stall data from a frame of the NASA report (https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19830003778.pdf)\n\nArguments\n\nframe::Union{Int,String}: frame number\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.GU_frames_loader","page":"Public API","title":"AeroBeams.GU_frames_loader","text":"GU_frames_loader(frame::Union{Int,String})\n\nLoads dynamic stall data from a frame of the University of Glasgow (DOI:10.5525/gla.researchdata.464)\n\nArguments\n\nframe::Union{Int,String}: frame number\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Visualizing-the-results","page":"Public API","title":"Visualizing the results","text":"","category":"section"},{"location":"publicAPI/#AeroBeams.plot_undeformed_assembly","page":"Public API","title":"AeroBeams.plot_undeformed_assembly","text":"plot_undeformed_assembly(model::Model; kwars...)\n\nPlots the undeformed assembly of beams in the model\n\nArguments\n\nmodel::Model\n\nKeyword arguments\n\nview::Tuple{Real,Real}: view angles\nequalAspectRatio::Bool: flag to set equal aspect ratio plot\nplotNodes::Bool: flag to plot nodes\nnodesColor=:black: color of nodes\nlinesColor=:black: color of lines (beams)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_steady_deformation","page":"Public API","title":"AeroBeams.plot_steady_deformation","text":"plot_steady_deformation(problem::Problem; kwargs...)\n\nPlots the initial and final deformed states for the model in the given problem\n\nArguments\n\nproblem::Problem: problem\n\nKeyword arguments\n\ninteractive::Bool: flag for interactive plot\nplotBCs::Bool: flag to plot BCs\nplotDistLoads::Bool: flag to plot distributed loads (includes gravitational and aerodynamic loads)\nview::Union{Nothing,Tuple{Real,Real}}: view angles\nscale::Real: displacements and rotations scale\nlw::Real: linewidth\ncolorUndef: color for undeformed assembly\ncolorDef: color for deformed assembly\nplotGrid::Bool: flag to plot grid\nlegendPos: legend position\ntolPlane::Real: displacement tolerance to plot as plane\nplotAeroSurf::Bool: flag to plot aerodynamic surfaces\nsurfα::Float64: transparency factor of aerodynamic surfaces \nΔuDef::Vector{<:Real}: displacement vector for first node of deformed assembly relative to the undeformed one\nσ2plot::Vector{<:Real}: (tentative) load factors to plot  \npartialLoadStepsLineStyle::Symbol: linestyle for partial load steps\nplotLimits::Union{Nothing,Tuple{Vector{<:Real},Vector{<:Real},Vector{<:Real}}}: plot axis limits    \nshowScale::Bool: flag to show scale on plot\nscalePos::Vector{<:Real}: position of scale on plot\nsave::Bool: flag to save the figure\nsavePath::String: relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_steady_outputs","page":"Public API","title":"AeroBeams.plot_steady_outputs","text":"plot_steady_outputs(problem::Problem; kwargs...)\n\nPlots outputs of a steady problem\n\nArguments\n\nproblem::Problem: problem\n\nKeyword arguments\n\noutputs::Vector{String}: list of outputs\nbeamGroups: list of beams in each group for which arclengths are concatenated\nlw::Real: linewidth\ncolorScheme: color scheme\nlegendPos: legend position\nsave::Bool: flag to save figures\nsaveFolder::String: relative path of folder where to save figures\nfigureExtension::String: figure extension\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_mode_shapes","page":"Public API","title":"AeroBeams.plot_mode_shapes","text":"plot_mode_shapes(problem::EigenProblem; kwargs...)\n\nPlots the mode shapes of the model in the given eigenproblem\n\nArguments\n\nproblem::EigenProblem: problem\n\nKeyword arguments\n\ninteractive::Bool: flag for interactive plot\nplotBCs::Bool: flag to plot BCs\nview::Union{Nothing,Tuple{Real,Real}}: view angles\nnModes::Union{Nothing,Int64}: number of modes to plot\nscale::Real: displacements and rotations scale\nΔuDef::Vector{<:Real}: displacement vector for first node of deformed assembly relative to the undeformed one\nfrequencyLabel::String: option for frequency label\nlw::Real: linewidth\ncolorSteady: color for steadily deformed assembly\nmodalColorScheme: color scheme for mode shapes\nplotAxes::Bool: flag to plot axes\nplotGrid::Bool: flag to plot grid\nplotLimits::Union{Nothing,Tuple{Vector{Int64},Vector{Int64}}} = plot limits\nlegendPos: legend position\nmodeLabels::Union{Nothing,Vector{String}} = labels for each mode\ntolPlane::Real: displacement tolerance to plot as plane\nplotAeroSurf: flag to plot aerodynamic surfaces\nsurfα::Float64: transparency factor of aerodynamic surfaces \nsave::Bool: flag to save the figure\nsavePath::String: relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_dynamic_deformation","page":"Public API","title":"AeroBeams.plot_dynamic_deformation","text":"plot_dynamic_deformation(problem::DynamicProblem; kwargs...)\n\nPlots the animated deformation of the model in the given problem\n\nArguments\n\nproblem::DynamicProblem: problem\n\nKeyword arguments\n\nrefBasis::String: reference observer basis for plot\nplotFrequency::Int64: frequency of time steps to plot\nplotUndeformed::Bool: flag to plot undeformed assembly\nplotBCs::Bool: flag to plot BCs\nplotDistLoads::Bool: flag to plot distributed loads (includes gravitational and aerodynamic loads)\nview::Union{Nothing,Tuple{Real,Real}}: view angles\nfps::Real: frame rate for gif\nscale::Real: displacements and rotations scale\nfrequencyLabel::String: option for frequency label (only frequency or frequency and damping)\nlw::Real: linewidth\ncolorUndef: color for undeformed assembly\ncolorDef: color for deformed assembly\nplotGrid::Bool: flag to plot grid\nlegendPos: legend position\ntolPlane::Real: displacement tolerance to plot as plane\nplotAeroSurf: flag to plot aerodynamic surfaces\nsurfα::Float64: transparency factor of aerodynamic surfaces \nplotLimits::Union{Nothing,Tuple{Vector{<:Real},Vector{<:Real},Vector{<:Real}}}: plot axis limits\nfollowAssembly::Bool: flag to adjust the plot limits in order to \"follow\" the assembly of beams with the movement of basis A\nsave::Bool: flag to save the figure\nsavePath::String: relative path on which to save the figure\nshowScale::Bool: flag to show scale on plot\nshowTimeStamp::Bool: flag to show time stamp on plot\nscalePos::Vector{<:Real}: position of scale on plot\ntimeStampPos::Vector{<:Real}: position of time stamp on plot\ndisplayProgress::Bool: flag to display progress of gif creation\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_time_outputs","page":"Public API","title":"AeroBeams.plot_time_outputs","text":"plot_time_outputs(problem::Problem; kwargs...)\n\nPlots outputs of a dynamic problem\n\nArguments\n\nproblem::Problem: problem\n\nKeyword arguments\n\nnodes::Vector{Tuple{Int64,Int64}} = global IDs of nodes for which to plot\nelements::Vector{Int64} = global IDs of elements for which to plot\nnodalOutputs::Vector{String} = nodal outputs to plot\nelementalOutputs::Vector{String}: elemental outputs to plot\nlw::Real: linewidth\ncolorScheme: color scheme\nshowLegend::Bool: flag to show legend\nlegendPos: legend position\nsave::Bool: flag to save figures\nsaveFolder::String: relative path of folder where to save figures\nfigureExtension::String: figure extension\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_snapshots","page":"Public API","title":"AeroBeams.plot_snapshots","text":"plot_snapshots(problem::DynamicProblem; kwargs...)\n\nPlots the deformed states for the model in the given dynamic problem at specified time instances (snapshots)\n\nArguments\n\nproblem::DynamicProblem: problem\n\nKeyword arguments\n\nrefBasis::String: reference observer basis for plot\nplotBCs::Bool: flag to plot BCs\nplotDistLoads::Bool: flag to plot distributed loads (includes gravitational and aerodynamic loads)\nview::Union{Nothing,Tuple{Real,Real}}: view angles\nscale::Real: displacements and rotations scale\nlw::Real: linewidth\nls::Symbol= line style\ncolor: color\nplotAxes::Bool: flag to plot axes\nplotGrid::Bool: flag to plot grid\ntolPlane::Real: displacement tolerance to plot as plane\nplotAeroSurf::Bool: flag to plot aerodynamic surfaces\nsurfα::Float64: transparency factor of aerodynamic surfaces\nsnapshots::Vector{<:Real}: (tentative) time instances to plot    \nplotLimits::Union{Nothing,Tuple{Vector{<:Real},Vector{<:Real},Vector{<:Real}}}: plot axis limits    \nshowScale::Bool: flag to show scale on plot\nscalePos::Vector{<:Real}: position of scale on plot\nsave::Bool: flag to save the figure\nsavePath::String: relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"literate/BWBflutter/#Flutter-of-a-Blended-Wing-Body","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"","category":"section"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"This example illustrates how to set up a flutter analysis of an aircraft in free flight. For that we take a Blended-Wing-Body (BWB) vehicle, a swept flying-wing with trailing-edge control surfaces. This aircraft model was described in Weihua Su's PhD thesis:","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: ) BWB model geometry by Su","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: ) BWB's body properties by Su","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: ) BWB's wing properties by Su","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/BWBflutter/#Problem-setup","page":"Flutter of a Blended-Wing-Body","title":"Problem setup","text":"","category":"section"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"Let's begin by setting up the variables of our problem.","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"using AeroBeams, DelimitedFiles, LinearInterpolations\n\n# Aerodynamic solver\naeroSolver = Indicial()\n\n# Flight altitude\nh = 0e3\n\n# Airspeed range\nURange = collect(30:2:160)\n\n# Number of vibration modes\nnModes = 8\n\n# Pre-allocate memory and initialize output arrays\ntrimAoA = Array{Float64}(undef,length(URange))\ntrimThrust = Array{Float64}(undef,length(URange))\ntrimδ = Array{Float64}(undef,length(URange))\nuntrackedFreqs = Array{Vector{Float64}}(undef,length(URange))\nuntrackedDamps = Array{Vector{Float64}}(undef,length(URange))\nuntrackedEigenvectors = Array{Matrix{ComplexF64}}(undef,length(URange))\nfreqs = Array{Vector{Float64}}(undef,length(URange))\ndamps = Array{Vector{Float64}}(undef,length(URange))\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"For the trim problem, we set a Newton-Raphson solver for the system of equations, with the adequate relaxation factor for trim problems (relaxFactor = 0.5), and an increased number of maximum iterations (maxIter = 50, the default is 20).","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# System solver\nrelaxFactor = 0.5\nmaxIter = 50\nNR = create_NewtonRaphson(ρ=relaxFactor,maximumIterations=maxIter)\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"Next, we address an important step to be taken when performing flutter analyses in free flight with AeroBeams: to attach the model to light springs in displacement and rotation. This step is necessary for the solver to find the flight dynamic (rigid-body) modes of the vehicle, by introducing some sensitivity of the finite element states to those degrees-of-freedom. In the present case, we will attach two springs to the vehicle, one at each of the nodes where the transition from the body (fuselage) to the wing begins. An appropriate value for the stiffness of the springs is specified by the variable μ. The vectors ku and kp denote the stiffness values in the three orthogonal directions.","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Attachment springs\nμ = 1e-1\nku = kp = μ*[1; 1; 1]\nspring1 = create_Spring(elementsIDs=[1],nodesSides=[1],ku=ku,kp=kp)\nspring2 = create_Spring(elementsIDs=[3],nodesSides=[2],ku=ku,kp=kp)\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/#Problem-solution","page":"Flutter of a Blended-Wing-Body","title":"Problem solution","text":"","category":"section"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"At this point we can sweep the airspeed vector to find the solution at each value.","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Sweep airspeed range\nfor (i,U) in enumerate(URange)\n    # The first step of the solution is to trim the aircraft at that flight condition (combination of altitude and airspeed). We leverage the built-in function in AeroBeams to create our model for the trim problem.\n    BWBtrim = create_BWB(aeroSolver=aeroSolver,altitude=h,airspeed=U,δElevIsTrimVariable=true,thrustIsTrimVariable=true)\n\n    # Now we create and solve the trim problem.\n    global trimProblem = create_TrimProblem(model=BWBtrim,systemSolver=NR)\n    solve!(trimProblem)\n\n    # We extract the trim variables at the current airspeed and set them into our pre-allocated arrays. The trimmed angle of attack at the root, `trimAoA[i]`, is not necessary for the flutter analyses, it is merely an output of interest.\n    trimAoA[i] = trimProblem.aeroVariablesOverσ[end][BWBtrim.beams[3].elementRange[1]].flowAnglesAndRates.αₑ\n    trimThrust[i] = trimProblem.x[end-1]*BWBtrim.forceScaling\n    trimδ[i] = trimProblem.x[end]\n\n    # Now let's create a new model, add springs to it, and update\n    BWBtrimSpringed = create_BWB(aeroSolver=aeroSolver,altitude=h,airspeed=U,δElevIsTrimVariable=true,thrustIsTrimVariable=true)\n    add_springs_to_beam!(beam=BWBtrimSpringed.beams[2],springs=[spring1])\n    add_springs_to_beam!(beam=BWBtrimSpringed.beams[3],springs=[spring2])\n    BWBtrimSpringed.skipValidationMotionBasisA = true\n    update_model!(BWBtrimSpringed)\n\n    # Now we create and solve the trim problem for the springed model.\n    global trimProblemSpringed = create_TrimProblem(model=BWBtrimSpringed,systemSolver=NR)\n    solve!(trimProblemSpringed)\n\n    # Let's make sure that the trim outputs of the springed model are very close to the one without springs, that is, the springs did not affect the trim solution. Notice that all ratios are very close to 1.\n    trimAoASpringed = trimProblemSpringed.aeroVariablesOverσ[end][BWBtrimSpringed.beams[3].elementRange[1]].flowAnglesAndRates.αₑ\n    trimThrustSpringed = trimProblemSpringed.x[end-1]*BWBtrimSpringed.forceScaling\n    trimδSpringed = trimProblemSpringed.x[end]\n    println(\"Trim outputs' ratios springed/nominal: AoA = $(round(trimAoASpringed/trimAoA[i],sigdigits=4)), thrust = $(round(trimThrustSpringed/trimThrust[i],sigdigits=4)), δ = $(round(trimδSpringed/trimδ[i],sigdigits=4))\")\n\n    # All the variables needed for the stability analysis are now in place. We create the model for the eigenproblem, using the trim variables found previously with the springed model in order to solve for the stability around that exact state.\n    BWBeigen = create_BWB(aeroSolver=aeroSolver,altitude=h,airspeed=U,δElev=trimδSpringed,thrust=trimThrustSpringed)\n\n    # Now we create and solve the eigenproblem. Notice that by using `solve_eigen!()`, we skip the step of finding the steady state of the problem, making use of the known trim solution (with the keyword argument `refTrimProblem`). We apply a filter to find only modes whose frequencies are greater than 5e-2*U rad/s through the keyword argument `frequencyFilterLimits`\n    global eigenProblem = create_EigenProblem(model=BWBeigen,nModes=nModes,frequencyFilterLimits=[5e-2*U,Inf],refTrimProblem=trimProblemSpringed)\n    solve_eigen!(eigenProblem)\n\n    # The final step in the loop is extracting the frequencies, dampings and eigenvectors of the solution\n    untrackedFreqs[i] = eigenProblem.frequenciesOscillatory\n    untrackedDamps[i] = round_off!(eigenProblem.dampingsOscillatory,1e-8)\n    untrackedEigenvectors[i] = eigenProblem.eigenvectorsOscillatoryCplx\nend\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/#Post-processing","page":"Flutter of a Blended-Wing-Body","title":"Post-processing","text":"","category":"section"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"We can use the AeroBeams built-in function mode_tracking_hungarian to enhance the chances of correctly tracking the frequencies and dampings of each mode","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Mode tracking\nfreqs,damps,_,matchedModes = mode_tracking_hungarian(URange,untrackedFreqs,untrackedDamps,untrackedEigenvectors)\n\n# Separate frequencies and damping ratios by mode\nmodeDampings = Array{Vector{Float64}}(undef,nModes)\nmodeFrequencies =  Array{Vector{Float64}}(undef,nModes)\nfor mode in 1:nModes\n    modeDampings[mode] = [damps[i][mode] for i in eachindex(URange)]\n    modeFrequencies[mode] = [freqs[i][mode] for i in eachindex(URange)]\nend\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"The flutter onset speeds and frequencies are computed for all modes","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Flutter onset speed of each mode\nflutterOnsetSpeedOfMode = fill(NaN, nModes)\nflutterOnsetFreqOfMode = fill(NaN, nModes)\nfor mode in 1:nModes\n    iOnset = findfirst(j -> modeDampings[mode][j] < 0 && modeDampings[mode][j+1] > 0, 1:length(URange)-1)\n    flutterOnsetSpeedOfMode[mode] = isnothing(iOnset) ? Inf : interpolate(modeDampings[mode][iOnset:iOnset+1],URange[iOnset:iOnset+1],0)\n    flutterOnsetFreqOfMode[mode] = isnothing(iOnset) ? Inf : interpolate(modeDampings[mode][iOnset:iOnset+1],modeFrequencies[mode][iOnset:iOnset+1],0)\nend\nflutterModes = findall(!isinf, flutterOnsetSpeedOfMode)\nflutterOnsetSpeedsAll = filter(!isinf,flutterOnsetSpeedOfMode)\nflutterOnsetFreqsAll = filter(!isinf,flutterOnsetFreqOfMode)\nflutterOnsetSpeed = minimum(flutterOnsetSpeedsAll)\nfor (mode,speed,freq) in zip(flutterModes,flutterOnsetSpeedsAll,flutterOnsetFreqsAll)\n    println(\"Mode $mode: flutter speed = $(round(speed,sigdigits=4)) m/s, flutter frequency = $(round(freq,digits=2)) rad/s\")\nend","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"We can load the reference solution found with the University of Michigan's Nonlinear Aeroelastic Simulation Tool (UM/NAST) in its 2024 version (not the version in Su's thesis).","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Load reference data\ntrimAoARef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/BWB/trimAoA.txt\")\ntrimThrustRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/BWB/trimThrust.txt\")\ntrimδRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/BWB/trimDelta.txt\")\nfreqsRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/BWB/freqs.txt\")\ndampsRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/BWB/damps.txt\")\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"We are ready to plot the results. The following plots show the trim root angle of attack, motor thrust and elevator deflection as functions of the airspeed. The correlation with the reference solution is very good, except for the thrust. This difference arises because of the way in which the airfoil tangential force is computed when a flap deflection is present: either as proportional to the total normal force, which includes the flap-induced component (in AeroBeams), or proportional to the effective angle of attack (in UM/NAST).","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"using Suppressor #hide\nusing Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\nnothing #hide\n\n# Root AoA\nplt1 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Trim root AoA [deg]\", xlims=[0,160], xticks=vcat(30:10:160))\nplot!(URange, trimAoA*180/π, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(trimAoARef[1,:],trimAoARef[2,:], c=:black, ms=4, label=\"UM/NAST\")\nsavefig(\"BWBflutter_AoA.svg\") #hide\n\n# Thrust\nplt2 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Trim thrust [N]\", xlims=[30,160], xticks=vcat(0:10:160), legend=:bottomright)\nplot!(URange, trimThrust, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(trimThrustRef[1,:],trimThrustRef[2,:], c=:black, ms=4, label=\"UM/NAST\")\nsavefig(\"BWBflutter_thrust.svg\") #hide\n\n# Elevator deflection\nplt3 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Trim elevator deflection [deg]\", xlims=[30,160], xticks=vcat(0:10:160), legend=:bottomright)\nplot!(URange, trimδ*180/π, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(trimδRef[1,:],trimδRef[2,:], c=:black, ms=4, label=\"UM/NAST\")\nsavefig(\"BWBflutter_delta.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"The stability results can be visualized through the following root locus and V-g-f (frequency and damping evolution) plots. The lowest flutter speed is computed by AeroBeams at approximately 120.7 m/s, at a frequency of 47.4 rad/s. Conversely, the flutter speed and frequency predicted by UM/NAST are around 137.7 m/s and 47.5 rad/s, yielding differences of 12.3% and 0.2%, on speed and frequency, respectively. Despite the flutter speed disagreement, there is qualitatively good agreement among the models for the behavior of the roots.","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Colormap\nmodeColors = get(colorschemes[:rainbow], LinRange(0, 1, nModes))\n\n# Root locus\nplt4 = plot(xlabel=\"Damping [1/s]\", ylabel=\"Frequency [rad/s]\", xlims=[-30,5],ylims=[0,125])\nscatter!([NaN],[NaN], c=:black, shape=:circle, ms=4, msw=0, label=\"AeroBeams\")\nscatter!([NaN],[NaN], c=:black, shape=:utriangle, ms=4, msw=0, label=\"UM/NAST\")\nfor mode in 1:nModes\nscatter!(dampsRef[mode+1,:], 2π*freqsRef[mode+1,:], c=:black, shape=:utriangle, ms=4, msw=0, label=false)\nscatter!(modeDampings[mode], modeFrequencies[mode], c=modeColors[mode], shape=:circle, ms=4, msw=0, label=false)\nend\nsavefig(\"BWBflutter_rootlocus.svg\") #hide\n\n# V-g-f\nplt51 = plot(ylabel=\"Frequency [rad/s]\", xlims=[30,160], xticks=0:10:160, ylims=[0,125])\nfor mode in 1:nModes\nplot!(URange, modeFrequencies[mode], c=modeColors[mode], shape=:circle, ms=4, msw=0, label=false)\nend\nplt52 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Damping ratio\", xlims=[30,160], ylims=[-0.3,0.2], xticks=30:10:160, yticks=-0.3:0.1:0.2)\nfor mode in 1:nModes\nplot!(URange, modeDampings[mode]./modeFrequencies[mode], c=modeColors[mode], shape=:circle, ms=4, msw=0, label=false)\nend\nplt5 = plot(plt51,plt52, layout=(2,1))\nsavefig(\"BWBflutter_Vgf.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: ) (Image: )","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"Finally, we may visualize the mode shapes of the last eigenproblem (at highest airspeed), making use of the plot_mode_shapes function with the appropriate inputs. Modes 1 and 2 seem to respectively be lateral-directional and longitudinal flight dynamic modes, whereas the others are structural.","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"# Plot mode shapes\n@suppress begin #hide\nmodesPlot = plot_mode_shapes(eigenProblem,scale=2,view=(45,30),ΔuDef=-eigenProblem.elementalStatesOverσ[end][11].u.+[0;0;-2],legendPos=:top,modalColorScheme=:rainbow)\nend #hide\nsavefig(\"BWBflutter_modeShapes.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"(Image: )","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"","category":"page"},{"location":"literate/BWBflutter/","page":"Flutter of a Blended-Wing-Body","title":"Flutter of a Blended-Wing-Body","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/#Pitch-maneuver-of-a-HALE-aircraft","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"","category":"section"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"This example illustrates how to set up a dynamic analysis of an aircraft in free flight. For that we take a high-altitude long-endurance (HALE) aircraft model described by Patil, Hodges and Cesnik:","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"(Image: ) HALE model geometry by Patil, Hodges and Cesnik","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/#Problem-setup","page":"Pitch maneuver of a HALE aircraft","title":"Problem setup","text":"","category":"section"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"Let's begin by setting up the variables of our problem.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"using AeroBeams\n\n# Aerodynamic solver\naeroSolver = Inflow(nInflowStates=6)\n\n# Stiffness factor (for the structure)\nλ = 1\n\n# Altitude [m]\nh = 20e3\n\n# Airspeed [m/s]\nU = 25\n\n# Wing and stabilizers parasite drag\nwingCd0 = stabsCd0 = 1e-2\n\n# Option to include vertical stabilizer\nincludeVS = true\n\n# Discretization\nnElemWing = 20\nnothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/#Trim-problem","page":"Pitch maneuver of a HALE aircraft","title":"Trim problem","text":"","category":"section"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"We have to first trim the aircraft at the specified flight condition. Our trim variables are the engine's thrust (modeled as a follower force at the root of the wing), and the elevator deflection. For the trim problem, we set a Newton-Raphson solver for the system of equations, with the adequate relaxation factor for trim problems (relaxFactor = 0.5), and an increased number of maximum iterations (maxiter = 50, the default is 20). We use the built-in function create_conventional_HALE to streamline the model creation process. A dedicated example explains the inner workings of that function.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"# System solver\nrelaxFactor = 0.5\nmaxiter = 50\nNR = create_NewtonRaphson(ρ=relaxFactor,maximumIterations=maxiter,relativeTolerance=1e-12)\n\n# Model for trim problem\nconventionalHALEtrim,_ = create_conventional_HALE(aeroSolver=aeroSolver,stiffnessFactor=λ,altitude=h,airspeed=U,nElemWing=nElemWing,wingCd0=wingCd0,stabsCd0=stabsCd0,δElevIsTrimVariable=true,thrustIsTrimVariable=true,includeVS=includeVS)\n\n# Create and solve trim problem\ntrimProblem = create_TrimProblem(model=conventionalHALEtrim,systemSolver=NR)\nsolve!(trimProblem)\n\n# Extract trim variables and outputs\ntrimAoA = (trimProblem.aeroVariablesOverσ[end][conventionalHALEtrim.beams[1].elementRange[end]].flowAnglesAndRates.αₑ + trimProblem.aeroVariablesOverσ[end][conventionalHALEtrim.beams[2].elementRange[1]].flowAnglesAndRates.αₑ)/2\ntrimThrust = trimProblem.x[end-1]*trimProblem.model.forceScaling\ntrimδ = trimProblem.x[end]\ntrimHTAoA = (trimProblem.aeroVariablesOverσ[end][35].flowAnglesAndRates.αₑ + trimProblem.aeroVariablesOverσ[end][36].flowAnglesAndRates.αₑ)/2\nnothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/#Dynamic-problem","page":"Pitch maneuver of a HALE aircraft","title":"Dynamic problem","text":"","category":"section"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"The pitch maneuver investigated is defined by a checked elevator deflection, linearly ramped. The amplitude of the deflection, Δδ, is negative so as to command a climb. The time-dependent elevator profile, δ, is then passed as an argument to create the model for the dynamic problem.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"using Suppressor #hide\n# Set checked elevator deflection profile\nΔδ = -10*π/180\ntδinit = 1\ntδramp = 2\ntδpeak = tδinit+tδramp\ntδfinal = tδpeak+tδramp\nδ = t -> ifelse(\n    t <= tδinit,\n    trimδ,\n    ifelse(\n        t <= tδpeak,\n        trimδ + Δδ * ((t-tδinit) / (tδpeak-tδinit)),\n        ifelse(\n            t <= tδfinal,\n            trimδ + Δδ - Δδ * ((t-tδpeak) / (tδfinal-tδpeak)),\n            trimδ\n        )\n    )\n)\n\n# Model for dynamic problem\nconventionalHALEdynamic,_ = create_conventional_HALE(aeroSolver=aeroSolver,stiffnessFactor=λ,altitude=h,airspeed=U,nElemWing=nElemWing,wingCd0=wingCd0,stabsCd0=stabsCd0,δElev=δ,thrust=trimThrust,includeVS=includeVS)\nnothing #hide\n\n# Time variables\nΔt = 1e-2\ntf = 10\n\n# Set NR system solver for dynamic problem\nmaxit = 100\nNR = create_NewtonRaphson(maximumIterations=maxit)\n\n# Create and solve dynamic problem\ndynamicProblem = create_DynamicProblem(model=conventionalHALEdynamic,x0=trimProblem.x[1:end-2],finalTime=tf,Δt=Δt,skipInitialStatesUpdate=true,systemSolver=NR)\n@suppress begin #hide\nsolve!(dynamicProblem)\nend #hide\nnothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/#Post-processing","page":"Pitch maneuver of a HALE aircraft","title":"Post-processing","text":"","category":"section"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"The first post-processing step is to unpack the desired outputs.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"# Get wing root elements\nlRootElem = div(nElemWing,2)\nrRootElem = lRootElem+1\n\n# Unpack numerical solution\nt = dynamicProblem.timeVector\nwingAoA = [(dynamicProblem.aeroVariablesOverTime[i][lRootElem].flowAnglesAndRates.αₑ+dynamicProblem.aeroVariablesOverTime[i][rRootElem].flowAnglesAndRates.αₑ)/2 for i in 1:length(t)]\nhtAoA = [(dynamicProblem.aeroVariablesOverTime[i][35].flowAnglesAndRates.αₑ+dynamicProblem.aeroVariablesOverTime[i][36].flowAnglesAndRates.αₑ)/2 for i in 1:length(t)]\nΔu2 = [(conventionalHALEdynamic.u_A.(t[i])[2] + dynamicProblem.nodalStatesOverTime[i][lRootElem].u_n2[2]) for i in eachindex(t)] .- dynamicProblem.nodalStatesOverTime[1][lRootElem].u_n2[2]\nΔu3 = [dynamicProblem.nodalStatesOverTime[i][lRootElem].u_n2[3] for i in 1:length(t)] .- dynamicProblem.nodalStatesOverTime[1][lRootElem].u_n2[3]\nairspeed = [(dynamicProblem.aeroVariablesOverTime[i][lRootElem].flowVelocitiesAndRates.U∞+dynamicProblem.aeroVariablesOverTime[i][rRootElem].flowVelocitiesAndRates.U∞)/2 for i in 1:length(t)]\nnothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"We are now ready to visualize the results through the changes in forward distance and altitude, root angle of attack and airspeed.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# Forward distance\nplt1 = plot(xlabel=\"Time [s]\", ylabel=\"Forward distance [m]\")\nplot!(t, Δu2, c=:black, lw=2, label=false)\nsavefig(\"conventionalHALECheckedPitchManeuver_fdist.svg\") #hide\n\n# Altitude\nplt2 = plot(xlabel=\"Time [s]\", ylabel=\"Altitude [m]\")\nplot!(t, Δu3, c=:black, lw=2, label=false)\nsavefig(\"conventionalHALECheckedPitchManeuver_altitude.svg\") #hide\n\n# Root AoA\nplt3 = plot(xlabel=\"Time [s]\", ylabel=\"Root angle of attack [deg]\")\nplot!(t, wingAoA*180/π, c=:black, lw=2, label=\"Wing\")\nplot!(t, htAoA*180/π, c=:blue, lw=2, label=\"HT\")\nsavefig(\"conventionalHALECheckedPitchManeuver_AoA.svg\") #hide\n\n# Airspeed\nplt4 = plot(xlabel=\"Time [s]\", ylabel=\"Airspeed [m/s]\")\nplot!(t, airspeed, c=:black, lw=2, label=false)\nsavefig(\"conventionalHALECheckedPitchManeuver_airspeed.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"Let's also visualize the complete motion of the aircraft (rigid + elastic) through the view of an inertial observer. For that, we use the plot_dynamic_deformation function with the appropriate arguments.","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"@suppress begin #hide\nplot_dynamic_deformation(dynamicProblem,refBasis=\"I\",view=(30,15),plotBCs=false,plotDistLoads=false,plotFrequency=10,plotLimits=([-20,20],[-10,250],[-20,20]),save=true,savePath=\"/docs/build/literate/conventionalHALECheckedPitchManeuver_motion.gif\")\nnothing #hide\nend #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"(Image: )","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"nothing #hide","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"","category":"page"},{"location":"literate/conventionalHALECheckedPitchManeuver/","page":"Pitch maneuver of a HALE aircraft","title":"Pitch maneuver of a HALE aircraft","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/conventionalHALEmodel/#Creating-a-HALE-aircraft-model","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"This example illustrates how to create a conventional aircraft model, the high-altitude long-endurance (HALE) aircraft described by Patil, Hodges and Cesnik:","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"(Image: ) HALE model geometry by Patil, Hodges and Cesnik","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"(Image: ) HALE model data by Patil, Hodges and Cesnik","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The contents of the present example are wrapped into the function create_conventional_HALE, in which you may check all the keyword arguments that we'll define below.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Define input arguments\nusing AeroBeams\n\naltitude=20e3\naeroSolver=Indicial()\nderivationMethod=AD()\nflapLoadsSolver=TableLookup()\ngustLoadsSolver=IndicialGust(\"Kussner\")\nstabilizersAero=true\nincludeVS=true\nwAirfoil=deepcopy(flatPlate)\nsAirfoil=deepcopy(flatPlate)\nnElemWing=20\nnElemHorzStabilizer=10\nnElemTailBoom=10\nnElemVertStabilizer=5\n∞=1e12\nstiffnessFactor=1\nk1=0\nk2=0\nairspeed=0\nδElevIsTrimVariable=false\nthrustIsTrimVariable=false\nδElev=nothing\nthrust=0\ng=-9.80665\nwingCd0=0\nwingcnδ=2.5\nwingcmδ=-0.35\nwingcdδ=0.15\nstabsCd0=0\nstabscnδ=2.5\nstabscmδ=-0.35\nstabscdδ=0.15\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Validation","page":"Creating a HALE aircraft model","title":"Validation","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The first step is the validation of the inputs, for which reasonable values are necessary.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Validate\n@assert iseven(nElemWing)\n@assert iseven(nElemHorzStabilizer)\n@assert ∞ > 1e8\n@assert stiffnessFactor > 0\n@assert wingCd0 >= 0\n@assert stabsCd0 >= 0\n@assert airspeed >= 0\nδElevIsInput = !isnothing(δElev)\nif δElevIsInput\n    @assert !δElevIsTrimVariable\nend\nif δElev isa Number\n    δElevConst = deepcopy(δElev)\n    δElev = t -> δElevConst\nend\nif thrust isa Number\n    thrustConst = deepcopy(thrust)\n    thrust = t -> thrustConst\nend\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Atmosphere","page":"Creating a HALE aircraft model","title":"Atmosphere","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"Let's initialize an instance of the International Standard Atmosphere (ISA) at the specified altitude using the function standard_atmosphere.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Atmosphere\natmosphere = standard_atmosphere(altitude)\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Wing-aerodynamic-surface","page":"Creating a HALE aircraft model","title":"Wing aerodynamic surface","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"In AeroBeams, each beam can have an aerodynamic surface attached to it. The wing surface is defined by an airfoil, wAirfoil, the normalized position of the beam's reference line (spar) on the chord, wNormSparPos, the normalized position of the flap (aileron) hinge on the chord, wNormFlapPos, and the normalized endpoints of the flap (aileron) span over the beam's arclength, wNormFlapSpan. We update the airfoil parameters to the specified atmospheric conditions using the function update_Airfoil_params!. To create an aerodynamic surface, we use the function create_AeroSurface.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Wing surface\nwChord = 1\nwNormSparPos = 0.5\nwNormFlapPos = 0.75\nwNormFlapSpan = [0.75,1]\nupdate_Airfoil_params!(wAirfoil,Ma=airspeed/atmosphere.a,U=airspeed,b=wChord/2)\nwingSurf = create_AeroSurface(solver=aeroSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,flapLoadsSolver=flapLoadsSolver,airfoil=wAirfoil,c=wChord,normSparPos=wNormSparPos,normFlapPos=wNormFlapPos,normFlapSpan=wNormFlapSpan,updateAirfoilParameters=false)\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"We then override the appropriate parameters of the airfoil with those input by the user.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Override wing airfoil parameters\nwingSurf.airfoil.attachedFlowParameters.cd₀ = wingCd0\nwingSurf.airfoil.parametersBLi.cd₀ = wingCd0\nwingSurf.airfoil.parametersBLo.cd₀ = wingCd0\nwingSurf.airfoil.flapParameters.cnδ = wingcnδ\nwingSurf.airfoil.flapParameters.cmδ = wingcmδ\nwingSurf.airfoil.flapParameters.cdδ = wingcdδ\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Wing-beam-(spar)","page":"Creating a HALE aircraft model","title":"Wing beam (spar)","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"Next, we'll define the structural properties of the beam. Notice that we have the option of specifying a stiffness factor, stiffnessFactor, for the relevant properties of the wing. We then use the built-in functions isotropic_stiffness_matrix and inertia_matrix to create the sectional stiffness (force-strain relations) and inertia (velocity-displacement relation) matrices.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Beam properties\nLw = 16\nwGJ,wEIy,wEIz = 1e4,2e4,4e6\nwGJ,wEIy,wEIz = AeroBeams.multiply_inplace!(stiffnessFactor, wGJ,wEIy,wEIz)\nwρA,wρIs = 0.75,0.1\nwρIy,wρIz = (wEIy/wEIz)*wρIs,(1-wEIy/wEIz)*wρIs\nCwing = isotropic_stiffness_matrix(∞=∞,GJ=wGJ,EIy=wEIy,EIz=wEIz)\nIwing = inertia_matrix(ρA=wρA,ρIy=wρIy,ρIz=wρIz,ρIs=wρIs)\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"In order to position the center of the wing at the origin of the frame A, we need the position of the first node of the assembly, at the left wingtip. That initialPosition vector will be a function of the undeformed wing curvature k2 (which is zero in the original model). Similarly, the initial angle of twist of the wing, ψ, is a function of the undeformed wing twist curvature, k1 (also zero in the original model).","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Initial position for first node of left wing\nρ = 1/k2\nθ = Lw/ρ\nx = ρ*sin(θ)\nz = ρ*(1-cos(θ))\ninitialPosition = k2 == 0 ? [-Lw; 0; 0] : [-x; 0; -z]\n\n# Initial angle of twist\nr = 1/k1\nψ = Lw/r\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"To create the beams of the left and right wings, we use the function create_Beam. The rotation parameters from the underformed beam basis (b) to the global basis (A), namely p0, are set for the left wing such that the left and right wings become symmetric about the x1-plane of basis A. We also create an antissymetric link between the ailerons of the left and right wings, using the function create_FlapLink.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Wing beams\nleftWing = create_Beam(name=\"leftWing\",length=Lw,nElements=div(nElemWing,2),S=[Cwing],I=[Iwing],aeroSurface=deepcopy(wingSurf),k=[-k1;k2;0],rotationParametrization=\"E321\",p0=[0;-θ;-ψ])\n\nrightWing = create_Beam(name=\"rightWing\",length=Lw,nElements=div(nElemWing,2),S=[Cwing],I=[Iwing],aeroSurface=deepcopy(wingSurf),k=[k1;k2;0],connectedBeams=[leftWing],connectedNodesThis=[1],connectedNodesOther=[div(nElemWing,2)+1])\n\n# Link wing ailerons\naileronLink = create_FlapLink(masterBeam=rightWing,slaveBeams=[leftWing],δMultipliers=[-1])\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Payload","page":"Creating a HALE aircraft model","title":"Payload","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The payload is modeled as a point inertia at the center of the wing spar. It is created with the constructor PointInertia, and then added to the center of the wing through the function add_point_inertias_to_beam!.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Payload\npayloadMass = 50\npayloadInertia = 200\npayload = PointInertia(elementID=1,η=[-Lw/div(nElemWing,2)/2;0;0],mass=payloadMass,Iyy=payloadInertia,Izz=payloadInertia,Ixx=payloadInertia)\nadd_point_inertias_to_beam!(rightWing,inertias=[payload])\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Tail-boom","page":"Creating a HALE aircraft model","title":"Tail boom","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The tail boom is assumed to be a rigid beam, devoid of aerodynamic surfaces, and rigidly connected to wing spar. Some of its sectional inertia matrix properties are assumed with reasonable values, since they are not given in the reference.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Tail boom\nLt = 10\ntρA,tρIy,tρIz = 0.08,wρIy/10,wρIz/10\ntailBoom = create_Beam(name=\"tailBoom\",length=Lt,nElements=nElemTailBoom,S=[isotropic_stiffness_matrix(∞=∞)],I=[inertia_matrix(ρA=tρA,ρIy=tρIy,ρIz=tρIz)],rotationParametrization=\"E321\",p0=[-π/2;0;0],connectedBeams=[rightWing],connectedNodesThis=[1],connectedNodesOther=[1])\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Horizontal-stabilizer","page":"Creating a HALE aircraft model","title":"Horizontal stabilizer","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The horizontal stabilizer's aerodynamic surface is constructed similarly to the wing's, though it depends on whether the elevator deflecton is a trim variable or not (through the flags δElevIsTrimVariable and δElevIsInput).","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Horizontal stabilizer surface\nhChord = 0.5\nhNormSparPos = 0.5\nhNormFlapPos = 0.75\nhNormFlapSpan = [0,1]\nupdate_Airfoil_params!(sAirfoil,Ma=airspeed/atmosphere.a,U=airspeed,b=hChord/2)\nhsSurf = δElevIsInput ? create_AeroSurface(solver=aeroSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,flapLoadsSolver=flapLoadsSolver,airfoil=sAirfoil,c=hChord,normSparPos=hNormSparPos,normFlapPos=hNormFlapPos,normFlapSpan=hNormFlapSpan,δ=δElev,updateAirfoilParameters=false) : create_AeroSurface(solver=aeroSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,flapLoadsSolver=flapLoadsSolver,airfoil=sAirfoil,c=hChord,normSparPos=hNormSparPos,normFlapPos=hNormFlapPos,normFlapSpan=hNormFlapSpan,δIsTrimVariable=δElevIsTrimVariable,updateAirfoilParameters=false)\n\n# Override horizontal stabilizer airfoil parameters\nhsSurf.airfoil.attachedFlowParameters.cd₀ = stabsCd0\nhsSurf.airfoil.parametersBLi.cd₀ = stabsCd0\nhsSurf.airfoil.parametersBLo.cd₀ = stabsCd0\nhsSurf.airfoil.flapParameters.cnδ = stabscnδ\nhsSurf.airfoil.flapParameters.cmδ = stabscmδ\nhsSurf.airfoil.flapParameters.cdδ = stabscdδ\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The horizontal stabilizer beam (spar) is also created analogously to the wing, albeit now we input the initialPosition keyword to create_Beam in order to the define the position of the stabilizer's left tip. The aerodynamic surface is only attached to the wing if the flag stabilizersAero is true, using the function update_beam!.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Horizontal stabilizer beam\nLh = 5\nhρA,hρIy,hρIz = 0.08,wρIy/10,wρIz/10\nhorzStabilizer = create_Beam(name=\"horzStabilizer\",length=Lh,initialPosition=[-Lh/2;0;0],nElements=nElemHorzStabilizer,S=[isotropic_stiffness_matrix(∞=∞)],I=[inertia_matrix(ρA=hρA,ρIy=hρIy,ρIz=hρIz)],connectedBeams=[tailBoom],connectedNodesThis=[div(nElemHorzStabilizer,2)+1],connectedNodesOther=[nElemTailBoom+1])\nif stabilizersAero\n    horzStabilizer.aeroSurface = hsSurf\n    update_beam!(horzStabilizer)\nend\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Vertical-stabilizer","page":"Creating a HALE aircraft model","title":"Vertical stabilizer","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The construction of the vertical stabilizer is again similar to that of the wing and horizontal counterpart.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Vertical stabilizer surface\nvChord = 0.5\nvNormSparPos = 0.5\nvNormFlapPos = 0.75\nvNormFlapSpan = [0,1]\nupdate_Airfoil_params!(sAirfoil,Ma=airspeed/atmosphere.a,U=airspeed,b=vChord/2)\nvsSurf = create_AeroSurface(solver=aeroSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,flapLoadsSolver=flapLoadsSolver,airfoil=sAirfoil,c=vChord,normSparPos=vNormSparPos,normFlapPos=vNormFlapPos,normFlapSpan=vNormFlapSpan,updateAirfoilParameters=false)\n\n# Override vertical stabilizer airfoil parameters\nvsSurf.airfoil.attachedFlowParameters.cd₀ = stabsCd0\nvsSurf.airfoil.parametersBLi.cd₀ = stabsCd0\nvsSurf.airfoil.parametersBLo.cd₀ = stabsCd0\nvsSurf.airfoil.flapParameters.cnδ = stabscnδ\nvsSurf.airfoil.flapParameters.cmδ = stabscmδ\nvsSurf.airfoil.flapParameters.cdδ = stabscdδ\n\n# Vertical stabilizer beam\nLv = 2.5\nvρA,vρIy,vρIz = 0.08,hρIy,hρIz\nvertStabilizer = create_Beam(name=\"vertStabilizer\",length=Lv,nElements=nElemVertStabilizer,S=[isotropic_stiffness_matrix(∞=∞)],I=[inertia_matrix(ρA=vρA,ρIy=vρIy,ρIz=vρIz)],rotationParametrization=\"E321\",p0=[0;-π/2;0],connectedBeams=[tailBoom],connectedNodesThis=[1],connectedNodesOther=[nElemTailBoom+1])\nif stabilizersAero\n    vertStabilizer.aeroSurface = vsSurf\n    update_beam!(vertStabilizer)\nend\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Thrust-force","page":"Creating a HALE aircraft model","title":"Thrust force","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The thrust force of the vehicle is modeled as a follower concentrated force acting at the wing's center node, initially pointing in the x2-direction of the undeformed beam basis. Whether it is to take a time-dependent user input value or is a trim variable depends on the user's choice. It is created using the function create_BC.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Propeller thrust force\nthrustValue = thrustIsTrimVariable ? t -> 0 : thrust\n\npropThrust = create_BC(name=\"propThrust\",beam=rightWing,node=1,types=[\"Ff2b\"],values=[t->thrustValue(t)],toBeTrimmed=[thrustIsTrimVariable])\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/#Model-assembly","page":"Creating a HALE aircraft model","title":"Model assembly","text":"","category":"section"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"The beams composing the model depend on whether the vertical stabilizer is to be included, through the flag includeVS. The model is created with the appropriate inputs using the function create_Model. Notice that the keyword argument initialPosition defines the position of the first node of the first beam of the model, namely, the node at the left wingtip. Also, the velocity of the body-attached global frame A with respect to an inertial frame is set through v_A.","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Beams of the model\nbeams = includeVS ? [leftWing,rightWing,tailBoom,horzStabilizer,vertStabilizer] : [leftWing,rightWing,tailBoom,horzStabilizer]\n\n# Aircraft model\nconventionalHALE = create_Model(name=\"conventionalHALE\",beams=beams,BCs=[propThrust],initialPosition=initialPosition,v_A=[0;airspeed;0],altitude=altitude,gravityVector=[0;0;g],flapLinks=[aileronLink])\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"Finally, we may visually check the undeformed assembly through the function plot_undeformed_assembly:","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"# Visualization\nusing Plots #hide\np1 = plot_undeformed_assembly(conventionalHALE, view=(30,30))\nnothing #hide\nsavefig(\"conventionalHALE.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"(Image: )","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"nothing #hide","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"","category":"page"},{"location":"literate/conventionalHALEmodel/","page":"Creating a HALE aircraft model","title":"Creating a HALE aircraft model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/heliosTrim/#Trimming-a-flying-wing-HALE","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"","category":"section"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"This example illustrates how to set up a trim analysis of an aircraft in free flight. For that we take a model of the Helios aircraft, a 75 meters wingspan flying-wing HALE. This aircraft model was described in Patil and Hodges:","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"(Image: ) Flying-wing HALE model geometry by Patil and Hodges","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"(Image: ) Flying-wing properties by Patil and Hodges","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/heliosTrim/#Problem-setup","page":"Trimming a flying-wing HALE","title":"Problem setup","text":"","category":"section"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"Let's begin by setting up the variables of our problem. We select the airfoil for the wing, and the optional flags to include the vertical beam pods and of setting the payload on the wing. Our set up matches that of Patil and Hodges. We will investigate the longitudinal trim of the aircraft at both rigid and elastic (nominal) configurations, using the payload at the center station as the varying parameter.","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"using AeroBeams, DelimitedFiles\n\n# Wing airfoil\nwingAirfoil = deepcopy(HeliosWingAirfoil)\n\n# Flag to include beam pods\nbeamPods = true\n\n# Flag to set payload on wing\npayloadOnWing = false\n\n# Aerodynamic solver\naeroSolver = Indicial()\n\n# Set NR system solver\nrelaxFactor = 0.5\nNR = create_NewtonRaphson(ρ=relaxFactor)\n\n# Airspeed (40 ft/s) [m]\nU = 40*0.3048\n\n# Set stiffness factor and payload ranges\nλRange = [1,50]\nPRange = collect(0:20:500)\n\n# Initialize outputs\nproblem = Array{TrimProblem}(undef,length(λRange),length(PRange))\ntrimAoA = Array{Float64}(undef,length(λRange),length(PRange))\ntrimThrust = Array{Float64}(undef,length(λRange),length(PRange))\ntrimδ = Array{Float64}(undef,length(λRange),length(PRange))\nnothing #hide","category":"page"},{"location":"literate/heliosTrim/#Solving-the-problem","page":"Trimming a flying-wing HALE","title":"Solving the problem","text":"","category":"section"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"At this point we can sweep the stiffness factor and payload vectors to find the trim solution at each value.","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"# Sweep stiffness factor\nfor (i,λ) in enumerate(λRange)\n    # Sweep payload\n    for (j,P) in enumerate(PRange)\n        # Model\n        helios,midSpanElem,_ = create_Helios(aeroSolver=aeroSolver,beamPods=beamPods,wingAirfoil=wingAirfoil,payloadOnWing=payloadOnWing,stiffnessFactor=λ,payloadPounds=P,airspeed=U,δIsTrimVariable=true,thrustIsTrimVariable=true)\n        # Set initial guess solution as previous known solution\n        x0 = (j==1) ? zeros(0) : problem[i,j-1].x\n        # Create and solve trim problem\n        problem[i,j] = create_TrimProblem(model=helios,systemSolver=NR,x0=x0)\n        solve!(problem[i,j])\n        # Trim results\n        trimAoA[i,j] = problem[i,j].aeroVariablesOverσ[end][midSpanElem].flowAnglesAndRates.αₑ*180/π\n        trimThrust[i,j] = problem[i,j].x[end-1]*problem[i,j].model.forceScaling\n        trimδ[i,j] = problem[i,j].x[end]*180/π\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/heliosTrim/#Post-processing","page":"Trimming a flying-wing HALE","title":"Post-processing","text":"","category":"section"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"The first post-processing step is to load the reference data by Patil and Hodges.","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"# Load reference data\nαFlexibleRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Helios/trim_AoA_flexible.txt\")\nαRigidRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Helios/trim_AoA_rigid.txt\")\nδFlexibleRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Helios/trim_delta_flexible.txt\")\nδRigidRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Helios/trim_delta_rigid.txt\")\nTRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Helios/trim_thrust.txt\")\nnothing #hide","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"We now plot the trim outputs as functions of the payload, for both rigid and elastic configurations. The agreement with the reference is very good. Notice that the thrust (per motor) remains almost constant, for both rigid and flexible aircraft, because the drag slope with flap deflection is assumed null (c_d_delta = 0) and induced drag is neglected, so that only the parasite drag (c_d_0) component is present.","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"# Plot configurations\nusing Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\ncolors = get(colorschemes[:rainbow], LinRange(0, 1, length(λRange)))\nlabels = [\"Flexible\" \"Rigid\"]\nlw = 2\nms = 3\nmsw = 0\nnothing #hide\n\n# Trim root angle of attack\nplt1 = plot(xlabel=\"Payload [lb]\", ylabel=\"Trim root AoA [deg]\", xlims=[0,500], ylims=[0,5])\nplot!([NaN], [NaN], c=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], c=:black, ms=ms, label=\"Patil & Hodges (2006)\")\nfor (i,λ) in enumerate(λRange)\n    plot!(PRange, trimAoA[i,:], c=colors[i], lw=lw, label=labels[i])\n    if i==1\n        scatter!(αFlexibleRef[1,:], αFlexibleRef[2,:], c=colors[i], ms=ms, msw=msw, label=false)\n    else\n        scatter!(αRigidRef[1,:], αRigidRef[2,:], c=colors[i], ms=ms, msw=msw, label=false)\n    end\nend\nsavefig(\"heliosTrim_AoA.svg\") #hide\n\n# Trim elevator deflection\nplt2 = plot(xlabel=\"Payload [lb]\", ylabel=\"Trim elevator deflection [deg]\", xlims=[0,500], ylims=[0,10])\nplot!([NaN], [NaN], c=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], c=:black, ms=ms, label=\"Patil & Hodges (2006)\")\nfor (i,λ) in enumerate(λRange)\n    plot!(PRange, trimδ[i,:], c=colors[i], lw=lw, label=labels[i])\n    if i==1\n        scatter!(δFlexibleRef[1,:], δFlexibleRef[2,:], c=colors[i], ms=ms, msw=msw, label=false)\n    else\n        scatter!(δRigidRef[1,:], δRigidRef[2,:], c=colors[i], ms=ms, msw=msw, label=false)\n    end\nend\nsavefig(\"heliosTrim_delta.svg\") #hide\n\n# Trim thrust per motor\nplt3 = plot(xlabel=\"Payload [lb]\", ylabel=\"Trim thrust per motor [N]\", xlims=[0,500], ylims=[0,60])\nplot!([NaN], [NaN], c=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], c=:black, ms=ms, label=\"Patil & Hodges (2006)\")\nfor (i,λ) in enumerate(λRange)\n    plot!(PRange, trimThrust[i,:], c=colors[i], lw=lw, label=labels[i])\n    scatter!(TRef[1,:], TRef[2,:], c=colors[i], ms=ms, msw=msw, label=false)\nend\nsavefig(\"heliosTrim_thrust.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"","category":"page"},{"location":"literate/heliosTrim/","page":"Trimming a flying-wing HALE","title":"Trimming a flying-wing HALE","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/initialDispAndVelBeam/#Motion-of-a-simply-supported-beam-under-initial-conditions","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"This example illustrates how to set up a dynamic analysis with initial conditions. To do that, we take a simply supported beam under a specified combination of sinusoidal initial displacement and velocity.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/initialDispAndVelBeam/#Initial-conditions","page":"Motion of a simply supported beam under initial conditions","title":"Initial conditions","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"The setup of our problem begins by specifying the initial conditions, defined by the variable initialConditions. These could theoretically be defined by the displacement (u3), the angle of rotation (θ2), or both. However, experience shows that the most accurate results are found with the first option. The displacement and rotation (and their time rates) correspond to those of a simply supported beam's second bending mode shape. Notice that θ2 is the angle of rotation over the beam's arclength coordinate (x1) and p2 is the corresponding Wiener-Milenkovic rotation parameter.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"using AeroBeams\n\n# Select initial conditions as either \"displacement\", \"rotation\" or \"both\"\ninitialConditions = \"displacement\"\n\n# Initial conditions: sinusoidal displacement and velocity of u3 and/or rotation of θ2\nδ = 1e-3\nσ = 1e-1\nu3 = x1 -> δ*sin.(2π*x1/L)\nθ2 = x1 -> -δ*2π/L*cos.(2π*x1/L)\np2 = x1 -> 4*tan.(θ2(x1)/4)\nudot3 = x1 -> σ*sin.(2π*x1/L)\nθdot2 = x1 -> -σ*2π/L*cos.(2π*x1/L)\npdot2 = x1 -> sec.(0/4).^2 .* θdot2(x1)\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/#Beam","page":"Motion of a simply supported beam under initial conditions","title":"Beam","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"We create a simple isotropic beam for this example. The only relevant properties are the beam's length (L), bending stiffness (EI) and mass per unit length (ρA). The initial conditions are appended to the beam accordingly, and it is later updated (to incorporate those conditions) with the function update_beam!.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Beam\nL = 1\nEI = 1\nρA = 1\n∞ = 1e4\nnElem = 48\nbeam = create_Beam(name=\"beam\",length=L,nElements=nElem,S=[isotropic_stiffness_matrix(∞=∞,EIy=EI)],I=[inertia_matrix(ρA=ρA)])\nif initialConditions == \"displacement\"\n    beam.u0_of_x1=x1->[0; 0; u3(x1)]\n    beam.udot0_of_x1=x1->[0; 0; udot3(x1)]\nelseif initialConditions == \"rotation\"\n    beam.p0_of_x1=x1->[0; p2(x1); 0]\n    beam.pdot0_of_x1=x1->[0; pdot2(x1); 0]\nelseif initialConditions == \"both\"\n    beam.u0_of_x1=x1->[0; 0; u3(x1)]\n    beam.p0_of_x1=x1->[0; p2(x1); 0]\n    beam.udot0_of_x1=x1->[0; 0; udot3(x1)]\n    beam.pdot0_of_x1=x1->[0; pdot2(x1); 0]\nelse\n    error(\"Wrong initialConditions\")\nend\nupdate_beam!(beam)\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/#Boundary-conditions","page":"Motion of a simply supported beam under initial conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"The beam is simply-supported: pinned at one end and with a roller at the other.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# BCs\npin = create_BC(name=\"pin\",beam=beam,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p3A\"],values=[0,0,0,0,0])\nroller = create_BC(name=\"roller\",beam=beam,node=nElem+1,types=[\"u3A\"],values=[0])\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/#Model","page":"Motion of a simply supported beam under initial conditions","title":"Model","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"Our model consists of the beam and the associated boundary conditions. Notice that gravity is neglected.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Model\ninitialDispAndVelBeam = create_Model(name=\"initialDispAndVelBeam\",beams=[beam],BCs=[pin,roller])\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/#Creating-the-dynamic-problem","page":"Motion of a simply supported beam under initial conditions","title":"Creating the dynamic problem","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"The time and frequency variables of our problem are defined by the beam's second bending mode frequency, ω2, whose analytical value is known. We'll run the simulation for one cycle, and with a time step one hundredth of that.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Time and frequency variables\nω2 = (2π/L)^2*sqrt(EI/ρA)\nT = 2π/ω2\ncycles = 1\ntf = cycles*T\nΔt = T/100\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"In initial conditions problems, in general we do not know the initial values of all the states of the formulation (displacements, rotations, internal loads and sectional velocities). Thus, we have to estimate the unknown states in the initial step, most importantly the velocities and their rates. The whole simulation is dependent on the accuracy of that estimation, which can be controlled through the dynamic problem's keyword argument initialVelocitiesUpdateOptions. We create an instance of such a variable using the constructor InitialVelocitiesUpdateOptions. The most important arguments of that are the maximum number of iterations (for which the best value is often 2), maxIter, the relaxation factor (for which the best value is often 0.5), relaxFactor, and the time step (for which the best value is problem-dependent, but has to smaller than the time step of the problem itself), Δt.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Initial velocities update options\nif initialConditions == \"displacement\"\n    initialVelocitiesUpdateOptions = InitialVelocitiesUpdateOptions(maxIter=2,displayProgress=true, relaxFactor=0.5, Δt=Δt/1e3)\nelseif initialConditions == \"rotation\"\n    initialVelocitiesUpdateOptions = InitialVelocitiesUpdateOptions(maxIter=2, tol=1e-8, displayProgress=true, relaxFactor=0.5, Δt=Δt/1e3)\nelseif initialConditions == \"both\"\n    initialVelocitiesUpdateOptions = InitialVelocitiesUpdateOptions(maxIter=2, displayProgress=true, relaxFactor=0.5, Δt=Δt/1e3)\nend\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"Now we can create the problem and solve it.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Create and solve the problem\nusing Suppressor #hide\nproblem = create_DynamicProblem(model=initialDispAndVelBeam,finalTime=tf,Δt=Δt,initialVelocitiesUpdateOptions=initialVelocitiesUpdateOptions)\n@suppress begin #hide\nsolve!(problem)\nend #hide\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/#Post-processing","page":"Motion of a simply supported beam under initial conditions","title":"Post-processing","text":"","category":"section"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"First, we unpack the numerical solution of our variables of interest and compute analytical values.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Unpack numerical solution\nt = problem.timeVector\ntNorm = t/T\nu3_quarter = [problem.nodalStatesOverTime[i][div(nElem,4)].u_n2[3] for i in 1:length(tNorm)]\nV3_quarter = [(problem.elementalStatesOverTime[i][div(nElem,4)].V[3]+problem.elementalStatesOverTime[i][div(nElem,4)+1].V[3])/2.0 for i in 1:length(tNorm)]\nVdot3_quarter = [(problem.elementalStatesRatesOverTime[i][div(nElem,4)].Vdot[3]+problem.elementalStatesRatesOverTime[i][div(nElem,4)+1].Vdot[3])/2.0 for i in 1:length(tNorm)]\nθ2_root = [problem.nodalStatesOverTime[i][1].θ_n1 for i in 1:length(tNorm)]\nΩ2_mid = [(problem.elementalStatesOverTime[i][div(nElem,2)].Ω[2]+problem.elementalStatesOverTime[i][div(nElem,2)+1].Ω[2])/2.0 for i in 1:length(tNorm)]\nΩdot2_mid = [(problem.elementalStatesRatesOverTime[i][div(nElem,2)].Ωdot[2]+problem.elementalStatesRatesOverTime[i][div(nElem,2)+1].Ωdot[2])/2.0 for i in 1:length(tNorm)]\n\n# Compute analytical values\nu3_quarter_analytic = δ*cos.(ω2*t)*sin(2π*1/4) + σ/ω2*sin.(ω2*t)*sin(2π*1/4)\nV3_quarter_analytic = -δ*ω2*sin.(ω2*t)*sin(2π*1/4) + σ*cos.(ω2*t)*sin(2π*1/4)\nVdot3_quarter_analytic = -δ*ω2^2*cos.(ω2*t)*sin(2π*1/4) + -σ*ω2*sin.(ω2*t)*sin(2π*1/4)\nθ2_root_analytic = -δ*2π/L*cos.(ω2*t)*cos(2π*0) + -σ*2π/L/ω2*sin.(ω2*t)*cos(2π*0)\nΩ2_mid_analytic = δ*2π/L*ω2*sin.(ω2*t)*cos(2π*1/2) + -σ*2π/L*cos.(ω2*t)*cos(2π*1/2)\nΩdot2_mid_analytic = δ*2π/L*ω2^2*cos.(ω2*t)*cos(2π*1/2) + σ*2π/L*ω2*sin.(ω2*t)*cos(2π*1/2)\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"Now let's plot the displacement, rotation, velocities and accelerations at the appropriate points of the beam. The correspondance with the analytical reference is very good, except for the angular acceleration at the midpoint, which oscillates around the analytical solution. That indicates the estimation of the initial value of that variable was not accurate, which may happen for the rates of the velocity states (dotV and dotOmega).","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# Displacement at quarter-length\nplt1 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$u_3\\$ at \\$x_1=L/4\\$ [m]\")\nplot!(tNorm,u3_quarter, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],u3_quarter_analytic[1:5:end], c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_disp.svg\") #hide\n\n# Velocity at quarter-length\nplt2 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$V_3\\$ at \\$x_1=L/4\\$ [m/s]\")\nplot!(tNorm,V3_quarter, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],V3_quarter_analytic[1:5:end], c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_vel.svg\") #hide\n\n# Acceleration at quarter-length\nplt3 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$\\\\dot{V}_3\\$ at \\$x_1=L/4\\$ [m/\\$s^2\\$]\")\nplot!(tNorm,Vdot3_quarter, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],Vdot3_quarter_analytic[1:5:end], c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_acc.svg\") #hide\n\n# Rotation at root\nplt4 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$\\\\theta/(2\\\\pi)\\$ at \\$x_1=0\\$\")\nplot!(tNorm,θ2_root/(2π), c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],θ2_root_analytic[1:5:end]/(2*π), c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_rot.svg\") #hide\n\n# Angular velocity at mid-length\nplt5 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$\\\\Omega_2\\$ at \\$x_1=L/2\\$ [rad/s]\")\nplot!(tNorm,Ω2_mid, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],Ω2_mid_analytic[1:5:end], c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_angVel.svg\") #hide\n\n# Angular acceleration at mid-length\nplt6 = plot(xlabel=\"\\$t/T\\$\", ylabel=\"\\$\\\\dot{\\\\Omega}_2\\$ at \\$x_1=L/2\\$ [rad/\\$s^2\\$]\")\nplot!(tNorm,Ωdot2_mid, c=:black, lw=2, label=\"AeroBeams\")\nscatter!(tNorm[1:5:end],Ωdot2_mid_analytic[1:5:end], c=:blue, ms=5, msw=0, label=\"Analytical\")\nsavefig(\"initialDispAndVelBeam_angAcc.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"Finally, we can visualize the motion of the beam using the function plot_dynamic_deformation with the appropriate inputs.","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"# Animation\n@suppress begin #hide\nplot_dynamic_deformation(problem,scale=1/δ/10,scalePos=[0.15;-0.05;0],timeStampPos=[0.5;-0.05;0],plotFrequency=1,plotLimits=([0,L],[-L/2,L/2],[-L/3,L/3]),save=true,savePath=\"/docs/build/literate/initialDispAndVelBeam_motion.gif\")\nnothing #hide\nend #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"(Image: )","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"nothing #hide","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"","category":"page"},{"location":"literate/initialDispAndVelBeam/","page":"Motion of a simply supported beam under initial conditions","title":"Motion of a simply supported beam under initial conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/#Flutter-analysis-of-the-Pazy-wing","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"","category":"section"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"This example illustrates how to set up a flutter (eigen) analysis, using the Technion's Pazy wing benchmark. The sectional properties of the wing's spar and the aerodynamic tip loss function were defined by Riso and Cesnik. The data is publicly available at https://github.com/UM-A2SRL/AePW3-LDWG.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"(Image: )","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"Pazy wing in the wind tunnel by Avin et al.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/#Problem-setup","page":"Flutter analysis of the Pazy wing","title":"Problem setup","text":"","category":"section"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"Let's begin by setting the variables of our problem. In this example we will analyze the flutter onset and offset boundaries of the clamped wing under several root pitch angles, defined by the array θRange.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"using AeroBeams, LinearInterpolations, DelimitedFiles\n\n# Aerodynamic solver\naeroSolver = Indicial()\n\n# Airfoil section\nairfoil = deepcopy(flatPlate)\n\n# Flag for tip correction\nhasTipCorrection = true\n\n# Tip correction function type\ntipLossType = \"Exponential\"\n\n# Flag for upright position\nupright = true\n\n# Gravity\ng = 0\n\n# Flag for small angles approximation\nsmallAngles = true\n\n# Fixed geometrical and discretization properties\nnElem,L,chord,normSparPos = geometrical_properties_Pazy()\n\n# Set system solver options\nσ0 = 0.5\nσstep = 0.5\nNR = create_NewtonRaphson(initialLoadFactor=σ0,maximumLoadFactorStep=σstep)\n\n# Number of vibration modes\nnModes = 3\n\n# Set pitch angle and airspeed ranges\nθRange = unique([vcat(0:0.25:1)...,vcat(1:0.5:7)...])\nURange = collect(0:1:120)\n\n# Initialize outputs\nuntrackedFreqs = Array{Vector{Float64}}(undef,length(θRange),length(URange))\nuntrackedDamps = Array{Vector{Float64}}(undef,length(θRange),length(URange))\nuntrackedEigenvectors = Array{Matrix{ComplexF64}}(undef,length(θRange),length(URange))\nfreqs = Array{Vector{Float64}}(undef,length(θRange),length(URange))\ndamps = Array{Vector{Float64}}(undef,length(θRange),length(URange))\ntip_OOP = Array{Float64}(undef,length(θRange),length(URange))\nflutterOnsetSpeedsOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nflutterOnsetFreqsOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nflutterOnsetDispOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nflutterOffsetSpeedsOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nflutterOffsetFreqsOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nflutterOffsetDispOfMode = Array{Vector{Float64}}(undef,length(θRange),nModes)\nnothing #hide","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/#Solving-the-problem","page":"Flutter analysis of the Pazy wing","title":"Solving the problem","text":"","category":"section"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"In the following loops, we create new model instances with the combination of pitch angle and airspeed, create and solve the eigenproblem, and then extract the outputs of interest. The model creation process is streamlined with the function create_Pazy, taking the appropriate inputs. Once the solutions for all airspeeds of each root pitch angle are found, we compute the flutter onset and offset speeds (if any), and the respective tip out-of-plane displacement of the wing for each vibration mode.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"# Sweep root angle\nfor (i,θ) in enumerate(θRange)\n    # Sweep airspeed\n    for (j,U) in enumerate(URange)\n        # Model\n        PazyWingFlutterPitchRange,_ = create_Pazy(aeroSolver=aeroSolver,airfoil=airfoil,hasTipCorrection=hasTipCorrection,tipLossType=tipLossType,upright=upright,θ=θ*π/180,airspeed=U,g=g,smallAngles=smallAngles)\n        # Create and solve problem\n        problem = create_EigenProblem(model=PazyWingFlutterPitchRange,nModes=nModes,systemSolver=NR)\n        solve!(problem)\n        # Frequencies, dampings and eigenvectors\n        untrackedFreqs[i,j] = problem.frequenciesOscillatory\n        untrackedDamps[i,j] = round_off!(problem.dampingsOscillatory,1e-8)\n        untrackedEigenvectors[i,j] = problem.eigenvectorsOscillatoryCplx\n        # Get OOP displacement at midchord\n        tip_p = problem.nodalStatesOverσ[end][nElem].p_n2_b\n        R,_ = rotation_tensor_WM(tip_p)\n        Δ = R*[0; 1; 0]\n        tip_twist = asind(Δ[3])\n        tip_OOP[i,j] = -(problem.nodalStatesOverσ[end][nElem].u_n2[1] - chord*(1/2-normSparPos)*sind(tip_twist))\n    end\n    # Apply mode tracking\n    freqs[i,:],damps[i,:],_ = mode_tracking(URange,untrackedFreqs[i,:],untrackedDamps[i,:],untrackedEigenvectors[i,:])\n    # Separate frequencies and damping ratios by mode\n    modeFrequencies = Array{Vector{Float64}}(undef,nModes)\n    modeDampings = Array{Vector{Float64}}(undef,nModes)\n    modeDampingRatios = Array{Vector{Float64}}(undef,nModes)\n    for mode in 1:nModes\n        modeFrequencies[mode] = [freqs[i,j][mode] for j in eachindex(URange)]\n        modeDampings[mode] = [damps[i,j][mode] for j in eachindex(URange)]\n        modeDampingRatios[mode] = modeDampings[mode]./modeFrequencies[mode]\n    end\n    # Loop over modes: compute flutter onset and offset speeds, respective frequencies and OOP displacements\n    for mode in 1:nModes\n        # Find flutter onset indices\n        onsetIndices = findall((modeDampings[mode][2:end] .> 0) .& (modeDampings[mode][1:end-1] .< 0)) .+ 1\n        nIndOn = length(onsetIndices)\n        # Loop flutter onset indices\n        flutterOnsetSpeeds,flutterOnsetFreqs,flutterOnsetDisp = Vector{Float64}(undef,nIndOn),Vector{Float64}(undef,nIndOn),Vector{Float64}(undef,nIndOn)\n        for (n,k) in enumerate(onsetIndices)\n            flutterOnsetSpeeds[n] = LinearInterpolations.interpolate(modeDampings[mode][k-1:k],URange[k-1:k],0)\n            flutterOnsetFreqs[n] = LinearInterpolations.interpolate(modeDampings[mode][k-1:k],modeFrequencies[mode][k-1:k],0)\n            flutterOnsetDisp[n] = LinearInterpolations.interpolate(modeDampings[mode][k-1:k],tip_OOP[i,k-1:k]/L*100,0)\n        end\n        if nIndOn == 0\n            flutterOnsetSpeeds,flutterOnsetFreqs,flutterOnsetDisp = [NaN],[NaN],[NaN]\n        end\n        # Set flutter onset variables for current mode\n        flutterOnsetSpeedsOfMode[i,mode] = flutterOnsetSpeeds\n        flutterOnsetFreqsOfMode[i,mode] = flutterOnsetFreqs\n        flutterOnsetDispOfMode[i,mode] = flutterOnsetDisp\n        # Find flutter offset indices\n        offsetIndices = findall((modeDampings[mode][2:end] .< 0) .& (modeDampings[mode][1:end-1] .> 0)) .+ 1\n        nIndOff = length(offsetIndices)\n        # Find flutter offset variables\n        flutterOffsetSpeeds,flutterOffsetFreqs,flutterOffsetDisp = Vector{Float64}(undef,nIndOff),Vector{Float64}(undef,nIndOff),Vector{Float64}(undef,nIndOff)\n        # Loop flutter offset indices\n        for (n,k) in enumerate(offsetIndices)\n            flutterOffsetSpeeds[n] = LinearInterpolations.interpolate(-modeDampings[mode][k-1:k],URange[k-1:k],0)\n            flutterOffsetFreqs[n] = LinearInterpolations.interpolate(-modeDampings[mode][k-1:k],modeFrequencies[mode][k-1:k],0)\n            flutterOffsetDisp[n] = LinearInterpolations.interpolate(-modeDampings[mode][k-1:k],tip_OOP[i,k-1:k]/L*100,0)\n        end\n        if nIndOff == 0\n            flutterOffsetSpeeds,flutterOffsetFreqs,flutterOffsetDisp = [NaN],[NaN],[NaN]\n        end\n        # Set flutter offset variables for current mode\n        flutterOffsetSpeedsOfMode[i,mode] = flutterOffsetSpeeds\n        flutterOffsetFreqsOfMode[i,mode] = flutterOffsetFreqs\n        flutterOffsetDispOfMode[i,mode] = flutterOffsetDisp\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/#Post-processing","page":"Flutter analysis of the Pazy wing","title":"Post-processing","text":"","category":"section"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"Post-processing begins by loading the reference experimental data by Drachinski et al. and numerical data by Riso & Cesnik, by Riso & Cesnik and of Sharpy.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"# Load reference data\nrootPitchVelUp = [3; 5; 7]\nrootPitchVelDown = [3; 5]\nflutterOnsetVelUp = [49; 43; 38]\nflutterOffsetVelUp = [58; 51; 46]\nflutterOnsetVelDown = [55; 48]\nflutterOffsetVelDown = [40; 36]\nflutterOnsetDispUp = [23; 24.5; 26]\nflutterOnsetDispDown = [28.5; 31.5]\nflutterBoundaryDisp_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/flutterBoundaryDisp_UMNAST.txt\")\nflutterBoundaryPitch_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/flutterBoundaryPitch_UMNAST.txt\")\nflutterBoundaryDisp_UMNAST_PanelCoeffs = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/flutterBoundaryDisp_UMNAST_PanelCoeffs.txt\")\nflutterBoundaryPitch_UMNAST_PanelCoeffs = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/flutterBoundaryPitch_UMNAST_PanelCoeffs.txt\")\nflutterBoundary_UVsPitch_Lambda0_Sharpy = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/sweptPazy/flutterBoundary_UVsPitch_Lambda0_Sharpy.txt\")\nflutterBoundary_dispVsU_Lambda0_Sharpy = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/sweptPazy/flutterBoundary_dispVsU_Lambda0_Sharpy.txt\")\nnothing #hide","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"The Pazy wing is known from the tests of Drachinski et al. to have a hump flutter mode, that is, a mode that becomes unstable over a certain region of airspeeds. The size of this region is dependent on the root pitch angle of the wing. Let us now plot the flutter boundaries of this hump mode. There is good agreement with the experimental data, but notice that to capture the hysterysis on the flutter onset and offset we would need an analysis more complex than an eigenvalue one. The UM/NAST data by Riso and Cesnik, Riso and Cesnik and the Sharpy results are also plotted for comparison.","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"using Plots, ColorSchemes\nts = 10\nfs = 16\nlfs = 9\nlw = 2\nms = 10\nms2 = 4\nmsw = 0\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n# Flutter onset and offset speeds vs root pitch angle\nhumpMode = 3\nx1 = [flutterOnsetSpeedsOfMode[i,humpMode][1] for i in eachindex(θRange)]\nx2 = [flutterOffsetSpeedsOfMode[i,humpMode][1] for i in eachindex(θRange)]\nplt1 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Root pitch angle [deg]\", xlims=[30,90], ylims=[0,7.25], xticks=collect(30:10:90), yticks=collect(0:1:7), legend=:topright, tickfont=font(ts), guidefont=font(fs), legendfontsize=lfs)\nplot!(Shape(vcat(x1,reverse(x2)),vcat(θRange,reverse(θRange))), fillcolor = plot_color(:red, 0.25), lw=lw, label=\"AeroBeams hump flutter region\")\nscatter!(flutterOnsetVelUp, rootPitchVelUp, shape=:rtriangle, mc=:red, ms=ms, msw=msw, label=\"Test onset up\")\nscatter!(flutterOffsetVelUp, rootPitchVelUp, shape=:rtriangle, mc=:green, ms=ms, msw=msw, label=\"Test offset up\")\nscatter!(flutterOnsetVelDown, rootPitchVelDown, shape=:ltriangle, mc=:red, ms=ms, msw=msw, label=\"Test onset down\")\nscatter!(flutterOffsetVelDown, rootPitchVelDown, shape=:ltriangle, mc=:green, ms=ms, msw=msw, label=\"Test offset down\")\nplot!(flutterBoundaryPitch_UMNAST[1,:], flutterBoundaryPitch_UMNAST[2,:], c=:gold, ls=:dash, lw=lw, marker=:circle, ms=ms2, msw=msw, label=\"UM/NAST (Exp. loss)\")\nplot!(flutterBoundaryPitch_UMNAST_PanelCoeffs[1,:], flutterBoundaryPitch_UMNAST_PanelCoeffs[2,:], c=:brown, ls=:dash, lw=lw, marker=:circle, ms=ms2, msw=msw, label=\"UM/NAST (Panel coeffs.)\")\nplot!(flutterBoundary_UVsPitch_Lambda0_Sharpy[1,1:19], flutterBoundary_UVsPitch_Lambda0_Sharpy[2,1:19], c=:magenta, ls=:dash, lw=lw, marker=:diamond, ms=ms2, msw=msw, label=\"Sharpy\")\nsavefig(\"PazyWingFlutterPitchRange_flutterBoundaryPitch.svg\") #hide\nnothing #hide\n\n# Flutter onset and offset speeds vs tip OOP displacement for varying root pitch angle\nθ2plot = [0.5,1,2,3,5,7]\nindθ2plot = findall(x -> any(isapprox(x, θ; atol=1e-10) for θ in θ2plot), θRange)\nθcolors = cgrad([:blue, :red], length(θ2plot), categorical=true)\nxθ = [ 5,  9, 12, 14, 16, 17.5]\nyθ = [60, 55, 48, 43, 38, 34]\nx1 = [flutterOnsetDispOfMode[i,humpMode][1] for i in eachindex(θRange)]\nx2 = [flutterOffsetDispOfMode[i,humpMode][1] for i in eachindex(θRange)]\ny1 = [flutterOnsetSpeedsOfMode[i,humpMode][1] for i in eachindex(θRange)]\ny2 = [flutterOffsetSpeedsOfMode[i,humpMode][1] for i in eachindex(θRange)]\nplt2 = plot(xlabel=\"Tip OOP displacement [% semispan]\", ylabel=\"Airspeed [m/s]\", xlims=[0,32], ylims=[30,90], xticks=collect(0:5:30), yticks=collect(30:10:90), legend=:bottomleft)\nplot!(Shape(vcat(x1,reverse(x2)),vcat(y1,reverse(y2))), fillcolor = plot_color(:red, 0.25), lw=2, label=\"Hump flutter region\")\nfor (n,ind) in enumerate(indθ2plot)\n    θ = θ2plot[n]\n    plot!(tip_OOP[ind,:]/L*100, URange, c=θcolors[n], ls=:dash, lw=2, label=false)\n    annotate!([xθ[n]],[yθ[n]], text(\"\\$$(round(θ2plot[n],digits=1)) ^\\\\circ\\$\", 10, :bottom, θcolors[n]))\nend\nscatter!(flutterOnsetDispUp, flutterOnsetVelUp, shape=:rtriangle, mc=:red, ms=ms, msw=msw, label=\"Test onset up\")\nscatter!(flutterOnsetDispDown, flutterOnsetVelDown, shape=:ltriangle, mc=:red, ms=ms, msw=msw, label=\"Test onset down\")\nplot!(flutterBoundaryDisp_UMNAST[1,:], flutterBoundaryDisp_UMNAST[2,:], c=:gold, ls=:dash, lw=lw, marker=:circle, ms=ms2, msw=msw, label=false)\nplot!(flutterBoundaryDisp_UMNAST_PanelCoeffs[1,:], flutterBoundaryDisp_UMNAST_PanelCoeffs[2,:], c=:brown, ls=:dash, lw=lw, marker=:circle, ms=ms2, msw=msw, label=false)\nplot!(flutterBoundary_dispVsU_Lambda0_Sharpy[1,:]*100,flutterBoundary_dispVsU_Lambda0_Sharpy[2,:], c=:magenta, ls=:dash, lw=lw, marker=:diamond, ms=ms2, msw=msw, label=false)\nsavefig(\"PazyWingFlutterPitchRange_flutterBoundaryDisp.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"(Image: ) (Image: )","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"","category":"page"},{"location":"literate/PazyWingFlutterPitchRange/","page":"Flutter analysis of the Pazy wing","title":"Flutter analysis of the Pazy wing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/#Flutter-analysis-of-a-wing-with-flared-folding-wingtip-(FFWT)","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"","category":"section"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"This example illustrates how to set up a flutter analysis for a wing featuring a flared folding wingtip (FFWT). The influence of the root pitch angle on the behavior of this wing model was studied numerically in Healy's PhD Thesis.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"(Image: )","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"Top view of baseline wing model featuring a FFWT by Healy et al.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/#Problem-setup","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Problem setup","text":"","category":"section"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"Let's begin by setting the variables of our problem. In this example we will analyze the coasting angle and stability of the free FFWT under several root pitch angles. The flare angle of the wingtip is of 15 degrees, and the airspeed is varied. The influence of three-dimensional aerodynamic effects is investigated through the tip loss factor, for which two values are assumed (one leading to some tip loss, and another leading to no tip loss). The hinge is assumed as a universal joint (allowing movement about the three axes), but the restriction of the in-plane bending DOF is modeled through a stiff spring with value kIPBendingHinge. We select the addedResidual as the method for the solution of the hinge constraint. Only the flutter mechanism arising from the interaction of the first two modes (the wingtip flapping mode and the first OOP bending mode) are analyzed.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"using AeroBeams, DelimitedFiles\n\n# Hinge configuration\nhingeConfiguration = \"free\"\n\n# Tip loss factor range\nτRange = [12,Inf64]\n\n# Pitch angle range [rad]\nθRange = π/180*[0,3,6]\n\n# Airspeed range [m/s]\nURange = collect(1:1:40)\n\n# Flare angle\nΛ = 15*π/180\n\n# Gravity\ng = 9.80665\n\n# Stiffness of the spring around the hinge for in-plane bending\nkIPBendingHinge = 1e1\n\n# Discretization\nnElementsInner = 16\nnElementsFFWT = 4\n\n# Tip loss flag\nhasTipCorrection = true\n\n# Solution method for constraint\nsolutionMethod = \"addedResidual\"\n\n# System solver\nσ0 = 1\nmaxIter = 100\nrelTol = 1e-8\nNR = create_NewtonRaphson(displayStatus=false,initialLoadFactor=σ0,maximumIterations=maxIter,relativeTolerance=relTol)\n\n# Number of modes\nnModes = 2\n\n# Initialize outputs\nuntrackedFreqs = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nuntrackedDamps = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nuntrackedEigenvectors = [fill(NaN64+im*NaN64, nModes, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nfreqs = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\ndamps = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nmodeFrequencies = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nmodeDampings = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nmodeDampingRatios = [fill(NaN64, nModes) for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nϕHinge = [NaN64 for τ in 1:length(τRange), Λ in 1:length(θRange), U in 1:length(URange)]\nproblem = Array{EigenProblem}(undef,length(τRange),length(θRange),length(URange))\nnothing #hide","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/#Solving-the-problem","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Solving the problem","text":"","category":"section"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"In the following loops, we create new model instances for each combination of tip loss decay factor, pitch angle and airspeed, create and solve the eigen problem, and then extract the coasting angle of the FFWT (ϕHinge) and the frequencies, dampings and eigenvectors. The model creation process is streamlined with the function create_HealyBaselineFFWT, taking the appropriate inputs.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"using Suppressor #hide\n# Sweep tip loss factor\nfor (i,τ) in enumerate(τRange)\n    # Sweep pitch angle\n    for (j,θ) in enumerate(θRange)\n        # Sweep airspeed\n        for (k,U) in enumerate(URange)\n            # Update model\n            model = create_HealyBaselineFFWT(solutionMethod=solutionMethod,hingeConfiguration=hingeConfiguration,flareAngle=Λ,airspeed=U,pitchAngle=θ,hasTipCorrection=hasTipCorrection,tipLossDecayFactor=τ,g=g,kIPBendingHinge=kIPBendingHinge,nElementsInner=nElementsInner,nElementsFFWT=nElementsFFWT)\n            # Create and solve problem\n            problem[i,j,k] = create_EigenProblem(model=model,nModes=nModes,systemSolver=NR,frequencyFilterLimits=[1e-2*U,Inf])\n        @suppress begin #hide\n                solve!(problem[i,j,k])\n        end #hide\n            # Get outputs, if converged\n            if problem[i,j,k].systemSolver.convergedFinalSolution\n                # Frequencies and dampings\n                untrackedFreqs[i,j,k] = problem[i,j,k].frequenciesOscillatory\n                untrackedDamps[i,j,k] = round_off!(problem[i,j,k].dampingsOscillatory,1e-8)\n                untrackedEigenvectors[i,j,k] = problem[i,j,k].eigenvectorsOscillatoryCplx\n                # Hinge fold angle\n                ϕHinge[i,j,k] = -problem[i,j,k].model.hingeAxisConstraints[1].ϕ*180/π\n            end\n        end\n        # Apply mode tracking\n        freqs[i,j,:],damps[i,j,:],_ = mode_tracking(URange,untrackedFreqs[i,j,:],untrackedDamps[i,j,:],untrackedEigenvectors[i,j,:])\n        # Separate frequencies and damping ratios by mode\n        for mode in 1:nModes\n            modeFrequencies[i,j,mode] = [freqs[i,j,k][mode] for k in eachindex(URange)]\n            modeDampings[i,j,mode] = [damps[i,j,k][mode] for k in eachindex(URange)]\n            modeDampingRatios[i,j,mode] = modeDampings[i,j,mode]./modeFrequencies[i,j,mode]\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/#Post-processing","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Post-processing","text":"","category":"section"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"The post-processing begins by loading the reference data.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"# Load reference data\nfold_ST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/fold_ST.txt\")\nfold_VLM = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/fold_VLM.txt\")\nfreq1_ST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/freq1_ST.txt\")\nfreq2_ST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/freq2_ST.txt\")\nfreq1_VLM = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/freq1_VLM.txt\")\nfreq2_VLM = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/freq2_VLM.txt\")\ndamp1_ST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/damp1_ST.txt\")\ndamp2_ST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/damp2_ST.txt\")\ndamp1_VLM = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/damp1_VLM.txt\")\ndamp2_VLM = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyBaselineFFWTfreeFlutterAoARangeURange/damp2_VLM.txt\")\n\n# Adjust data for plots by padding matrices with NaN\nmatrices = Dict(\n    :fold_ST => fold_ST,\n    :fold_VLM => fold_VLM,\n    :freq1_ST => freq1_ST,\n    :freq2_ST => freq2_ST,\n    :freq1_VLM => freq1_VLM,\n    :freq2_VLM => freq2_VLM,\n    :damp1_ST => damp1_ST,\n    :damp2_ST => damp2_ST,\n    :damp1_VLM => damp1_VLM,\n    :damp2_VLM => damp2_VLM,\n)\nfor key in keys(matrices)\n    matrices[key] .= [x == \"\" ? NaN64 : x for x in matrices[key]]\nend\nfold_ST = matrices[:fold_ST]\nfold_VLM = matrices[:fold_VLM]\nfreq1_ST = matrices[:freq1_ST]\nfreq2_ST = matrices[:freq2_ST]\nfreq1_VLM = matrices[:freq1_VLM]\nfreq2_VLM = matrices[:freq2_VLM]\ndamp1_ST = matrices[:damp1_ST]\ndamp2_ST = matrices[:damp2_ST]\ndamp1_VLM = matrices[:damp1_VLM]\ndamp2_VLM = matrices[:damp2_VLM]\n\nnothing #hide","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"We can now plot the coasting (fold) angle of the FFWT and the evolution of the frequencies and dampings of the modes of vibration as functions of airspeed for each root pitch angle. The following reference results were taken from Fig. 3.32 of Healy's PhD Thesis. Healy's numerical method is composed of a Rayleigh-Ritz structural model coupled to a vortex-lattice method (VLM) or strip-theory (ST) method for aerodynamics, with the flared folding wingtip being modeled as a point inertia connected to the inner wing via a hinge. The behavior of the fold angle is captured with reasonable accuracy, and the correlation of the frequencies and dampings with the reference data is fair, although AeroBeams predicts smaller dampings, and consequently, sooner flutter onset.","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"using Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\ncolors = cgrad(:rainbow, length(θRange), categorical=true)\nlw = 2\n\n# Fold angle - without tip loss\nplt1 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Fold angle [deg]\", xlims=[0,40], ylims=[-90,30], yticks=-90:30:30, title=\"Without tip loss\")\nplot!([NaN],[NaN], lc=:black, ls=:dash, lw=lw, label=\"Healy (2023) - ST\")\nplot!([NaN],[NaN], lc=:black, ls=:solid, lw=lw, label=\"AeroBeams\")\nfor (j,θ) in enumerate(θRange)\n    plot!(fold_ST[2*j-1,:],fold_ST[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(URange, ϕHinge[2,j,:], c=colors[j], lw=lw, label=\"\\$\\\\theta = $(round(Int,θ*180/π)) \\\\degree\\$\")\nend\nsavefig(\"HealyBaselineFFWTfreeFlutterAoARangeURange_fold_tipLoss0.svg\")\n\n# Fold angle - with tip loss\nplt2 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Fold angle [deg]\", xlims=[0,40], ylims=[-90,30], yticks=-90:30:30, title=\"With tip loss\")\nplot!([NaN],[NaN], lc=:black, ls=:dash, lw=lw, label=\"Healy (2023) - VLM\")\nplot!([NaN],[NaN], lc=:black, ls=:solid, lw=lw, label=\"AeroBeams\")\nfor (j,θ) in enumerate(θRange)\n    plot!(fold_VLM[2*j-1,:],fold_VLM[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(URange, ϕHinge[1,j,:], c=colors[j], lw=lw, label=\"\\$\\\\theta = $(round(Int,θ*180/π)) \\\\degree\\$\")\nend\nsavefig(\"HealyBaselineFFWTfreeFlutterAoARangeURange_fold_tipLoss1.svg\")\n\n# V-g-f - without tip loss\nrange2plot = 1:findfirst(x -> x >= 22, URange)\nplt31 = plot(ylabel=\"Frequency [Hz]\", xlims=[0,30], ylims=[0,5], title=\"Without tip loss\", legend=:bottomright)\nplt32 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Damping Ratio\", xlims=[0,30], ylims=[-0.5,0.25], legend=:bottomleft)\nplot!(plt31, [NaN],[NaN], lc=:black, ls=:dash, lw=lw, label=\"Healy (2023) - ST\")\nplot!(plt31, [NaN],[NaN], lc=:black, ls=:solid, lw=lw, label=\"AeroBeams\")\nfor (j,θ) in enumerate(θRange)\n    for mode in 1:nModes\n        plot!(plt31, URange[range2plot], modeFrequencies[2,j,mode][range2plot]/(2*π), c=colors[j], lw=lw, label=false)\n        plot!(plt32, URange[range2plot], modeDampingRatios[2,j,mode][range2plot], c=colors[j], lw=lw, label=false)\n    end\n    plot!(plt31, freq1_ST[2*j-1,:], freq1_ST[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt31, freq2_ST[2*j-1,:], freq2_ST[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt32, damp1_ST[2*j-1,:], damp1_ST[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt32, damp2_ST[2*j-1,:], damp2_ST[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt32,[NaN],[NaN], c=colors[j], ls=:solid, lw=lw, label=\"\\$\\\\theta = $(round(Int,θ*180/π)) \\\\degree\\$\")\nend\nplt3 = plot(plt31,plt32, layout=(2,1))\nsavefig(\"HealyBaselineFFWTfreeFlutterAoARangeURange_Vgf_tipLoss0.svg\")\n\n# V-g-f - with tip loss\nplt41 = plot(ylabel=\"Frequency [Hz]\", xlims=[0,30], ylims=[0,5], title=\"With tip loss\", legend=:bottomright)\nplt42 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Damping Ratio\", xlims=[0,30], ylims=[-0.5,0.25], legend=:bottomleft)\nplot!(plt41, [NaN],[NaN], lc=:black, ls=:dash, lw=lw, label=\"Healy (2023) - VLM\")\nplot!(plt41, [NaN],[NaN], lc=:black, ls=:solid, lw=lw, label=\"AeroBeams\")\nfor (j,θ) in enumerate(θRange)\n    for mode in 1:nModes\n        plot!(plt41, URange, modeFrequencies[1,j,mode]/(2*π), c=colors[j], lw=lw, label=false)\n        plot!(plt42, URange, modeDampingRatios[1,j,mode], c=colors[j], lw=lw, label=false)\n    end\n    plot!(plt41, freq1_VLM[2*j-1,:], freq1_VLM[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt41, freq2_VLM[2*j-1,:], freq2_VLM[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt42, damp1_VLM[2*j-1,:], damp1_VLM[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt42, damp2_VLM[2*j-1,:], damp2_VLM[2*j,:], c=colors[j], ls=:dash, lw=lw, label=false)\n    plot!(plt42,[NaN],[NaN], c=colors[j], ls=:solid, lw=lw, label=\"\\$\\\\theta = $(round(Int,θ*180/π)) \\\\degree\\$\")\nend\nplt4 = plot(plt41,plt42, layout=(2,1))\nsavefig(\"HealyBaselineFFWTfreeFlutterAoARangeURange_Vgf_tipLoss1.svg\")\n\nnothing #hide","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"","category":"page"},{"location":"literate/HealyBaselineFFWTfreeFlutterAoARangeURange/","page":"Flutter analysis of a wing with flared folding wingtip (FFWT)","title":"Flutter analysis of a wing with flared folding wingtip (FFWT)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/PazyWingTorsionTest/#Static-structural-analysis-of-the-Pazy-wing","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"","category":"section"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"This example illustrates how to set up a static structural analysis, using the Technion's Pazy wing benchmark. More specifically, we'll simulate a coupled bending-torsion test. The sectional properties of the wing's spar and the aerodynamic tip loss function were defined by Riso and Cesnik. That data is publicly available at https://github.com/UM-A2SRL/AePW3-LDWG.","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"(Image: ) Pazy wing coupled bending-torsion test by Avin et al.","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/PazyWingTorsionTest/#Problem-setup","page":"Static structural analysis of the Pazy wing","title":"Problem setup","text":"","category":"section"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"Let's begin by setting the variables of our problem. In this example we will analyze the displacements and twist of the clamped wing caused by the attachment of a range of tip masses. Notice that we bring into scope some fixed geometrical and discretization properties of the wing's beam through the function geometrical_properties_Pazy.","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"using AeroBeams, DelimitedFiles\n\n# Fixed geometrical properties\nnElem,L,chord,normSparPos = geometrical_properties_Pazy()\n\n# Set tip mass range\nmRange = collect(0:0.1:3)\n\n# Initialize outputs\ntip_twist = Array{Float64}(undef,length(mRange))\ntip_OOP = Array{Float64}(undef,length(mRange))\nnothing #hide","category":"page"},{"location":"literate/PazyWingTorsionTest/#Solving-the-problem","page":"Static structural analysis of the Pazy wing","title":"Solving the problem","text":"","category":"section"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"In the following loop, we create new model instances for each tip mass value, create and solve the steady problem, and then extract the outputs of interest. The tip mass is positioned in such a way to cause not only bending but also significant torsion of the wing. The model creation process is streamlined with the function create_Pazy, taking the appropriate inputs. Notice that the twist angle is computed as the arcsine of the difference in \"height\" between the leading edge and trailing edge of the wingtip (throught the rotation of the local basis vector pointing in the x2-direction).","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"# Sweep tip mass\nfor (i,m) in enumerate(mRange)\n    # Create model with current tip mass 80 mm behind the trailing-edge\n    PazyWingTorsionTest,_ = create_Pazy(tipMass=m,ηtipMass=[0;-(chord*(1-normSparPos)+0.08);0])\n    # Create and solve problem\n    global problem = create_SteadyProblem(model=PazyWingTorsionTest)\n    solve!(problem)\n    # Get twist and OOP displacement at midchord\n    tip_p = problem.nodalStatesOverσ[end][nElem].p_n2\n    R,_ = rotation_tensor_WM(tip_p)\n    Δ = R*[0; 1; 0]\n    tip_twist[i] = asind(Δ[3])\n    tip_OOP[i] = problem.nodalStatesOverσ[end][nElem].u_n2[3] - chord*(1/2-normSparPos)*sind(tip_twist[i])\nend\nnothing #hide","category":"page"},{"location":"literate/PazyWingTorsionTest/#Post-processing","page":"Static structural analysis of the Pazy wing","title":"Post-processing","text":"","category":"section"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"The post-processing begins by loading the reference data.","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"# Load reference data\nu3Exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/torsion_u3VsMass_Exp.txt\")\nu3UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/torsion_u3VsMass_UMNAST.txt\")\nθExp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/torsion_thetaVsMass_Exp.txt\")\nθUMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/torsion_thetaVsMass_UMNAST.txt\")\nnothing #hide","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"We can now plot the out-of-plane (OOP) tip displacement and tip twist as functions of the tip mass. The following \"experimental\" results were taken from Figure 17 of the paper by Avin et al.. The correlation with the reference data is good.","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# Tip midchord OOP displacement (offset from zero tip mass value) vs. tip mass\nplt1 = plot(xlabel=\"Tip mass [kg]\", ylabel=\"Tip OOP displacement offset [% semispan]\", xlims=[mRange[1],mRange[end]])\nplot!(mRange, (tip_OOP.-tip_OOP[1])/L*100, c=:black, lw=2, label=\"AeroBeams\")\nplot!(u3UMNAST[1,:], u3UMNAST[2,:], c=:blue, ls=:dash, lw=2, label=\"UM/NAST\")\nscatter!(u3Exp[1,:], u3Exp[2,:], mc=:red, ms=4, msw=0, label=\"Experimental\")\nsavefig(\"PazyWingTorsionTest_OOP.svg\") #hide\nnothing #hide\n\n# Tip twist vs. tip mass\nplt2 = plot(xlabel=\"Tip mass [kg]\", ylabel=\"Tip twist [deg]\", xlims=[mRange[1],mRange[end]])\nplot!(mRange, tip_twist, c=:black, lw=2, label=\"AeroBeams\")\nplot!(θUMNAST[1,:], θUMNAST[2,:], c=:blue, ls=:dash, lw=2, label=\"UM/NAST\")\nscatter!(θExp[1,:], θExp[2,:], mc=:red, ms=4, msw=0, label=\"Experimental\")\nsavefig(\"PazyWingTorsionTest_twist.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"(Image: ) (Image: )","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"","category":"page"},{"location":"literate/PazyWingTorsionTest/","page":"Static structural analysis of the Pazy wing","title":"Static structural analysis of the Pazy wing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/OMCgustTests/#Gust-response-of-an-airfoil-section","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"","category":"section"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"This example illustrates how to set up an aerodynamic analysis of gust response. While AeroBeams can't run a strictly aerodynamic analyses (only aeroelastic ones), that can be done in practice by using a one-element stiff beam supported at both ends, effectively removing structural deformation effects. We'll evaluate the response of the NACA 0012 airfoil to one-minus-cosine gusts through several tests, each with different pitch angle and gust length. The performance of the available aerodynamic solvers the gust indicial solvers will be assessed too.","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/OMCgustTests/#Core-function-setup","page":"Gust response of an airfoil section","title":"Core function setup","text":"","category":"section"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"The following core function solves our problem given the test case, the aerodynamic solver the gust indicial solver. Notice that we use the function create_OneMinusCosineGust with the appropriate arguments to streamline the process of creation of the gust.","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"using AeroBeams, DelimitedFiles\nusing Suppressor #hide\n\n# Core function\nfunction OMCgustTestsCore(aeroSolver,gustLoadsSolver,testCase)\n\n    # Set test case data\n    if testCase == 1\n        Ma = 0.2            # Mach number\n        U = 68.06           # Airspeed [m/s]\n        H = π               # Normalized gust length\n        b = 0.40663         # Airfoil semichord [m]\n        τ = 2*H*b/U         # Gust duration [s]\n        w = 2.3748          # Gust peak velocity [m/s]\n        t₀ = 80*b/U         # Time of gust encounter [s]\n        tf = t₀ + 30*b/U    # Total simulation time [s]\n        θ = 0*π/180         # Airfoil pitch angle [deg]\n    elseif testCase == 2\n        Ma = 0.2\n        U = 68.06\n        H = π\n        b = 0.40663\n        τ = 2*H*b/U\n        w = 2.3748\n        t₀ = 80*b/U\n        tf = t₀ + 30*b/U\n        θ = 10*π/180\n    elseif testCase == 3\n        Ma = 0.2\n        U = 68.06\n        H = π\n        b = 0.40663\n        τ = 2*H*b/U\n        w = 2.3748\n        t₀ = 80*b/U\n        tf = t₀ + 30*b/U\n        θ = 15*π/180\n    elseif testCase == 4\n        Ma = 0.2\n        U = 68.06\n        H = 8π\n        b = 0.40663\n        τ = 2*H*b/U\n        w = 2.3748\n        t₀ = 80*b/U\n        tf = t₀ + 80*b/U\n        θ = 0*π/180\n    elseif testCase == 5\n        Ma = 0.2\n        U = 68.06\n        H = 8π\n        b = 0.40663\n        τ = 2*H*b/U\n        w = 2.3748\n        t₀ = 80*b/U\n        tf = t₀ + 80*b/U\n        θ = 10*π/180\n    elseif testCase == 6\n        Ma = 0.2\n        U = 68.06\n        H = 8π\n        b = 0.40663\n        τ = 2*H*b/U\n        w = 2.3748\n        t₀ = 60*b/U\n        tf = t₀ + 80*b/U\n        θ = 15*π/180\n    end\n\n    # Gust\n    gust = create_OneMinusCosineGust(initialTime=t₀,duration=τ,verticalVelocity=w)\n\n    # Wing surface\n    airfoil = deepcopy(NACA0012)\n    update_Airfoil_params!(airfoil,Ma=Ma,U=U,b=b)\n    derivationMethod = AD()\n    surf = create_AeroSurface(solver=aeroSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,airfoil=airfoil,c=2*b,normSparPos=1/4,updateAirfoilParameters=true)\n\n    # Wing beam\n    L = 1\n    nElem = 1\n    ρA = 1\n    ∞ = 1e12\n    wing = create_Beam(name=\"beam\",length=L,nElements=nElem,S=[isotropic_stiffness_matrix(∞=∞)],I=[inertia_matrix(ρA=ρA)],rotationParametrization=\"E321\",p0=[0;0;θ],aeroSurface=surf)\n\n    # BCs\n    clamp1 = create_BC(name=\"clamp1\",beam=wing,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\n    clamp2 = create_BC(name=\"clamp2\",beam=wing,node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\n\n    # Model\n    OMCgustTests = create_Model(name=\"OMCgustTests\",beams=[wing],BCs=[clamp1,clamp2],v_A=[0;U;0],gust=gust)\n\n    # Set system solver options\n    σ0 = 1.0\n    maxIter = 20\n    rtol = 1e-12\n    NR = create_NewtonRaphson(initialLoadFactor=σ0,maximumIterations=maxIter,relativeTolerance=rtol,displayStatus=false,alwaysUpdateJacobian=false,minConvRateAeroJacUpdate=1.2,minConvRateJacUpdate=1.2)\n\n    # Time variables\n    steps = 1000\n    Δt = (tf-t₀)/steps\n\n    # Initial velocities update options\n    initialVelocitiesUpdateOptions = InitialVelocitiesUpdateOptions(maxIter=2,tol=1e-8, displayProgress=false, relaxFactor=0.5, Δt=Δt/10)\n\n    # Create and solve dynamic problem\n    problem = create_DynamicProblem(model=OMCgustTests,finalTime=tf,Δt=Δt,systemSolver=NR,initialVelocitiesUpdateOptions=initialVelocitiesUpdateOptions)\n    solve!(problem)\n\n    # Unpack numerical solution\n    t = problem.savedTimeVector\n    cn = [problem.aeroVariablesOverTime[i][1].aeroCoefficients.cn for i in 1:length(t)]\n    ct = [problem.aeroVariablesOverTime[i][1].aeroCoefficients.ct for i in 1:length(t)]\n    cl = @. cn*cos(θ) + ct*sin(θ)\n\n    # Load reference data\n    if testCase == 1\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/Hpi_A0.txt\")\n    elseif testCase == 2\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/Hpi_A10.txt\")\n    elseif testCase == 3\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/Hpi_A15.txt\")\n    elseif testCase == 4\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/H8pi_A0.txt\")\n    elseif testCase == 5\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/H8pi_A10.txt\")\n    elseif testCase == 6\n        ΔclRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/gustTests/H8pi_A15.txt\")\n    end\n\n    # Time index of gust encounter\n    ind = floor(Int,t₀/Δt)+1\n\n    # Non-dimensional time and cl increment vectors\n    τ = U/b * (t[ind:end] .- t[ind])\n    Δcl = cl[ind:end] .- cl[ind]\n\n    return τ,Δcl,ΔclRef\nend\nnothing #hide","category":"page"},{"location":"literate/OMCgustTests/#Problem-setup","page":"Gust response of an airfoil section","title":"Problem setup","text":"","category":"section"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"To setup the problem, we define which tests will be run, and which aerodynamic and gust indicial solvers will be used. Notice that BLi stands for our modified Beddoes-Leishman model, whereas BLo is the original version.","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"# Tests range\ntests = collect(1:6)\n\n# Aerodynamic and gust indicial solvers\naeroSolvers = [QuasiSteady(); Indicial(); Inflow(); BLi(); BLo()]\ngustLoadsSolvers = [IndicialGust(\"Kussner\"); IndicialGust(\"Berci&Righi\")]\n\n# Initialize outputs\nτ = Array{Vector{Float64}}(undef,length(aeroSolvers),length(gustLoadsSolvers),length(tests))\nΔcl = Array{Vector{Float64}}(undef,length(aeroSolvers),length(gustLoadsSolvers),length(tests))\nΔclRef = Array{Matrix{Float64}}(undef,length(aeroSolvers),length(gustLoadsSolvers),length(tests))\nnothing #hide","category":"page"},{"location":"literate/OMCgustTests/#Problem-solving","page":"Gust response of an airfoil section","title":"Problem solving","text":"","category":"section"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"We now loop the configurations to solve for each one of them.","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"# Loop aerodynamic solver\nfor (i,aeroSolver) in enumerate(aeroSolvers)\n    # Loop gust solver\n    for (j,gustLoadsSolver) in enumerate(gustLoadsSolvers)\n        # Loop test cases\n        for (k,testCase) in enumerate(tests)\n            # Solve for current configuration\n        @suppress begin #hide\n            τ[i,j,k],Δcl[i,j,k],ΔclRef[i,j,k] = OMCgustTestsCore(aeroSolver,gustLoadsSolver,testCase)\n        end #hide\n        nothing #hide\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"Let's compare the accuracy of the aerodynamic formulations by plotting the development of the lift coefficient. The indicial functions by Kussner (approximation of analytical) and by Berci and Righi (semi-analytical) compare well to the CFD data by Mallik and Raveh. The linear models show good results (except the quasi-steady one) for test 2, in which the airfoil is pitched by 10 degrees. However, at test 6 the dynamic stall models fare better, since the airfoil is at a high angle of attack (15 degrees) and stalls upon encountering the gust.","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"using Plots, ColorSchemes\ncolors = get(colorschemes[:rainbow], LinRange(0, 1, length(aeroSolvers)))\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\nlabels = [\"QS\" \"Indicial\" \"Inflow\" \"BLi\" \"BLo\"]\nlinestyles = [:solid :dash :dot :dashdot :dashdotdot]\n\n# Test 2 - Kussner indicial function\nplt21 = plot(xlabel=\"\\$\\\\tau\\$ [semichords]\", ylabel=\"\\$\\\\Delta c_l\\$\", title=\"Test 2 - Kussner indicial function\")\nscatter!(ΔclRef[1,1,2][1,:], ΔclRef[1,1,2][2,:], color=:black, ms=4, label=\"Mallik & Raveh (2019)\")\nfor (i,aeroSolver) in enumerate(aeroSolvers)\n    plot!(τ[i,1,2], Δcl[i,1,2], color=colors[i], lw=2, ls=linestyles[i], label=labels[i])\nend\nsavefig(\"OMCgustTests_test2K.svg\") #hide\nnothing #hide\n\n# Test 2 - Berci and Righi indicial function\nplt22 = plot(xlabel=\"\\$\\\\tau\\$ [semichords]\", ylabel=\"\\$\\\\Delta c_l\\$\", title=\"Test 2 - Berci and Righi indicial function\")\nscatter!(ΔclRef[1,1,2][1,:], ΔclRef[1,1,2][2,:], color=:black, ms=4, label=\"Mallik & Raveh (2019)\")\nfor (i,aeroSolver) in enumerate(aeroSolvers)\n    plot!(τ[i,1,2], Δcl[i,1,2], color=colors[i], lw=2, ls=linestyles[i], label=labels[i])\nend\nsavefig(\"OMCgustTests_test2BR.svg\") #hide\nnothing #hide\n\n# Test 6 - Kussner indicial function\nplt61 = plot(xlabel=\"\\$\\\\tau\\$ [semichords]\", ylabel=\"\\$\\\\Delta c_l\\$\", title=\"Test 6 - Kussner indicial function\")\nscatter!(ΔclRef[1,1,6][1,:], ΔclRef[1,1,6][2,:], color=:black, ms=4, label=\"Mallik & Raveh (2019)\")\nfor (i,aeroSolver) in enumerate(aeroSolvers)\n    plot!(τ[i,1,6], Δcl[i,1,6], color=colors[i], lw=2, ls=linestyles[i], label=labels[i])\nend\nsavefig(\"OMCgustTests_test6K.svg\") #hide\nnothing #hide\n\n# Test 6 - Berci and Righi indicial function\nplt62 = plot(xlabel=\"\\$\\\\tau\\$ [semichords]\", ylabel=\"\\$\\\\Delta c_l\\$\", title=\"Test 6 - Berci and Righi indicial function\")\nscatter!(ΔclRef[1,1,6][1,:], ΔclRef[1,1,6][2,:], color=:black, ms=4, label=\"Mallik & Raveh (2019)\")\nfor (i,aeroSolver) in enumerate(aeroSolvers)\n    plot!(τ[i,2,6], Δcl[i,2,6], color=colors[i], lw=2, ls=linestyles[i], label=labels[i])\nend\nsavefig(\"OMCgustTests_test6BR.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"","category":"page"},{"location":"literate/OMCgustTests/","page":"Gust response of an airfoil section","title":"Gust response of an airfoil section","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/sweptTipRotor/#Modal-analysis-of-a-rotating-beam","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"","category":"section"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"This example illustrates how to set up a modal (eigen) analysis, using a swept-tip rotor. We will investigate the vibration modes of this rotor at several rotating speeds and several angles of the tip. This problem was proposed by Hodges, Shang and Cesnik, based on the experiments of Epps and Chandra.","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"(Image: )","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"Geometry of the swept-tip rotor by Hodges, Shang and Cesnik","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/sweptTipRotor/#Problem-setup","page":"Modal analysis of a rotating beam","title":"Problem setup","text":"","category":"section"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"To set up the problem, we need to define the geometric and material properties of the beams, to later create them. We also define the number of elements for each beam, the number of vibration modes to extract and the ranges for the angular velocity and the tip angle. Notice that the beam is clamped at a position r0 relative to the axis of rotation, which is input to the function create_Model through the argument initialPosition. Moreover, the model assembly assumes by default that all the beams given by the beams argument are connected in sequence (e.g., the first node of tipBeam is the same as the last of baseBeam).","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"using AeroBeams\n\n# Geometric properties\nL1,L2 = 31.5,6.0\nb,H = 1,0.063\nA,Iy,Iz = b*H,b*H^3/12,H*b^3/12\nJ = Is = Iy + Iz\nKsy,Ksz,Kt = 5/6,1/14.625,1/65.852\nr0 = [2.5; 0.0; 0.0]\n\n# Material properties (aluminum)\nE = 1.06e7\nG = E/(2*(1+0.325))\nρ = 2.51e-4\n\n# Seciontal stiffness and inertia matrices\nS = isotropic_stiffness_matrix(EA=E*A,GAy=G*A*Ksy,GAz=G*A*Ksz,GJ=G*J*Kt,EIy=E*Iy,EIz=E*Iz)\nI = inertia_matrix(ρA=ρ*A,ρIy=ρ*Iy,ρIz=ρ*Iz,ρIs=ρ*Is)\n\n# Discretization variables\nnElemBeam1 = 20\nnElemBeam2 = 10\n\n# Range of angular velocity [rad/s]\nωRange = 2π/60*[0,500,750]\n\n# Range of beam tip angles [rad]\ntipAngleRange = π/180*collect(0:2.5:45)\n\n# Number of modes\nnModes = 8\n\n# Beam frame\nbaseBeam = create_Beam(name=\"baseBeam\",length=L1,nElements=nElemBeam1,S=[S],I=[I])\ntipBeam = create_Beam(name=\"tipBeam\",length=L2,nElements=nElemBeam2,S=[isotropic_stiffness_matrix(∞=1e12,EA=E*A,GAy=G*A*Ksy,GAz=G*A*Ksz,GJ=G*J*Kt,EIy=E*Iy,EIz=E*Iz)],I=[I],rotationParametrization=\"E321\")\n\n# BCs\nclamp = create_BC(name=\"clamp\",beam=baseBeam,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\n\n# Create model\nsweptTipRotor = create_Model(name=\"sweptTipRotor\",beams=[baseBeam,tipBeam],BCs=[clamp],initialPosition=r0,units=create_UnitsSystem(length=\"in\",force=\"lbf\",frequency=\"Hz\"))\n\n# Initialize outputs\nnumFreqs = Matrix{Vector{Float64}}(undef,length(ωRange),length(tipAngleRange))\nnothing #hide","category":"page"},{"location":"literate/sweptTipRotor/#Solving-the-problem","page":"Modal analysis of a rotating beam","title":"Solving the problem","text":"","category":"section"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"We now solve an eigenproblem at each combination of tip angle and angular velocity, and extract the modal frequencies. Notice that we set the angular velocity of the entire model through the angular velocity of basis mathcalA, using the variable ω_A. AeroBeams will automatically solve the steady problem to find the deformed state of the model, and then perform an eigen-analysis around that state.","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"# Loop over sweep variables\nfor (i,ω) in enumerate(ωRange)\n    # Set angular velocity of basis A\n    sweptTipRotor.ω_A = [0; 0; ω]\n    # Loop tip angles\n    for (j,tipAngle) in enumerate(tipAngleRange)\n        # Update tipBeam angle with tip angle\n        tipBeam.p0[1] = -tipAngle\n        update_beam!(tipBeam)\n        # Update model\n        sweptTipRotor.beams = [baseBeam,tipBeam]\n        update_model!(sweptTipRotor)\n        # Create and solve eigenproblem\n        global problem = create_EigenProblem(model=sweptTipRotor,nModes=nModes)\n        solve!(problem)\n        # Get outputs\n        numFreqs[i,j] = problem.frequenciesOscillatory\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/sweptTipRotor/#Post-processing","page":"Modal analysis of a rotating beam","title":"Post-processing","text":"","category":"section"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"We begin by loading the experimental values by Epps and Chandra.","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"# Experimental values\nexpTipAngles = [0, 15, 30, 45]\nexpFreqs1 = [1.4 1.8 1.7 1.6; 10.2 10.1 10.2 10.2; 14.8 14.4 14.9 14.7]\nexpFreqs2 = [10.3 10.2 10.4 10.4; 25.2 25.2 23.7 21.6; 36.1 34.8 30.7 26.1]\nexpFreqs3 = [27.7 27.2 26.6 24.8; 47.0 44.4 39.3 35.1; 62.9 55.9 48.6 44.8]\nexpFreqs4 = [95.4 87.5 83.7 78.8; 106.6 120.1 122.6 117.7; 132.7 147.3 166.2 162.0]\nnothing #hide","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"Now we plot the evolution of the modal frequencies with the tip angle for the range of angular velocities. The numerical results agree well with the experimental ones, and match those described by Hodges, Shang and Cesnik and Yu and Blair.","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"using Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\ncolors = get(colorschemes[:darkrainbow], LinRange(0, 1, length(ωRange)))\n\n# 1st bending mode\nplt1 = plot(xlabel=\"Tip sweep angle [deg]\", ylabel=\"Frequency [Hz]\", title=\"1st bending\", legend=(0.15,0.4))\nplot!([NaN],[NaN], lc=:black, lw=2, label=\"AeroBeams\")\nscatter!([NaN],[NaN], mc=:black, ms=4, msw=0, label=\"Epps & Chandra (1996)\")\nfor (i,ω) in enumerate(ωRange)\n    mode = 1\n    ωRPM = round(Int,ω/(2*π/60))\n    numFreqs1 = [numFreqs[i,j][mode]/(2π) for j in 1:size(numFreqs, 2)]\n    plot!(tipAngleRange*180/π,numFreqs1, lc=colors[i], lw=2, label=false)\n    scatter!(expTipAngles,expFreqs1[i,:], mc=colors[i], ms=4, msw=0, label=false)\n    plot!([NaN], [NaN], lc=colors[i], m=colors[i], lw=2, ms=4, msw=0, label=\"\\$\\\\omega\\$ = $ωRPM rpm\")\nend\nsavefig(\"sweptTipRotor_1B.svg\") #hide\nnothing #hide\n\n# 2nd bending\nplt2 = plot(xlabel=\"Tip sweep angle [deg]\", ylabel=\"Frequency [Hz]\", title=\"2nd bending\", legend=(0.15,0.4))\nplot!([NaN],[NaN], lc=:black, lw=2, label=\"AeroBeams\")\nscatter!([NaN],[NaN], mc=:black, ms=4, msw=0, label=\"Epps & Chandra (1996)\")\nfor (i,ω) in enumerate(ωRange)\n    mode = i < 3 ? 2 : 3\n    ωRPM = round(Int,ω/(2*π/60))\n    numFreqs2 = [numFreqs[i,j][mode]/(2π) for j in 1:size(numFreqs, 2)]\n    plot!(tipAngleRange*180/π,numFreqs2, lc=colors[i], lw=2, label=false)\n    scatter!(expTipAngles,expFreqs2[i,:], mc=colors[i], ms=4, msw=0, label=false)\n    plot!([NaN], [NaN], lc=colors[i], m=colors[i], lw=2, ms=4, msw=0, label=\"\\$\\\\omega\\$ = $ωRPM rpm\")\nend\nsavefig(\"sweptTipRotor_2B.svg\") #hide\nnothing #hide\n\n# 3rd bending mode\nplt3 = plot(xlabel=\"Tip sweep angle [deg]\", ylabel=\"Frequency [Hz]\", title=\"3rd bending\", legend=:topright)\nplot!([NaN],[NaN], lc=:black, lw=2, label=\"AeroBeams\")\nscatter!([NaN],[NaN], mc=:black, ms=4, msw=0, label=\"Epps & Chandra (1996)\")\nfor (i,ω) in enumerate(ωRange)\n    mode = 4\n    ωRPM = round(Int,ω/(2*π/60))\n    numFreqs3 = [numFreqs[i,j][mode]/(2π) for j in 1:size(numFreqs, 2)]\n    plot!(tipAngleRange*180/π,numFreqs3, lc=colors[i], lw=2, label=false)\n    scatter!(expTipAngles,expFreqs3[i,:], mc=colors[i], ms=4, msw=0, label=false)\n    plot!([NaN], [NaN], lc=colors[i], m=colors[i], lw=2, ms=4, msw=0, label=\"\\$\\\\omega\\$ = $ωRPM rpm\")\nend\nsavefig(\"sweptTipRotor_3B.svg\") #hide\nnothing #hide\n\n# Coupled bending-torsion modes at ω = 750 rpm\nplt4 = plot(xlabel=\"Tip sweep angle [deg]\", ylabel=\"Frequency [Hz]\", title=\"Coupled bending-torsion at \\$\\\\omega\\$ = 750 rpm\", legend=(0.1,0.99))\nplot!([NaN],[NaN], lc=:black, lw=2, label=\"AeroBeams\")\nscatter!([NaN],[NaN], mc=:black, ms=4, msw=0, label=\"Epps & Chandra (1996)\")\nmodes = [5,6,7]\nmodeLabels = [\"1T/5B\",\"5B/1T\",\"4B/1T\"]\nfor (i,ω) in enumerate(ωRange)\n    ωRPM = round(Int,ω/(2π/60))\n    if i == 3\n        numFreqsCoupled = zeros(length(tipAngleRange))\n        for j in 1:size(numFreqs, 2)\n            mode = tipAngleRange[j]*180/π >= 20 ? 8 : 7\n            numFreqsCoupled[j] = numFreqs[end,j][mode]/(2π)\n        end\n    else\n        mode = modes[i]\n        numFreqsCoupled = [numFreqs[end,j][mode]/(2π) for j in 1:size(numFreqs, 2)]\n    end\n    plot!(tipAngleRange*180/π,numFreqsCoupled, c=colors[i], lw=2, label=false)\n    scatter!(expTipAngles,expFreqs4[i,:], c=colors[i], ms=4, msw=0, label=false)\n    plot!([NaN], [NaN], lc=colors[i], mc=colors[i], lw=2, ms=4, msw=0, label=modeLabels[i])\nend\nsavefig(\"sweptTipRotor_TB.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"","category":"page"},{"location":"literate/sweptTipRotor/","page":"Modal analysis of a rotating beam","title":"Modal analysis of a rotating beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Structural-formulation","page":"Theory","title":"Structural formulation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The theory for the structural part of the code was developed by Hodges[1], and practical implementation aspects are based on the works of Yu and Blair[2] and Wang and Yu[3]. Here we will outline only the basics for a better understanding of how to use the package. In the following, we use Bauchau's[4] tensorial notation, in which first-order tensors (represented through vectors) are written with a single underline (underlinecdot) and second- and higher-order tensors (represented through matrices) with a double underline (underlineunderlinecdot).","category":"page"},{"location":"theory/#Geometry-and-kinematics","page":"Theory","title":"Geometry and kinematics","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The figure below illustrates the kinematics of the deformation of the beam. The primary basis (frame or reference) for the development of the theory is basis mathcalA, because the equations of motion are written in terms of tensors resolved in it (it can be thought of as a global, or body-attached basis). Its motion in an inertial, fixed basis mathcalI^circ is supposed to be known at all times. In AeroBeams, the user may input the motion of basis mathcalA relative to mathcalI^circ through the vectorial displacement, initial rotation, velocities and/or accelerations (u_A,p_A0,v_A,ω_A,vdot_A and ωdot_A arguments) of that basis to the model with the function create_Model.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Kinematics of beam deformation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the undeformed configuration, the beam is idealized as an initially twisted and curved reference line with a defined cross-section at each point, shown as a  gray rectangle in the figure. Vector underlinek defines the undeformed beam's curvatures per unit length (k_1 is the twist and k_2 and k_3 are the bending curvatures), which may be input to the function create_Beam through the argument k. The curvilinear coordinate x_1 defines an intrinsic parametrization of the reference line, i.e., denotes the arc-length along it. In this undeformed configuration, a basis b^+, called the undeformed beam basis, is defined at each point along the reference line. This basis is fixed with respect to mathcalA, and tensor components resolved in it are denoted with a superscript (cdot)^+. Rotation tensor underlineunderlineR_0 brings basis mathcalA to basis b^+. That rotation can be specified by the user to the function create_Beam through the arguments representing the rotation parameters and the choice of rotation parametrization, p0 and rotationParametrization, respectively.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nArgument rotationParametrization is specific to the definition of p0. Internal computations of the systems of equations are done with Wiener-Milenkovic parameters, regardless of the choice of rotationParametrization.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Upon deformation, each point of the beam's undeformed reference line moves to a new point, whose loci define a new reference line in the deformed configuration. At each of such points is defined an orthonormal basis B^star, the deformed beam basis, and tensor components resolved in that basis are denoted with a superscript (cdot)^star.","category":"page"},{"location":"theory/#Equations-of-motion","page":"Theory","title":"Equations of motion","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The equations of motion are derived from Hamilton's principle:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"int_t_1^t_2 int_0^ell (delta (mathcalK-mathcalU) + overlinedelta mathcalW_textnormalext ) dx_1 dt = overlinedeltamathcalA","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where t_1 and t_2 represent initial and final instances of a time interval, ell is the length of the beam, delta is the variational operator, mathcalK and mathcalU are the kinetic energy and strain energy of the beam per unit length, respectively, overlinedelta mathcalW_textnormalext is the virtual work of applied loads per unit length of the beam, and overlinedeltamathcalA is the virtual action applied at the ends of the beam, at the initial and final times.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The form of the strain energy per unit length is assumed to be known as a function of the generalized strain measures, that is, mathcalU = mathcalU(underlinegamma^+underlinekappa^+). Therefore, its variation can be written as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"deltamathcalU = delta underlinegamma^+^T underlineF^star + delta underlinekappa^+^T underlineM^star","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"in which underlineF^star and underlineM^star are the sectional force and moment resultants (i.e., internal load vectors resolved in basis B^star) and underlinegamma^+ and underlinekappa^+ are the force and moment strains (i.e., unidimensional strain measures). These quantities are related through the generalized force-strain, or geometry-material constitutive relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrix underlineF^star  underlineM^star endbmatrix = underlineunderlineS beginbmatrix underlinegamma^+  underlinekappa^+ endbmatrix ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"in which underlineunderlineS is the sectional stiffness matrix. For simple cross-sections of isotropic materials it takes a diagonal form,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"underlineunderlineS = beginbmatrix\nEA                 \n    GA_y            \n       GA_z         \n           GJ       \n             EI_y   \n                EI_z\nendbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where EA is the axial stiffness, GA_y and GA_z are the shear stiffnesses, GJ is the torsional stiffness, and EI_y and EI_z are the bending stiffnesses. However, for complex cross-sections of anisotropic materials, underlineunderlineS may become a fully populated matrix that has to be numerically computed (for instance with GXBeam.jl). In AeroBeams, the sectional stiffness matrix of each element of the beam can be specified through the argument S to the function create_Beam.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nIf the beam has a uniform cross-section and material, a single-valued array may be input for S.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, the kinetic energy per unit length of the beam is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathcalK = frac12 ( mu underlineV^star^T underlineV^star - 2mu underlineOmega^star^T tildeV^star underlineeta^star + underlineOmega^star^T underlineunderlineiota^star underlineOmega^star )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mu = rho A is the mass per unit length, and underlineeta^star and underlineunderlineiota^star are the sectional first and second mass moments of inertia, respectively, underlineV^star is the sectional velocity, and underlineOmega^star is the sectional angular velocity of the beam. Note that the tilde(cdot) represents the skew-symmetric matrix.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the kinetic energy per unit length is a function of the sectional generalized velocities, i.e., mathcalK = mathcalK(underlineV^starunderlineOmega^star), its variation may be expressed as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"deltamathcalK = delta underlineV^star^T underlineP^star + delta underlineOmega^star^T underlineH^star","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"in which underlineP^star and underlineH^star are the sectional linear and angular momenta. These are related to the sectional velocities through the generalized momentum-velocity relationship:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginbmatrix underlineP^star  underlineH^star endbmatrix = underlineunderlinemathcalM beginbmatrix underlineV^star  underlineOmega^star endbmatrix ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where the sectional inertia matrix is given by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"underlinemathcalM = beginbmatrix mu underlineunderlineI_3  - mu tildeeta^star  \n    mu tildeeta^star  underlineunderlineiota^star endbmatrix","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Just like the sectional stiffness matrix, the sectional inertia matrix may be analytically computable for simple cross-sections, but a numerical solution must be sought for arbitrary ones. In AeroBeams, the sectional stiffness matrix of each element of the beam can be specified through the argument I to the function create_Beam.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nIf the beam has a uniform cross-section and material, a single-valued array may be input for I.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The virtual work per unit length, overlinedelta mathcalW_textnormalext, may be written as a function of the displacements and rotations, underlineu and underlinep, and the externally applied distributed forces and moments, underlinef and underlinem. These loads may be input in AeroBeams either being dead (fixed direction) or follower, and being initially resolved in basis mathcalA or b^+, through the arguments f_A_of_x1t, m_A_of_x1t, f_b_of_x1t, m_b_of_x1t, ff_A_of_x1t, mf_A_of_x1t, ff_b_of_x1t, mf_b_of_x1t of the function create_Beam. As their names suggest, these can be functions of the beam arclength coordinate, x_1, and of time, t. In problems where the initial conditions are nonzero, the arguments u0_of_x1, p0_of_x1, udot0_of_x1 and pdot0_of_x1 can be input to create_Beam to define the initial displacements and rotations (and their rates) resolved in basis b^+.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"tip: Tip\nYou can also use the functions add_loads_to_beam! and add_initial_displacements_and_velocities_to_beam!.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nVectors underlinef and underlinem will also include any aerodynamic loads present.        ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nConcentrated dead and follower loads (and displacements/rotations) can also be defined as initially resolved in basis mathcalA or b^+, but they must be set as boundary conditions through the function create_BC. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"With all the elements of the equations of motion at hand, we can adjoin the kinematic constraints (generalized strain-displacement relationships) to arrive at a mixed variational statement that encapsulates all the dynamics of this Timoshenko beam formulation. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the finite-element discretization, we maintain the displacements and rotation parameters resolved in basis mathcalA, underlineu and underlinep, as well as the sectional loads and velocities, underlineF^star, underlineM^star, underlineV^star and underlineOmega^star as state variables. That allows us to use the simplest shape functions (linear or constant) for these variables and therefore avoid numerical quadrature, besides yielding analytically computable system arrays. These states (and the complementary states underlinegamma^+, underlinekappa^+, underlineP^star and underlineH^star) are assumed as constants over the beam element.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nWhen an aerodynamic surface is attached to the beam, through the argument aeroSurface of create_Beam, the generated aerodynamic mesh is coincident with the structural mesh, since strip theory is assumed. Thus, each element will also have its associated aerodynamic states, underlinechi, and aerodynamic coefficients/loads.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Point inertias may be defined with the constructor PointInertia. They can be attached to a specific element of the beam through the argument pointInertias of the function create_Beam. Alternatively, one may use the function add_point_inertias_to_beam!. Their effect is to add to the attached element's sectional inertia matrix.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A similar situation arises with respect to linear springs, which can have one or both of their ends attached to nodes of a beam. They are instantiated with the function create_Spring, and can be passed to create_Beam through the argument springs. Alternatively, one may use the functions add_springs_to_beam! and add_spring_to_beams!.","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1]: Hodges, D. H. \"Nonlinear Composite Beam Theory\". 2006. American Institute of Aeronautics and Astronautics. 10.2514/4.866821","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[2]: Yu, W. and Blair, M. \"GEBT: A general-purpose nonlinear analysis tool for composite beams\". 2012. Composite Structures. 10.1016/j.compstruct.2012.04.007","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[3]: Wang, Q. and Yu, W. \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\". 2017. Journal of Renewable and Sustainable Energy. 10.1063/1.4985091","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[4]: Bauchau, O. A. \"Flexible Multibody Dynamics\". 2011. Springer.","category":"page"},{"location":"literate/PazyWingPitchRange/#Steady-aeroelastic-analysis-of-the-Pazy-wing","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy wing","text":"","category":"section"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"This example illustrates how to set up a steady aeroelastic analysis, using the Technion's Pazy wing benchmark. The sectional properties of the wing's spar and the aerodynamic tip loss function were defined by Riso and Cesnik. The data is publicly available at https://github.com/UM-A2SRL/AePW3-LDWG.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"(Image: )","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"Pazy wing in the wind tunnel by Avin et al.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/PazyWingPitchRange/#Problem-setup","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Problem setup","text":"","category":"section"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"Let's begin by setting the variables of our problem. In this example we will analyze the displacements and twist of the clamped wing under several combinations of root pitch angle and airspeed, which are defined by the arrays θRange and URange. The wing was tested with a balance mass of 0.01 kg attached to its tip store, at a position of 40 mm behind the trailing-edge. Notice that we bring into scope some fixed geometrical and discretization properties of the wing's beam through the function geometrical_properties_Pazy.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"using AeroBeams, DelimitedFiles\n\n# Aerodynamic solver\naeroSolver = QuasiSteady()\n\n# Derivation method\nderivationMethod = AD()\n\n# Airfoil section\nairfoil = deepcopy(flatPlate)\n\n# Flag for upright position\nupright = true\n\n# Gravity\ng = 0\n\n# Flag for small angles approximation\nsmallAngles = true\n\n# Fixed geometrical and discretization properties\nnElem,L,chord,normSparPos = geometrical_properties_Pazy()\n\n# Tip mass (for test 1, 0.01 kg, 40 mm behind the trailing-edge)\ntipMass = 0.01\nηtipMass = [0; -chord*(1-normSparPos)-0.04; 0]\n\n# Root angle (in degrees) and airspeed ranges\nθRange = [3, 5, 7]\nURange = collect(0:1:60)\n\n# Initialize outputs\ntip_OOP = Array{Float64}(undef,length(θRange),length(URange))\ntip_IP = Array{Float64}(undef,length(θRange),length(URange))\ntip_twist = Array{Float64}(undef,length(θRange),length(URange))\ntip_AoA = Array{Float64}(undef,length(θRange),length(URange))\nnothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/#Solving-the-problem","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Solving the problem","text":"","category":"section"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"In the following loops, we create new model instances with the combination of pitch angle and airspeed, create and solve the steady problem, and then extract the outputs of interest. The model creation process is streamlined with the function create_Pazy, taking the appropriate inputs. Notice that the twist angle is computed as the arcsine of the difference in \"height\" between the leading edge and trailing edge of the wingtip (throught the rotation of the local basis vector pointing in the x2-direction).","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"# Sweep root angle\nfor (i,θ) in enumerate(θRange)\n    # Sweep airspeed\n    for (j,U) in enumerate(URange)\n        # Update model\n        PazyWingPitchRange,_ = create_Pazy(aeroSolver=aeroSolver,derivationMethod=derivationMethod,airfoil=airfoil,upright=upright,θ=θ*π/180,airspeed=U,g=g,tipMass=tipMass,ηtipMass=ηtipMass,smallAngles=smallAngles)\n        # Create and solve problem\n        global problem = create_SteadyProblem(model=PazyWingPitchRange)\n        solve!(problem)\n        # Get tip twist, AoA, IP and OOP displacement at beam reference line\n        tip_p = problem.nodalStatesOverσ[end][nElem].p_n2_b\n        R,_ = rotation_tensor_WM(tip_p)\n        Δ = R*[0; 1; 0]\n        tip_twist[i,j] = asind(Δ[3])\n        tip_OOP[i,j] = problem.nodalStatesOverσ[end][nElem].u_n2_b[3]\n        tip_IP[i,j] = -problem.nodalStatesOverσ[end][nElem].u_n2_b[2]\n        tip_AoA[i,j] = problem.model.elements[end].aero.flowAnglesAndRates.αₑ*180/π\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/#Post-processing","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Post-processing","text":"","category":"section"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"The post-processing begins by loading the reference data.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"# Load reference data\ntip_u3VsU_rootPitch5_Exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3VsU_rootPitch5_Exp.txt\")\ntip_u3VsU_rootPitch5_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3VsU_rootPitch5_UMNAST.txt\")\ntip_u3VsU_rootPitch7_Exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3VsU_rootPitch7_Exp.txt\")\ntip_u3VsU_rootPitch7_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3VsU_rootPitch7_UMNAST.txt\")\ntip_thetaVsU_rootPitch5_Exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_thetaVsU_rootPitch5_Exp.txt\")\ntip_thetaVsU_rootPitch5_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_thetaVsU_rootPitch5_UMNAST.txt\")\ntip_thetaVsU_rootPitch7_Exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_thetaVsU_rootPitch7_Exp.txt\")\ntip_thetaVsU_rootPitch7_UMNAST = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_thetaVsU_rootPitch7_UMNAST.txt\")\ntip_u3Vsq_rootPitch3_ExpTest1 = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3Vsq_rootPitch3_ExpTest1.txt\")\ntip_u3Vsq_rootPitch5_ExpTest1 = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3Vsq_rootPitch5_ExpTest1.txt\")\ntip_u3Vsq_rootPitch7_ExpTest1 = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/Pazy/tip_u3Vsq_rootPitch7_ExpTest1.txt\")\nρTest2 = 2*1050/43^2 # Estimated air density for test 2, from Table 13 of Avin et al.'s paper\nnothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"We can now plot the outputs as a function of airspeed for each of the root pitch angles. The following \"experimental\" results were taken from Figure 33 of the paper by Avin et al.. Note that the experimental twist angle was actually estimated by Riso and Cesnik using the diffence between the leading- and trailing-edge out-of-plane displacements of Avin et al.. The correlation with the experimental data and the reference numerical solution is very good.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"using Suppressor #hide\nusing Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\ncolors = get(colorschemes[:rainbow], LinRange(0, 1, length(θRange)))\n\n# Tip OOP displacement vs. airspeed\nplt1 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Tip OOP displacement [% semispan]\", xlims=[URange[1],URange[end]], ylims=[0,50], legend=:topleft)\nplot!([NaN], [NaN], c=:black, lw=2, ls=:solid, label=\"AeroBeams\")\nplot!([NaN], [NaN], c=:black, lw=2, ls=:dashdot, label=\"UM/NAST\")\nscatter!([NaN], [NaN], c=:black, ms=4, label=\"Exp. (test 1)\")\nscatter!([NaN], [NaN], c=:black, shape=:diamond, ms=4, label=\"Exp. (test 2)\")\nfor (i,θ) in enumerate(θRange)\n    plot!(URange, tip_OOP[i,:]/L*100, c=colors[i], lw=2, ls=:solid, label=string(\"\\$\\\\alpha_r=\",round(Int,θ),\"^\\\\circ\\$\"))\n   if θ==3\n       scatter!(sqrt.(2*tip_u3Vsq_rootPitch3_ExpTest1[1,:]/ρTest2), tip_u3Vsq_rootPitch3_ExpTest1[2,:]*100/L, mc=colors[i], shape=:diamond, ms=4, msw=0, label=false)\n    elseif θ==5\n        plot!(tip_u3VsU_rootPitch5_UMNAST[1,:], tip_u3VsU_rootPitch5_UMNAST[2,:], lw=2, ls=:dashdot, c=colors[i], label=false)\n        scatter!(tip_u3VsU_rootPitch5_Exp[1,:], tip_u3VsU_rootPitch5_Exp[2,:], mc=colors[i], ms=4, msw=0, label=false)\n        scatter!(sqrt.(2*tip_u3Vsq_rootPitch5_ExpTest1[1,:]/ρTest2), tip_u3Vsq_rootPitch5_ExpTest1[2,:]*100/L, mc=colors[i], shape=:diamond, ms=4, msw=0, label=false)\n    elseif θ==7\n        plot!(tip_u3VsU_rootPitch7_UMNAST[1,:], tip_u3VsU_rootPitch7_UMNAST[2,:], lw=2, ls=:dashdot, c=colors[i], label=false)\n        scatter!(tip_u3VsU_rootPitch7_Exp[1,:], tip_u3VsU_rootPitch7_Exp[2,:], mc=colors[i], ms=4, msw=0, label=false)\n        scatter!(sqrt.(2*tip_u3Vsq_rootPitch7_ExpTest1[1,:]/ρTest2), tip_u3Vsq_rootPitch7_ExpTest1[2,:]*100/L, mc=colors[i], shape=:diamond, ms=4, msw=0, label=false)\n    end\nend\nsavefig(\"PazyWingPitchRange_tipOOP.svg\") #hide\nnothing #hide\n\n# Tip twist vs. airspeed\nplt2 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Tip twist [deg]\", xlims=[URange[1],URange[end]], legend=:topleft)\nfor (i,θ) in enumerate(θRange)\n    plot!(URange, tip_twist[i,:], c=colors[i], lw=2, label=false)\n    if θ==5\n        plot!(tip_thetaVsU_rootPitch5_UMNAST[1,:], tip_thetaVsU_rootPitch5_UMNAST[2,:], lw=2, ls=:dashdot, c=colors[i], label=false)\n        scatter!(tip_thetaVsU_rootPitch5_Exp[1,:], tip_thetaVsU_rootPitch5_Exp[2,:], mc=colors[i], ms=4, msw=0, label=false)\n    elseif θ==7\n        plot!(tip_thetaVsU_rootPitch7_UMNAST[1,:], tip_thetaVsU_rootPitch7_UMNAST[2,:], lw=2, ls=:dashdot, c=colors[i], label=false)\n        scatter!(tip_thetaVsU_rootPitch7_Exp[1,:], tip_thetaVsU_rootPitch7_Exp[2,:], mc=colors[i], ms=4, msw=0, label=false)\n    end\nend\nsavefig(\"PazyWingPitchRange_tipTwist.svg\") #hide\nnothing #hide\n\n# Tip AoA vs. airspeed\nplt3 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Tip AoA [deg]\", xlims=[URange[1],URange[end]], legend=:bottomright)\nfor (i,θ) in enumerate(θRange)\n    plot!(URange, tip_AoA[i,:], c=colors[i], lw=2, label=false)\nend\nsavefig(\"PazyWingPitchRange_tipAoA.svg\") #hide\nnothing #hide\n\n# Tip in-plane displacement vs. airspeed\nplt4 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Tip IP displacement [% semispan]\", xlims=[URange[1],URange[end]], legend=:topleft)\nfor (i,θ) in enumerate(θRange)\n    plot!(URange, tip_IP[i,:]/L*100, c=colors[i], lw=2, label=false)\nend\nsavefig(\"PazyWingPitchRange_tipIP.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"Let's leverage the built-in function plot_steady_outputs with the appropriate inputs to plot the lift coefficient over the span of the wing.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"# Lift coefficient over span for the last problem (θ = θRange[end] and U = URange[end])\n@suppress begin #hide\nplot_steady_outputs(problem,outputs=[\"cl\"],colorScheme=:grays,lw=2)\nsavefig(\"PazyWingPitchRange_cl.svg\") #hide\nnothing #hide\nend #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"(Image: )","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"nothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"Finally, we can visualize the deformed state of the wing using the plot_steady_deformation with the appropriate arguments. Notice that by default, gravitational loads are plotted in yellow, and aerodynamic loads in green.","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"# Deformed state of last problem (θ = θRange[end] and U = URange[end])\n@suppress begin #hide\ndeformationPlot = plot_steady_deformation(problem,view=(45,30),plotBCs=true,plotDistLoads=true)\nsavefig(\"PazyWingPitchRange_deformation.svg\") #hide\nend #hide\nnothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"(Image: )","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"nothing #hide","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"","category":"page"},{"location":"literate/PazyWingPitchRange/","page":"Steady aeroelastic analysis of the Pazy Wing","title":"Steady aeroelastic analysis of the Pazy Wing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/flyingScissors/#Dynamic-analysis-of-an-articulated-beam","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"This example illustrates how to set up a dynamic analysis, using the articulated beam in free flight proposed by Simo and Vu-Quoc:","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"(Image: ) Articulated beam: definition and motion by Simo and Vu-Quoc","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/flyingScissors/#Beam","page":"Dynamic analysis of an articulated beam","title":"Beam","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"The set up of this problem begins with the definition of the articulated links (beams), each with its own inertia properties. Notice, however, that we create a single beam, which has different properties for each half of its elements. This beam has a hinge defined by the arguments hingedNodes and hingedNodesDoF of the function create_Beam.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"using AeroBeams, LinearAlgebra\n\n# Beam\nL = 10\nEA,GA,GJ,EI = 1e6,1e6,1e6,1e4\nρA,ρI1,ρI2 = 1,1,10\nθ₀ = atan(4/3)\nnElem = 20\nstiffnessMatrix = diagm([EA,GA,GA,GJ,EI,EI])\ninertiaMatrix1 = diagm([ρA,ρA,ρA,2*ρI1,ρI1,ρI1])\ninertiaMatrix2 = diagm([ρA,ρA,ρA,2*ρI2,ρI2,ρI2])\ninertiaMatrices = vcat([inertiaMatrix2 for _ in 1:div(nElem,2)],[inertiaMatrix1 for _ in 1:div(nElem,2)])\nbeam = create_Beam(name=\"beam\",length=L,nElements=nElem,S=[stiffnessMatrix],I=inertiaMatrices,rotationParametrization=\"E321\",p0=[0;θ₀;0],hingedNodes=[div(nElem,2)+1],hingedNodesDoF=[[false,true,false]])\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/#Boundary-conditions","page":"Dynamic analysis of an articulated beam","title":"Boundary conditions","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"The boundary conditions consist of the force and moment impulses applied at one end of the beam.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"# BCs\nM₀ = 160\nτ = 0.5\nM2 = t -> ifelse.(t.<=τ, M₀, 0)\nF1 = t -> M2(t)/4\nforces = create_BC(name=\"forces\",beam=beam,node=nElem+1,types=[\"F1A\",\"M2A\"],values=[t->F1(t),t->M2(t)])\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/#Model","page":"Dynamic analysis of an articulated beam","title":"Model","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"Our model is composed of the beam and the boundary conditions. We name it flyingScissors.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"# Model\nflyingScissors = create_Model(name=\"flyingScissors\",beams=[beam],BCs=[forces])\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/#Problem","page":"Dynamic analysis of an articulated beam","title":"Problem","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"The problem is solved for a total time tf, with a time step Δt.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"# Time variables\ntf = 5\nΔt = 5e-2\n\n# Initial velocities update options\ninitialVelocitiesUpdateOptions = InitialVelocitiesUpdateOptions(maxIter=2, Δt=Δt/10)\n\n# Create and solve the problem\nproblem = create_DynamicProblem(model=flyingScissors,finalTime=tf,Δt=Δt,initialVelocitiesUpdateOptions=initialVelocitiesUpdateOptions)\nusing Suppressor #hide\n@suppress begin #hide\nsolve!(problem)\nend #hide\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/#Post-processing","page":"Dynamic analysis of an articulated beam","title":"Post-processing","text":"","category":"section"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"The first post-processing step is to retrieve the outputs of interest, namely the displacements at each end of the articulated beam.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"# Unpack numerical solution\nt = problem.timeVector\nu1_tipA = [problem.nodalStatesOverTime[i][1].u_n2[1] for i in 1:length(t)]\nu3_tipA = [problem.nodalStatesOverTime[i][1].u_n2[3] for i in 1:length(t)]\nu1_tipB = [problem.nodalStatesOverTime[i][nElem].u_n2[1] for i in 1:length(t)]\nu3_tipB = [problem.nodalStatesOverTime[i][nElem].u_n2[3] for i in 1:length(t)]\nu1_hinge = [problem.nodalStatesOverTime[i][div(nElem,2)].u_n2[1] for i in 1:length(t)]\nu3_hinge = [problem.nodalStatesOverTime[i][div(nElem,2)].u_n2[3] for i in 1:length(t)]\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"Let's plot the displacements at the tip of each link and at the hinge.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n\n# Nomalized u1 displacements\nlabels = [\"Tip A\" \"Hinge\" \"Tip B\"]\nplt1 = plot(xlabel=\"\\$t\\$ [s]\", ylabel=\"\\$u_1/L\\$\")\nplot!(t,[u1_tipA/L, u1_hinge/L, u1_tipB/L], lw=2, label=labels)\nsavefig(\"flyingScissors_u1.svg\") #hide\nnothing #hide\n\n# Nomalized u3 displacements\nplt2 = plot(xlabel=\"\\$t\\$ [s]\", ylabel=\"\\$u_3/L\\$\")\nplot!(t,[u3_tipA/L, u3_hinge/L, u3_tipB/L], lw=2, label=labels)\nsavefig(\"flyingScissors_u3.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"(Image: ) (Image: )","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"Finaly, we may visualize the motion of the beam using the function plot_dynamic_deformation with the appropriate inputs. It correlates well with the one displayed by Simo and Vu-Quoc.","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"# Animation\n@suppress begin #hide\nplot_dynamic_deformation(problem,refBasis=\"I\",plotFrequency=1,plotLimits=([0,2*L],[-L/2,L/2],[-L,0]),save=true,savePath=\"/docs/build/literate/flyingScissors_motion.gif\")\nnothing #hide\nend #hide","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"(Image: )","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"nothing #hide","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"","category":"page"},{"location":"literate/flyingScissors/","page":"Dynamic analysis of an articulated beam","title":"Dynamic analysis of an articulated beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/#Steady-aeroelastic-analysis-of-a-wing-with-flared-folding-wingtip-(FFWT)","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"","category":"section"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"This example illustrates how to set up a steady aeroelastic analysis for a wing featuring a flared folding wingtip (FFWT). The influence of the sideslip angle on the behavior of this wing model was studied numerically and experimentally by Healy et al., and more details can be found in Healy's PhD Thesis.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"(Image: )","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"Top view of aircraft model featuring a FFWT by Healy et al.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"(Image: )","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"Front view of aircraft model featuring a FFWT by Healy et al.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/#Problem-setup","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Problem setup","text":"","category":"section"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"Let's begin by setting the variables of our problem. In this example we will analyze the coasting angle of the FFWT under several combinations of wingtip twist, root pitch angle and sideslip angle, which are defined by the arrays φRange, θRange and βRange, respectively. The flare angle of the wingtip is of 20 degrees, and the airspeed is 22 m/s. A very soft rotational spring is introduced here to avoid the singularity associated with the hinge, through the variable kSpring. We also assume a fixed spanwise lift distribution through the parameter tipLossDecayFactor, in order to model three-dimensional aerodynamic effects.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"using AeroBeams, DelimitedFiles\n\n# Wingtip twist angle range\nφRange = π/180*[-6,0,9]\n\n# Root pitch angle range\nθRange = π/180*vcat(-3:3:12)\n\n# Sideslip angle range\nβRange = π/180*vcat(-10:1:30)\n\n# Flare angle [rad]\nΛ = 20*π/180\n\n# Airspeed\nU = 22\n\n# Spring stiffness\nkSpring = 1e-4\n\n# Discretization\nnElementsInner = 15\nnElementsFFWT = 5\n\n# Tip loss options (the value of tipLossDecayFactor is assumed to match the experimental results, since it strongly influences the solution, especially at lower airspeeds)\nhasTipCorrection = true\ntipLossDecayFactor = 10\n\n# Solution method for constraint\nsolutionMethod = \"addedResidual\"\n\n# System solver\nσ0 = 1\nmaxIter = 200\nrelTol = 1e-6\nNR = create_NewtonRaphson(displayStatus=false,initialLoadFactor=σ0,maximumIterations=maxIter,relativeTolerance=relTol)\n\n# Initialize outputs\nϕHinge = Array{Float64}(undef,length(φRange),length(θRange),length(βRange))\nproblem = Array{SteadyProblem}(undef,length(φRange),length(θRange),length(βRange))\nnothing #hide","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/#Solving-the-problem","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Solving the problem","text":"","category":"section"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"In the following loops, we create new model instances for each combination of wingtip twist, pitch angle and sideslip angle, create and solve the steady problem, and then extract the coasting angle of the FFWT (ϕHinge). The model creation process is streamlined with the function create_HealyFFWT, taking the appropriate inputs. We run the simulations up to the maximum sideslip angle for which convergence is achieved.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"using Suppressor #hide\n# Loop wingtip twist angle\nfor (i,φ) in enumerate(φRange)\n    # Loop root pitch angle\n    for (j,θ) in enumerate(θRange)\n        # Loop sideslip angle\n        for (k,β) in enumerate(βRange)\n            # Update model\n            model = create_HealyFFWT(solutionMethod=solutionMethod,flareAngle=Λ,kSpring=kSpring,airspeed=U,pitchAngle=θ,wingtipTwist=φ,hasTipCorrection=hasTipCorrection,tipLossDecayFactor=tipLossDecayFactor,nElementsInner=nElementsInner,nElementsFFWT=nElementsFFWT,flightDirection=[sin(β);cos(β);0])\n            # Set initial guess solution as the one from previous sideslip angle\n            x0 = (k>1 && problem[i,j,k-1].systemSolver.convergedFinalSolution) ? problem[i,j,k-1].x : zeros(0)\n            # Create and solve problem\n            problem[i,j,k] = create_SteadyProblem(model=model,systemSolver=NR,x0=x0)\n           @suppress begin #hide\n                solve!(problem[i,j,k])\n           end #hide\n            converged = problem[i,j,k].systemSolver.convergedFinalSolution\n            # Get outputs, if converged\n            ϕHinge[i,j,k] = problem[i,j,k].model.hingeAxisConstraints[1].ϕ*180/π\n            # Skip remaining sideslip angles, if unconverged or if solution for hinge angle has jumped\n            if !converged || (k > 1 && ϕHinge[i,j,k]*ϕHinge[i,j,k-1] < 0)\n                ϕHinge[i,j,k:end] .= NaN\n                break\n            end\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/#Post-processing","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Post-processing","text":"","category":"section"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"The post-processing begins by loading the reference data.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"# Load reference data\nphim6_aoam3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoam3_exp.txt\")\nphim6_aoam3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoam3_num.txt\")\nphim6_aoa0_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa0_exp.txt\")\nphim6_aoa0_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa0_num.txt\")\nphim6_aoa3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa3_exp.txt\")\nphim6_aoa3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa3_num.txt\")\nphim6_aoa6_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa6_exp.txt\")\nphim6_aoa6_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa6_num.txt\")\nphim6_aoa9_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa9_exp.txt\")\nphim6_aoa9_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa9_num.txt\")\nphim6_aoa12_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa12_exp.txt\")\nphim6_aoa12_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phim6_aoa12_num.txt\")\n\nphi0_aoam3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoam3_exp.txt\")\nphi0_aoam3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoam3_num.txt\")\nphi0_aoa0_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa0_exp.txt\")\nphi0_aoa0_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa0_num.txt\")\nphi0_aoa3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa3_exp.txt\")\nphi0_aoa3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa3_num.txt\")\nphi0_aoa6_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa6_exp.txt\")\nphi0_aoa6_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa6_num.txt\")\nphi0_aoa9_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa9_exp.txt\")\nphi0_aoa9_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa9_num.txt\")\nphi0_aoa12_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa12_exp.txt\")\nphi0_aoa12_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi0_aoa12_num.txt\")\n\nphi9_aoam3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoam3_exp.txt\")\nphi9_aoam3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoam3_num.txt\")\nphi9_aoa0_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa0_exp.txt\")\nphi9_aoa0_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa0_num.txt\")\nphi9_aoa3_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa3_exp.txt\")\nphi9_aoa3_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa3_num.txt\")\nphi9_aoa6_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa6_exp.txt\")\nphi9_aoa6_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa6_num.txt\")\nphi9_aoa9_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa9_exp.txt\")\nphi9_aoa9_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa9_num.txt\")\nphi9_aoa12_exp = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa12_exp.txt\")\nphi9_aoa12_num = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/phi9_aoa12_num.txt\")\n\nnothing #hide","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"We can now plot the coasting angle of the FFWT as a function of sideslip angle for each of the root pitch and wingtip twist angles. The following reference results (both numerical and experimental) were taken from Fig. 7.34 of Healy's PhD Thesis. Healy's numerical method is composed of a Rayleigh-Ritz structural model coupled to a VLM for aerodynamics, with the flared folding wingtip being modeled as a point inertia connected to the inner wing via a hinge. For the most part, the correlation of AeroBeams' results with the reference data is good, especially for the case of zero wingtip twist. This twist profile is very agressively introduced at the very tip of the wing, and similar convergence problems for these cases were also reported by Jan et al. with ASWING. Also note that the wingtip is limited to a fold angle of pm125^degree, a detail that is not implemented yet in AeroBeams.","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"using Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\ncolors = cgrad(:rainbow, length(θRange), categorical=true)\nlw = 2\nms = 6\nmsw = 0\nfigureNames = [\"HealyFFWTsteadySideslipRangeAoARangeCoast_phim6.svg\" \"HealyFFWTsteadySideslipRangeAoARangeCoast_phi0.svg\" \"HealyFFWTsteadySideslipRangeAoARangeCoast_phi9.svg\"]\nnothing #hide\n\n# Coast angle vs sideslip angle for each AoA, for several wingtip twist angles\nfor (i,φ) in enumerate(φRange)\n    if i==1\n        aoam3_exp = phim6_aoam3_exp\n        aoam3_num = phim6_aoam3_num\n        aoa0_exp = phim6_aoa0_exp\n        aoa0_num = phim6_aoa0_num\n        aoa3_exp = phim6_aoa3_exp\n        aoa3_num = phim6_aoa3_num\n        aoa6_exp = phim6_aoa6_exp\n        aoa6_num = phim6_aoa6_num\n        aoa9_exp = phim6_aoa9_exp\n        aoa9_num = phim6_aoa9_num\n        aoa12_exp = phim6_aoa12_exp\n        aoa12_num = phim6_aoa12_num\n    elseif i==2\n        aoam3_exp = phi0_aoam3_exp\n        aoam3_num = phi0_aoam3_num\n        aoa0_exp = phi0_aoa0_exp\n        aoa0_num = phi0_aoa0_num\n        aoa3_exp = phi0_aoa3_exp\n        aoa3_num = phi0_aoa3_num\n        aoa6_exp = phi0_aoa6_exp\n        aoa6_num = phi0_aoa6_num\n        aoa9_exp = phi0_aoa9_exp\n        aoa9_num = phi0_aoa9_num\n        aoa12_exp = phi0_aoa12_exp\n        aoa12_num = phi0_aoa12_num\n    else\n        aoam3_exp = phi9_aoam3_exp\n        aoam3_num = phi9_aoam3_num\n        aoa0_exp = phi9_aoa0_exp\n        aoa0_num = phi9_aoa0_num\n        aoa3_exp = phi9_aoa3_exp\n        aoa3_num = phi9_aoa3_num\n        aoa6_exp = phi9_aoa6_exp\n        aoa6_num = phi9_aoa6_num\n        aoa9_exp = phi9_aoa9_exp\n        aoa9_num = phi9_aoa9_num\n        aoa12_exp = phi9_aoa12_exp\n        aoa12_num = phi9_aoa12_num\n    end\n    plt = plot(xlabel=\"Sideslip angle [deg]\", ylabel=\"Coast angle [deg]\", title=\"Wingtip twist = \\$ $(round(Int,φ*180/π)) \\\\degree\\$\", xlims=[-10,30], ylims=[-150,150], yticks=-150:30:150)\n    if i==1\n        plot!(legendfontsize=7, legend=:topleft)\n    else\n        plot!(legend=false)\n    end\n    scatter!([NaN],[NaN], mc=:black, ms=ms, msw=msw, label=\"Healy (2023) - Exp.\")\n    plot!([NaN],[NaN], lc=:black, ls=:dash, lw=lw, label=\"Healy (2023) - Num.\")\n    plot!([NaN],[NaN], lc=:black, ls=:solid, lw=lw, label=\"AeroBeams\")\n    for (j,θ) in enumerate(θRange)\n        plot!(βRange*180/π, -ϕHinge[i,j,:], lw=lw, ls=:solid, c=colors[j], label=\"\\$\\\\theta = $(round(Int,θ*180/π)) \\\\degree\\$\")\n        if j==1\n            plot!(aoam3_num[1,:], aoam3_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoam3_exp[1,:], aoam3_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        elseif j==2\n            plot!(aoa0_num[1,:], aoa0_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoa0_exp[1,:], aoa0_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        elseif j==3\n            plot!(aoa3_num[1,:], aoa3_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoa3_exp[1,:], aoa3_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        elseif j==4\n            plot!(aoa6_num[1,:], aoa6_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoa6_exp[1,:], aoa6_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        elseif j==5\n            plot!(aoa9_num[1,:], aoa9_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoa9_exp[1,:], aoa9_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        else\n            plot!(aoa12_num[1,:], aoa12_num[2,:], lw=lw, ls=:dash, c=colors[j], label=false)\n            scatter!(aoa12_exp[1,:], aoa12_exp[2,:], ms=ms, msw=msw, c=colors[j], label=false)\n        end\n    end\n    savefig(figureNames[i]) #hide\nend\nnothing #hide","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"","category":"page"},{"location":"literate/HealyFFWTsteadyTwistRangeAoARangeSideslipRangeCoast/","page":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","title":"Steady aeroelastic analysis of a wing with flared folding wingtip (FFWT)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/#Flutter-and-divergence-of-a-typical-aeroelastic-section","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"","category":"section"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"This example illustrates how to set up a flutter/divergence analysis of a 2-DOF typical aeroelastic section. The typical section used was defined by Hodges and Pierce.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"(Image: ) Typical section","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/#Problem-setup","page":"Flutter and divergence of a typical aeroelastic section","title":"Problem setup","text":"","category":"section"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"Let's begin by setting up the variables of our problem: we'll model the 2-DOF (pitch and plunge) typical section, which is a two-dimensional idealization, by setting up a rigid wing supported by displacement and rotation springs. We leverage the function typical_section_data to extract the typical section parameters.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"using AeroBeams, LinearInterpolations, DelimitedFiles\n\n# Aerodynamic solver\naeroSolver = Inflow(nInflowStates=6)\n\n# Derivation method\nderivationMethod = FD(nothing)\n\n# Atmosphere\naltitude = 0\natmosphere = standard_atmosphere(altitude)\nρ = atmosphere.ρ\n\n# Given typical section data\ntypicalSectionName = \"HP-1\"\nairfoil = deepcopy(flatPlate)\na,e,μ,rα²,σ,ωα,c = typical_section_data(typicalSectionName)\n\n# Derived typical section data: semichord, mass per unit length, pitching inertia, distance from elastic axis to mass axis, plunge stiffness and pitch stiffness\nb = c/2\nm = μ * π*ρ*b^2\nIα = rα²*m*b^2\ne2 = -(e-a)*b\nkh = m*(σ*ωα)^2\nkα = Iα*ωα^2\n\n# Number of elements for the wing (the results are independent of it)\nnElem = 2\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"We now create the aerodynamic surface to be attached to the wing's beam, the attachment springs, and the rigid beam of the wing. Two sliding journals (allowing only pitch and plunge motion) are added at the wingtips, further removing any elastic effects of the beam.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Aerodynamic surface\nsurf = create_AeroSurface(solver=aeroSolver,derivationMethod=derivationMethod,airfoil=airfoil,c=c,normSparPos=(a+1)/2,updateAirfoilParameters=false)\nnothing #hide\n\n# Attachment springs (in pitch and plunge)\nsprings = create_Spring(elementsIDs=[1],nodesSides=[2],ku=kh*[0;0;1],kp=kα*[1;0;0])\n\n# Rigid wing\nL = 1\n∞ = 1e15\nwing = create_Beam(name=\"wing\",length=L,nElements=nElem,S=[isotropic_stiffness_matrix(∞=∞)],I=[inertia_matrix(ρA=m,ρIs=Iα,e2=e2)],aeroSurface=surf,springs=[springs])\n\n# BCs\njournal1 = create_BC(name=\"journal-1\",beam=wing,node=1,types=[\"u1A\",\"u2A\",\"p2A\",\"p3A\"],values=[0,0,0,0])\njournal2 = create_BC(name=\"journal-2\",beam=wing,node=nElem+1,types=[\"u1A\",\"u2A\",\"p2A\",\"p3A\"],values=[0,0,0,0])\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"The model consists of the beam and boundary conditions. We also select the airspeed range for analysis, the number of oscillatory modes to be extracted and initialize the outputs.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Model\ntypicalSectionFlutterAndDivergence = create_Model(name=\"typicalSectionFlutterAndDivergence\",beams=[wing],BCs=[journal1,journal2])\n\n# Airspeed range\nURange = b*ωα*collect(0.25:0.025:2.5)\n\n# Number of oscillatory modes\nnModes = 2\n\n# Pre-allocate memory and initialize output arrays\nuntrackedFreqs = Array{Vector{Float64}}(undef,length(URange))\nuntrackedDamps = Array{Vector{Float64}}(undef,length(URange))\nuntrackedEigenvectors = Array{Matrix{ComplexF64}}(undef,length(URange))\nproblem = Array{EigenProblem}(undef,length(URange))\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/#Problem-solution","page":"Flutter and divergence of a typical aeroelastic section","title":"Problem solution","text":"","category":"section"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"We're now ready to solve the eigenproblem at each airspeed value.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Sweep airspeed\nfor (i,U) in enumerate(URange)\n    # Update airspeed on model\n    set_motion_basis_A!(model=typicalSectionFlutterAndDivergence,v_A=[0;U;0])\n    # Create and solve eigenproblem\n    problem[i] = create_EigenProblem(model=typicalSectionFlutterAndDivergence,nModes=nModes,frequencyFilterLimits=[1e-3,1e3])\n    solve!(problem[i])\n    # Frequencies, dampings and eigenvectors\n    untrackedFreqs[i] = problem[i].frequenciesOscillatory\n    untrackedDamps[i] = round_off!(problem[i].dampingsOscillatory,1e-8)\n    untrackedEigenvectors[i] = problem[i].eigenvectorsOscillatoryCplx\nend\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/#Post-processing","page":"Flutter and divergence of a typical aeroelastic section","title":"Post-processing","text":"","category":"section"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"The first post-processing step is to use the built-in mode tracking algorithm to enhance our chances of correctly tracking the oscillatory modes. We then set arrays for the frequecies and dampings of each mode, and find the flutter onset and offset (actually absent in this case) speeds. To identify the divergence, we have to look at the damping of the non-oscillatory (zero-frequency) modes.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Apply mode tracking\nfreqs,damps,_ = mode_tracking(URange,untrackedFreqs,untrackedDamps,untrackedEigenvectors)\n\n# Separate frequencies and damping ratios by mode\nmodeFrequencies = Array{Vector{Float64}}(undef,nModes)\nmodeDampings = Array{Vector{Float64}}(undef,nModes)\nfor mode in 1:nModes\n    modeFrequencies[mode] = [freqs[i][mode] for i in eachindex(URange)]\n    modeDampings[mode] = [damps[i][mode] for i in eachindex(URange)]\nend\n\n# Flutter speed and flutter frequency\nflutterOnsetSpeed = [Float64[] for _ in 1:nModes]\nflutterOnsetFreq = [Float64[] for _ in 1:nModes]\nflutterOffsetSpeed = [Float64[] for _ in 1:nModes]\nflutterOffsetFreq = [Float64[] for _ in 1:nModes]\nfor mode in 1:nModes\n    # Flutter onset\n    iOnset = 1 .+ findall(i -> modeDampings[mode][i] < 0 && modeDampings[mode][i+1] > 0, 1:length(modeDampings[mode])-1)\n    if isempty(iOnset) || isempty(filter!(x->x!=1,iOnset))\n        continue\n    end\n    for i in iOnset\n        push!(flutterOnsetSpeed[mode],interpolate(modeDampings[mode][i-1:i],URange[i-1:i],0))\n        push!(flutterOnsetFreq[mode],interpolate(modeDampings[mode][i-1:i],modeFrequencies[mode][i-1:i],0))\n    end\n    # Flutter offset\n    iOffset = 1 .+ findall(i -> modeDampings[mode][i] > 0 && modeDampings[mode][i+1] < 0, 1:length(modeDampings[mode])-1)\n    if isempty(iOffset)\n        continue\n    end\n    for i in iOffset\n        push!(flutterOffsetSpeed[mode],interpolate(-modeDampings[mode][i-1:i],URange[i-1:i],0))\n        push!(flutterOffsetFreq[mode],interpolate(-modeDampings[mode][i-1:i],modeFrequencies[mode][i-1:i],0))\n    end\nend\n\n# Damping of non-oscillatory modes\ndampingsNonOscillatory = [problem[i].dampingsNonOscillatory for i in eachindex(URange)]\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"We also load a reference solution obtained using the p method for stability analysis using the unsteady aerodynamic theory of Peters et al., as proposed in problem 5.7 of Hodges and Pierce.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Load reference data\nfreqsRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/typicalSectionFlutterAndDivergence/freqs.txt\")\ndampsRef = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/typicalSectionFlutterAndDivergence/damps.txt\")\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"We'll visualize the results through the V-g-f diagrams, i.e., the evolution of the frequencies and dampings (both normalized by the in vacuo pitching frequency) with airspeed. The flutter speed is that at which the damping of an oscillatory mode, in this case the pitch mode, becomes positive. Conversely, the divergence speed is that at which the damping of a non-oscillatory mode becomes positive. The results match almost exactly! Notice that once the damping of the non-oscillatory mode leading to divergence becomes positive, AeroBeams can no longer identify it. This is a current limitation of package, albeit the divergence speed can be computed in spite of it. See this example to learn how.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"using Plots, ColorSchemes\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\nnothing #hide\n\n# Plot configurations\nmodeColors = get(colorschemes[:rainbow], LinRange(0, 1, nModes+1))\nmodeLabels = [\"Plunge\" \"Pitch\"]\nlw = 3\nms = 2\nmsw = 0\n\n# Frequency plot\nplt11 = plot(ylabel=\"Frequency ratio\", xlims=[0,URange[end]/(b*ωα)], ylims=[0,1.02])\nfor mode in 1:nModes\n    plot!(URange/(b*ωα), modeFrequencies[mode]/ωα, c=modeColors[mode], lw=lw,  label=false)\nend\nplot!(freqsRef[1,:], freqsRef[2,:], ls=:dash, lw=1, marker=:circle, ms=2, msw=msw, c=modeColors[end], label=false)\n# Damping plot\nplt12 = plot(xlabel=\"Airspeed [m/s]\", ylabel=\"Damping Ratio\", xlims=[0,URange[end]/(b*ωα)], ylims=[-0.15,0.15],legend=:topleft)\nfor i in eachindex(URange)\n    for j in eachindex(dampingsNonOscillatory[i])\n        scatter!([URange[i]/(b*ωα)], [dampingsNonOscillatory[i][j]/ωα], c=:black, ms=ms, msw=msw, label=false)\n    end\nend\nscatter!([NaN], [NaN], c=:black, ms=ms, msw=msw, label=\"Non-oscillatory\")\nfor mode in 1:nModes\n    plot!(URange/(b*ωα), modeDampings[mode]/ωα, c=modeColors[mode], lw=lw, label=modeLabels[mode])\nend\nplot!(dampsRef[1,:], dampsRef[2,:], ls=:dash, lw=1, marker=:circle, ms=2, msw=msw, c=modeColors[end], label=\"Hodges & Pierce (2011) - \\$p\\$ method\")\nplt1 = plot(plt11,plt12, layout=(2,1))\nsavefig(\"typicalSectionFlutter_Vgf.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"(Image: )","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"Finally, we show the numerical values of the nondimensional flutter speed and frequency. The values computed by Hodges & Pierce are 2.165 and 0.6545, respectively.","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"# Compute nondimensional flutter speed and frequency\nflutterSpeedAll = vcat(flutterOnsetSpeed...)\nflutterFreqAll = vcat(flutterOnsetFreq...)\nind = argmin(flutterSpeedAll)\nflutterSpeed = flutterSpeedAll[ind]\nflutterFreq = flutterFreqAll[ind]\nprintln(\"Nondimensional flutter speed = $(flutterSpeed/(b*ωα))\")\nprintln(\"Nondimensional flutter frequency = $(flutterFreq/ωα)\")","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"","category":"page"},{"location":"literate/typicalSectionFlutterAndDivergence/","page":"Flutter and divergence of a typical aeroelastic section","title":"Flutter and divergence of a typical aeroelastic section","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/archUnderFollowerPressure/#Static-structural-analysis-of-an-arch-under-follower-pressure","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"This example simulates the static response of a clamped arch subjected to a normal (follower) pressure. It illustrates how to set up a steady structural problem for an initially curved beam subjected to follower distributed loads. The problem was defined by Argyris and Symeonidis.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"(Image: ) Clamped circular arch under normal pressure by Argyris and Symeonidis","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/archUnderFollowerPressure/#Beam","page":"Static structural analysis of an arch under follower pressure","title":"Beam","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"The first step is to create a beam. The arch has radius R and spans over and angle θ. The curvature of the beam is thus 1/R, and the total length is L=Rθ. We define the beam orientation such that the arch spans from an angle -θ/2 to θ/2 about a vertical line. This is done by specifying the rotation parameters from basis A to basis b, p0, with the Euler parameters sequence 3-2-1: the angle of rotation about the second axis is -θ/2. The cross-section has area A and bending moment of inertia Iy. The elastic modulus of the material is E. We discretize the beam into nElem finite elements. In this case the properties of the beam are constant over its length, to see a case where those properties vary, check this example.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# Beam\nusing AeroBeams\n\nR,θ = 2.54,120*π/180\nk2 = 1/R\nL = R*θ\nA,Iy = 4.05e-4,13.1e-8\nE = 70.4e9\nEA,EIy = E*A,E*Iy\nnElem = 40\nbeam = create_Beam(name=\"arch\",length=L,nElements=nElem,S=[isotropic_stiffness_matrix(∞=1e12,EA=EA,EIy=EIy)],rotationParametrization=\"E321\",p0=[0;-θ/2;0],k=[0;k2;0])\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/#BCs","page":"Static structural analysis of an arch under follower pressure","title":"BCs","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"Now we create the boundary conditions (including the pressure load). The normalized load is defined by the λ variable, and the maximum value of the actual distributed load per unit length is q. We add this constant load to the arch as a distributed follower force initially resolved in basis A. We then clamp both ends of the beam (nodes 1 and nElem+1) by setting the displacements and rotations to zero.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# BCs\nλ = 11\nq = -λ*EIy/R^2\nadd_loads_to_beam!(beam,loadTypes=[\"ff_b_of_x1t\"],loadFuns=[(x1,t)->[0; 0; q]])\nclamp1 = create_BC(name=\"clamp1\",beam=beam,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamp2 = create_BC(name=\"clamp2\",beam=beam,node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/#Model","page":"Static structural analysis of an arch under follower pressure","title":"Model","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"We are now ready to create the model itself. It is composed of the beam and the boundary conditions.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# Model\narchUnderFollowerPressure = create_Model(name=\"archUnderFollowerPressure\",beams=[beam],BCs=[clamp1,clamp2])\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/#System-solver","page":"Static structural analysis of an arch under follower pressure","title":"System solver","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"We can set an optional system solver for the nonlinear algebraic system of equations resulting from the finite element discretization. In this case we choose to start with a load factor σ0 and increase it in steps σstep (up to the ultimate load factor of one). We then create a Newton-Raphson solver with these options.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# System solver\nσ0 = 0\nσstep = 0.02\nNR = create_NewtonRaphson(initialLoadFactor=σ0,maximumLoadFactorStep=σstep)\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/#Problem","page":"Static structural analysis of an arch under follower pressure","title":"Problem","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"Now we define the steady problem, by inputting the model and our optional system solver, and then solve it.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# Problem\nproblem = create_SteadyProblem(model=archUnderFollowerPressure,systemSolver=NR)\nsolve!(problem)\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/#Post-processing","page":"Static structural analysis of an arch under follower pressure","title":"Post-processing","text":"","category":"section"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"We are interested in the behavior of the arch's midpoint transverse displacement (in the x3 direction) as a function of the load. So we can get solution at all partial load steps. The array of the partial load factors is σVector, and the corresponding midpoint displacements are mid_u3.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# Unpack outputs\nσVector = problem.savedσ\nmid_u3 = [problem.nodalStatesOverσ[i][div(nElem,2)].u_n2[3] for i in 1:length(σVector)]\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"The following plot shows the midpoint displacement as a function of the load.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\n# Plot displacement\nplot(-mid_u3/R, σVector*λ, color=:black, lw=2, xlabel=\"Midpoint \\$-u_3/R\\$\", ylabel=\"\\$\\\\lambda\\$\", label=false)\nsavefig(\"archUnderFollowerPressure_disp.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"(Image: )","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"Let's also plot the initial and final deformed shape of the arch (scaled ten-fold), along with the boundary conditions. To do that, we exploit AeroBeams' built-in visualization capabilities, by simply calling the plot_steady_deformation() function accordingly.","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"# Plot deformed shape\nplot_steady_deformation(problem,scale=10,showScale=true,scalePos=[0.5,2.2])\nsavefig(\"archUnderFollowerPressure-deformed.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"(Image: )","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"","category":"page"},{"location":"literate/archUnderFollowerPressure/","page":"Static structural analysis of an arch under follower pressure","title":"Static structural analysis of an arch under follower pressure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/compositeCantileverMD/#Static-structural-analysis-of-composite-beams","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"","category":"section"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"This example illustrates how to set up a static structural analysis of composite beams. We will investigate the deflection of several composite beams under tip loads caused by attached weights. This problem was proposed by Minguet and Dugundji:","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"(Image: )","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"Beam geometry by Minguet and Dugundji","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"(Image: )","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"Laminate properties by Minguet and Dugundji","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/compositeCantileverMD/#Problem-setup","page":"Static structural analysis of composite beams","title":"Problem setup","text":"","category":"section"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"Let's begin by setting up the variables of our problem. We create three beams, each of a different composite laminate, clamp them ar the root, and apply the tip load. Notice that only beam 1 has a diagonal sectional stiffness matrix, whereas the others have coupling terms.","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"using AeroBeams, LinearAlgebra, DelimitedFiles\n\n# Properties common to all beams\nL = 0.55\nnElem = 22\n\n# Rotation angles\nθRange = π/4*[0, 1]\n\n# Gravity\ng = 9.80665\n\n# Tip load mass\nm = 0.5\n\n# Tip weight\nW = m*g\n\n# Beam 1\nstiffnessMatrix1 = diagm([3.7e6,2.6e5,2.9e5,0.183,0.707,276])\nbeam1 = create_Beam(name=\"beam1\",length=L,nElements=nElem,S=[stiffnessMatrix1],rotationParametrization=\"E321\")\n\n# Beam 2\nstiffnessMatrix2 = diagm([4e6,2.6e5,5.5e5,0.368,0.522,298])\nstiffnessMatrix2[1,2] = stiffnessMatrix2[2,1] = -2.7e5\nstiffnessMatrix2[4,5] = stiffnessMatrix2[5,4] = -0.102\nbeam2 = create_Beam(name=\"beam2\",length=L,nElements=nElem,S=[stiffnessMatrix2],rotationParametrization=\"E321\")\n\n# Beam 3\nstiffnessMatrix3 = diagm([3.9e6,1.1e6,1.2e5,1.18,0.983,290])\nstiffnessMatrix3[1,4] = stiffnessMatrix3[4,1] = -522\nbeam3 = create_Beam(name=\"beam3\",length=L,nElements=nElem,S=[stiffnessMatrix3],rotationParametrization=\"E321\")\n\n# BCs\nclamp1 = create_BC(name=\"clamp1\",beam=beam1,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\ntipLoad1 = create_BC(name=\"tipLoad1\",beam=beam1,node=nElem+1,types=[\"F3A\"],values=[-W])\nclamp2 = create_BC(name=\"clamp2\",beam=beam2,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\ntipLoad2 = create_BC(name=\"tipLoad2\",beam=beam2,node=nElem+1,types=[\"F3A\"],values=[-W])\nclamp3 = create_BC(name=\"clamp3\",beam=beam3,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\ntipLoad3 = create_BC(name=\"tipLoad3\",beam=beam3,node=nElem+1,types=[\"F3A\"],values=[-W])\n\n# Models\ncompositeCantilever1 = create_Model(name=\"compositeCantilever1\",beams=[beam1],BCs=[clamp1,tipLoad1])\ncompositeCantilever2 = create_Model(name=\"compositeCantilever2\",beams=[beam2],BCs=[clamp2,tipLoad2])\ncompositeCantilever3 = create_Model(name=\"compositeCantilever3\",beams=[beam3],BCs=[clamp3,tipLoad3])\n\n# Set system solver options\nσ0 = 0\nσstep = 0.1\nNR = create_NewtonRaphson(initialLoadFactor=σ0,maximumLoadFactorStep=σstep,minimumLoadFactorStep=σstep)\n\n# Initialize outputs: displacements at x1 = 500 mm\nσVector = Array{Vector{Float64}}(undef,3,2)\nu1_500mm = Array{Vector{Float64}}(undef,3,2)\nu2_500mm = Array{Vector{Float64}}(undef,3,2)\nu3_500mm = Array{Vector{Float64}}(undef,3,2)\nnothing #hide","category":"page"},{"location":"literate/compositeCantileverMD/#Problem-solution","page":"Static structural analysis of composite beams","title":"Problem solution","text":"","category":"section"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"We can sweep the range of root rotation angle, θRange, to find the solution at each value for each beam.","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"# Loop root angles\nfor (j,θ) in enumerate(θRange)\n    # Update beams' rotation\n    beam1.p0[3] = beam2.p0[3] = beam3.p0[3] = θ\n    update_beam!(beam1); update_model!(compositeCantilever1)\n    update_beam!(beam2); update_model!(compositeCantilever2)\n    update_beam!(beam3); update_model!(compositeCantilever3)\n    # Create and solve the problems\n    problem1 = create_SteadyProblem(model=compositeCantilever1,systemSolver=NR)\n    problem2 = create_SteadyProblem(model=compositeCantilever2,systemSolver=NR)\n    problem3 = create_SteadyProblem(model=compositeCantilever3,systemSolver=NR)\n    solve!(problem1)\n    solve!(problem2)\n    solve!(problem3)\n    # Save outputs\n    σVector[1,j] = problem1.savedσ\n    σVector[2,j] = problem2.savedσ\n    σVector[3,j] = problem3.savedσ\n    u1_500mm[1,j] = [problem1.nodalStatesOverσ[i][nElem-1].u_n1[1] for i in 1:length(σVector[1,j])]\n    u1_500mm[2,j] = [problem2.nodalStatesOverσ[i][nElem-1].u_n1[1] for i in 1:length(σVector[2,j])]\n    u1_500mm[3,j] = [problem3.nodalStatesOverσ[i][nElem-1].u_n1[1] for i in 1:length(σVector[3,j])]\n    u2_500mm[1,j] = [problem1.nodalStatesOverσ[i][nElem-1].u_n1[2] for i in 1:length(σVector[1,j])]\n    u2_500mm[2,j] = [problem2.nodalStatesOverσ[i][nElem-1].u_n1[2] for i in 1:length(σVector[2,j])]\n    u2_500mm[3,j] = [problem3.nodalStatesOverσ[i][nElem-1].u_n1[2] for i in 1:length(σVector[3,j])]\n    u3_500mm[1,j] = [problem1.nodalStatesOverσ[i][nElem-1].u_n1[3] for i in 1:length(σVector[1,j])]\n    u3_500mm[2,j] = [problem2.nodalStatesOverσ[i][nElem-1].u_n1[3] for i in 1:length(σVector[2,j])]\n    u3_500mm[3,j] = [problem3.nodalStatesOverσ[i][nElem-1].u_n1[3] for i in 1:length(σVector[3,j])]\nend\nnothing #hide","category":"page"},{"location":"literate/compositeCantileverMD/#Post-processing","page":"Static structural analysis of composite beams","title":"Post-processing","text":"","category":"section"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"Let's load the reference experimental solution by Minguet and Dugundji.","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"# Load reference solution\nu1_b1_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th0_u1.txt\")\nu2_b1_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th0_u2.txt\")\nu3_b1_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th0_u3.txt\")\nu1_b1_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th45_u1.txt\")\nu2_b1_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th45_u2.txt\")\nu3_b1_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b1_th45_u3.txt\")\nu1_b2_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th0_u1.txt\")\nu2_b2_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th0_u2.txt\")\nu3_b2_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th0_u3.txt\")\nu1_b2_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th45_u1.txt\")\nu2_b2_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th45_u2.txt\")\nu3_b2_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b2_th45_u3.txt\")\nu1_b3_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th0_u1.txt\")\nu2_b3_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th0_u2.txt\")\nu3_b3_th0_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th0_u3.txt\")\nu1_b3_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th45_u1.txt\")\nu2_b3_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th45_u2.txt\")\nu3_b3_th45_ref = readdlm(pkgdir(AeroBeams)*\"/test/referenceData/compositeCantileverMD/b3_th45_u3.txt\")\nnothing #hide","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"Finally, we may plot the displacements at x_1 = 500 mm for each beam in each configuration. The correlation with the experimental data is good, and matches the numerical results of Minguet and Dugundji as well (not shown).","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"using Plots\ngr()\nENV[\"GKSwstype\"] = \"100\" #hide\nnothing #hide\n\n# Plot configurations\nlabels = [\"\\$-u_1\\$\" \"\\$u_2\\$\" \"\\$-u_3\\$\"]\nxLabel = \"\\$-u_1, u_2, -u_3\\$ [m]\"\nyLabel = \"Load [grams]\"\ncolors = [:blue,:orange,:green]\nlw = 2\nms = 5\nmsw = 0\n\n# Beam 1, θ=0⁰\nplt11 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 1, \\$\\\\theta=0^{\\\\degree}\\$\")\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\" Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[1,1], u2_500mm[1,1], -u3_500mm[1,1]], colors)\n    plot!(x, σVector[1,1]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b1_th0_ref[1,:], u2_b1_th0_ref[1,:], u3_b1_th0_ref[1,:]], [u1_b1_th0_ref[2,:], u2_b1_th0_ref[2,:], u3_b1_th0_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b1th0.svg\") #hide\nnothing #hide\n\n# Beam 1, θ=45⁰\nplt12 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 1, \\$\\\\theta=45^{\\\\degree}\\$\")\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\"  Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[1,2], u2_500mm[1,2], -u3_500mm[1,2]], colors)\n    plot!(x, σVector[1,2]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b1_th45_ref[1,:], u2_b1_th45_ref[1,:], u3_b1_th45_ref[1,:]], [u1_b1_th45_ref[2,:], u2_b1_th45_ref[2,:], u3_b1_th45_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b1th45.svg\") #hide\nnothing #hide\n\n# Beam 2, θ=0⁰\nplt21 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 2, \\$\\\\theta=0^{\\\\degree}\\$\")\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\"  Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[2,1], u2_500mm[2,1], -u3_500mm[2,1]], colors)\n    plot!(x, σVector[2,1]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b2_th0_ref[1,:], u2_b2_th0_ref[1,:], u3_b2_th0_ref[1,:]], [u1_b2_th0_ref[2,:], u2_b2_th0_ref[2,:], u3_b2_th0_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b2th0.svg\") #hide\nnothing #hide\n\n# Beam 2, θ=45⁰\nplt22 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 2, \\$\\\\theta=45^{\\\\degree}\\$\", legend=:bottomright)\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\"  Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[2,2], u2_500mm[2,2], -u3_500mm[2,2]], colors)\n    plot!(x, σVector[2,2]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b2_th45_ref[1,:], u2_b2_th45_ref[1,:], u3_b2_th45_ref[1,:]], [u1_b2_th45_ref[2,:], u2_b2_th45_ref[2,:], u3_b2_th45_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b2th45.svg\") #hide\nnothing #hide\n\n# Beam 3, θ=0⁰\nplt31 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 3, \\$\\\\theta=0^{\\\\degree}\\$\")\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\"  Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[3,1], u2_500mm[3,1], -u3_500mm[3,1]], colors)\n    plot!(x, σVector[3,1]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b3_th0_ref[1,:], u2_b3_th0_ref[1,:], u3_b3_th0_ref[1,:]], [u1_b3_th0_ref[2,:], u2_b3_th0_ref[2,:], u3_b3_th0_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b3th0.svg\") #hide\nnothing #hide\n\n# Beam 3, θ=45⁰\nplt32 = plot(xlabel=xLabel, ylabel=yLabel, title=\"Beam 3, \\$\\\\theta=45^{\\\\degree}\\$\")\nplot!([NaN], [NaN], lc=:black, lw=lw, label=\"AeroBeams\")\nscatter!([NaN], [NaN], mc=:black, ms=ms, label=\"  Experimental\")\nfor i=1:3\n    plot!([NaN], [NaN], c=colors[i], m=colors[i], lw=lw, ms=ms, msw=msw, label=labels[i])\nend\nfor (x, c) in zip([-u1_500mm[3,2], u2_500mm[3,2], -u3_500mm[3,2]], colors)\n    plot!(x, σVector[3,2]*W/g*1e3, c=c, lw=lw, label=false)\nend\nfor (x, y, c) in zip([u1_b3_th45_ref[1,:], u2_b3_th45_ref[1,:], u3_b3_th45_ref[1,:]], [u1_b3_th45_ref[2,:], u2_b3_th45_ref[2,:], u3_b3_th45_ref[2,:]], colors)\n    scatter!(x, y, c=c, ms=ms, msw=msw, label=false)\nend\nsavefig(\"compositeCantileverMD_b3th45.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"","category":"page"},{"location":"literate/compositeCantileverMD/","page":"Static structural analysis of composite beams","title":"Static structural analysis of composite beams","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/twoStoryFrame/#Modal-analysis-of-a-two-story-frame","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"This example illustrates how to set up a modal analysis, using a two-story beam frame. Moreover, it also shows how to assemble a model where the beams are not all connected in sequence. This problem was proposed by Petyt.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"(Image: )","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"Geometry of the two-story frame by Petyt","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"tip: Tip\nThe code for this example is available here.","category":"page"},{"location":"literate/twoStoryFrame/#Problem-variables","page":"Modal analysis of a two-story frame","title":"Problem variables","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"The first step is to define the variables of our problem: geometric and material properties, and discretization. There are two types of beams in the frame: vertical ones have cross-section base b1 and horizontal ones have base b2, but all are made of the same material. We also apply an uniform discretization.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"using AeroBeams, LinearAlgebra\n\n# Geometric properties\nL = 1\nb1,b2,h = 5e-2,15e-2,5e-2\nA1,Iy1,Iz1 = b1*h,b1*h^3/12,h*b1^3/12\nA2,Iy2,Iz2 = b2*h,b2*h^3/12,h*b2^3/12\nJ1 = Is1 = A1^4/(Iy1+Iz1)/40\nJ2 = Is2 = A2^4/(Iy2+Iz2)/40\nKt1,Kt2 = 10/9,3.0864\nα = [0; 0; π/2; 0; 0; π/2; 0; 0; 0; 0; 0; 0; π/2; 0; 0; π/2]\nβ = -[π/2; π/2; 0; -π/2; -π/2; 0; 0; 0; 0; 0; -π/2; π/2; 0; -π/2; -π/2; 0]\n\n# Material properties\nE = 219.9e9\nν = 0.25\nG = E/(2*(1+ν))\nρ = 7.9e3\n∞ = 1e12\n\n# Stiffness and inertia matrices\nstiffnessMatrices = [diagm([E*A1,∞,∞,G*J1*Kt1,E*Iy1,E*Iz1]),diagm([E*A2,∞,∞,G*J2*Kt2,E*Iy2,E*Iz2])]\ninertiaMatrices = [diagm([ρ*A1,ρ*A1,ρ*A1,ρ*Is1,ρ*Iy1,ρ*Iz1]),diagm([ρ*A2,ρ*A2,ρ*A2,ρ*Is2,ρ*Iy2,ρ*Iz2])]\n\n# Number of elements for each beam\nnElem = 10\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/#Beams-of-the-frame","page":"Modal analysis of a two-story frame","title":"Beams of the frame","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"In the following we initialize an array of beams and create each one in turn. Notice that their disposition in space is defined by the rotation parameters from the global basis mathcalA to the undeformed beam basis b^+, p0. Moreover, since this is a frame, the beams are not all connected in sequence. That means there are connection nodes, which need to be specified. That is done by setting in create_Beam the keywords connectedBeams (an array of the beams to which the present one connects), connectedNodesThis (the corresponding array of nodes of connectedBeams to which the present one connects) and connectedNodesOther (the corresponding array of nodes of the present beam that connect to connectedNodesOther). Notice that these arguments are recursive, that is, you only need to reference beams that were already created (if beam 2 connects to beam 1, those arguments need to be set up only for beam 2).","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"# Beams\nbeams = Vector{Beam}(undef,16)\n\nbeams[1] = create_Beam(name=\"beam1\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[1];β[1];0.0])\n\nbeams[2] = create_Beam(name=\"beam2\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[2];β[2];0.0],connectedBeams=[beams[1]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[3] = create_Beam(name=\"beam3\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[3];β[3];0.0],connectedBeams=[beams[2]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[4] = create_Beam(name=\"beam4\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[4];β[4];0.0],connectedBeams=[beams[3]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[5] = create_Beam(name=\"beam5\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[5];β[5];0.0],connectedBeams=[beams[4]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[6] = create_Beam(name=\"beam6\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[6];β[6];0.0],connectedBeams=[beams[1],beams[4]],connectedNodesThis=[1,nElem+1],connectedNodesOther=[nElem+1,nElem+1])\n\nbeams[7] = create_Beam(name=\"beam7\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[7];β[7];0.0],connectedBeams=[beams[1]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[8] = create_Beam(name=\"beam8\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[8];β[8];0.0],connectedBeams=[beams[4]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[9] = create_Beam(name=\"beam9\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[9];β[9];0.0],connectedBeams=[beams[2]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[10] = create_Beam(name=\"beam10\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[10];β[10];0.0],connectedBeams=[beams[3]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[11] = create_Beam(name=\"beam11\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[11];β[11];0.0],connectedBeams=[beams[7]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[12] = create_Beam(name=\"beam12\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[12];β[12];0.0],connectedBeams=[beams[7],beams[9]],connectedNodesThis=[1,nElem+1],connectedNodesOther=[nElem+1,nElem+1])\n\nbeams[13] = create_Beam(name=\"beam13\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[13];β[13];0.0],connectedBeams=[beams[9],beams[10]],connectedNodesThis=[1,nElem+1],connectedNodesOther=[nElem+1,nElem+1])\n\nbeams[14] = create_Beam(name=\"beam14\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[14];β[14];0.0],connectedBeams=[beams[13],beams[8]],connectedNodesThis=[1,nElem+1],connectedNodesOther=[nElem+1,nElem+1])\n\nbeams[15] = create_Beam(name=\"beam15\",length=L,nElements=nElem,S=[stiffnessMatrices[1]],I=[inertiaMatrices[1]],rotationParametrization=\"E321\",p0=[α[15];β[15];0.0],connectedBeams=[beams[8]],connectedNodesThis=[1],connectedNodesOther=[nElem+1])\n\nbeams[16] = create_Beam(name=\"beam16\",length=L,nElements=nElem,S=[stiffnessMatrices[2]],I=[inertiaMatrices[2]],rotationParametrization=\"E321\",p0=[α[16];β[16];0.0],connectedBeams=[beams[7],beams[8]],connectedNodesThis=[1,nElem+1],connectedNodesOther=[nElem+1,nElem+1])\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/#Boundary-conditions","page":"Modal analysis of a two-story frame","title":"Boundary conditions","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"The frame is clamped at the four base points.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"# BCs\nclamps = Vector{BC}(undef,4)\nclamps[1] = create_BC(name=\"clamp1\",beam=beams[1],node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamps[2] = create_BC(name=\"clamp2\",beam=beams[5],node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamps[3] = create_BC(name=\"clamp3\",beam=beams[11],node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamps[4] = create_BC(name=\"clamp4\",beam=beams[15],node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/#Model","page":"Modal analysis of a two-story frame","title":"Model","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"Our model is composed of the beams and boundary conditions. We further specify the units, merely for plotting purposes, using the constructor create_UnitsSystem.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"# Model\ntwoStoryFrame = create_Model(name=\"twoStoryFrame\",beams=beams,BCs=clamps,units=create_UnitsSystem(length=\"m\",frequency=\"Hz\"))\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/#Create-and-solve-problem","page":"Modal analysis of a two-story frame","title":"Create and solve problem","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"We create and solve the eigenproblem, specifying the model, number of modes of vibration to be extracted, and the flag to get the linear structural solution.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"# Problem\nproblem = create_EigenProblem(model=twoStoryFrame,nModes=4,getLinearSolution=true)\nsolve!(problem)\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/#Post-processing","page":"Modal analysis of a two-story frame","title":"Post-processing","text":"","category":"section"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"We can now extract the frequencies of vibration and compare to the reference finite element solution. The agreement is very good. Notice that only the first and seconding bending mode (swaying modes) in a specific direction are compared, since this problem is symmetric.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"# Frequencies\nfreqs = problem.frequenciesOscillatory\n\n# Reference frequencies (in Hz)\nrefFreqs = [11.8; 34.1]\n\n# Display relative errors\nϵ_rel = freqs[[1,4]]/(2π)./refFreqs .- 1.0\nprintln(\"Relative errors: $ϵ_rel\")\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"We can also visualize the mode shapes using the function plot_mode_shapes with the appropriate arguments. They compare well to thosed described in the reference.","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"using Plots #hide\nmodesPlot = plot_mode_shapes(problem,scale=1,view=(45,30),legendPos=(0.3,0.1),frequencyLabel=\"frequency\",modalColorScheme=:rainbow)\nsavefig(\"twoStoryFrame_modeShapes.svg\") #hide\nnothing #hide","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"(Image: ) (Image: )","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"Swaying modes of the two-story frame by Petyt","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"","category":"page"},{"location":"literate/twoStoryFrame/","page":"Modal analysis of a two-story frame","title":"Modal analysis of a two-story frame","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AeroBeams.jl","page":"Home","title":"AeroBeams.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for the simulation of aeroelastic problems in beam structures","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for AeroBeams.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AeroBeams is a finite-element implementation of the geometrically exact beam theory of Hodges[1] [2], augmented with aerodynamic formulations in order to solve aeroelastic problems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install AeroBeams, simply go to the package manager mode in the Julia REPL by typing ], and then","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add AeroBeams","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software is a general-purpose aeroelastic solver for flexible aircraft structures that can be modeled as an assembly of anisotropic, initially curved and twisted beams undergoing arbitrarily large displacements and rotations. Multibody dynamics capabilities include only simple hinges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The assembly of beams can be subjected to time-dependent boundary conditions that can be specified either in a global or local frame of reference, including: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nodal displacements and rotations\nConcentrated, dead or follower nodal forces and moments\nDistributed, dead or follower forces and moments\nGravitational loads","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other assembly capabilities include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Concentrated elemental inertias\nAttached nodal springs","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aerodynamic models are based on strip theory augmented with specified spanwise corrections. The following are available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quasi-steady\nLinear unsteady (indicial[5] and inflow[6] methods) \nDynamic stall (original[7] and modified Beddoes-Leishman models[8]) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The beam assembly can also be immersed in gust fields, such as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discrete gusts (sharp-edged, one-minus-cosine, ...)\nContinuous gusts (based on von Kármán or Dryden 2-dimensional spectra)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Four types of analysis can be simulated:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Steady: when all time derivatives are zero.\nTrim: a steady analysis in which the attitude, flap/elevator deflections and loads (such as thrust) are treated as unknowns (trim variables) to be solved for. \nVibration/Stability: an eigenvalue-based (linearized) analysis of small motions about a deformed state.\nDynamic: time-marching.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple built-in post-processing tool allows the visualization of the results. Here is an example of the large-displacement motion of limit-cycle oscillations of the Pazy wing benchmark after encountering a gust:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Pazy Wing Gust Response)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Purely structural problems (in the abscence of aerodynamic loads) can analyzed as well, such as the \"flying spaghetti\"[9]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: flying spaghetti)","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A few limitations of the theory to keep in mind when using this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The strain measures considered yield a \"Timoshenko\" beam theory, which is valid for beams of solid or thin-walled, but closed cross-sections, and beams of strip-like cross-sections. It is not accurate for beams of thin-walled, open cross-section (like \"C\", \"I\", \"L\", \"T\", \"Z\", etc) for which the warping of the cross-section caused by torsion is important. For these, a \"Vlasov\" beam theory would be required.\nThe force-strain relationship of the material is assumed to be linear, i.e., the strains are assumed to be small.\nStructural damping is not modeled.\nThe formulation does not account for the trapeze effect, which is the tendency of a twisted beam to untwist (twist) as a traction (compression) force is applied. This effect can be important for beams of open cross-section (whose torsional compliance is high) under axial loads.\nThree-dimensional aerodynamic effects in wings are not modeled directly (such as in panel methods), but rather only through a specified distribution function.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GXBeam is a similar package for solving problems in beam structures. It also makes use of Hodges' equations for Timoshenko beams, though modified to include structural damping. It can also compute the sectional properties (stiffness and inertia matrices) and recover the cross-sectional strains and stresses for arbitrary (geometry- and material-wise) cross sections.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BeamDyn is a module of the OpenFAST wind turbine simulation tool. It also employs a geometrically exact beam theory, though it uses Legendre spectral finite elements for faster grid convergence, specially when dealing with varying properties along the beam arclength.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GEBT[3] [4] was the first open source implementation of the geometrically exact beam theory proposed by Hodges. All previously mentioned packages (including AeroBeams.jl) are based on it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GEBTAero couples GEBT with the 2D aerodynamic model of finite states[6] to yield an aeroelastic program for very flexible wings. It is geared towards maximum computational efficiency, and can compute sectional beam properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SHARPy is an aeroelastic simulation toolbox for very flexible aircraft and wind turbines. On the structural side, it employs a displacement-based geometrically exact beam formulation, whereas the aerodynamic modeling uses the Unsteady Vortex Lattice Method (UVLM) and the Source Panel Method (SPM).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The University of Michigan's Nonlinear Aeroelastic Simulation Toolbox (UM/NAST) is a framework for simulating the flight dynamics of flexible aircraft structures modeled as an assembly of beams. It implements a strain-based geometrically exact beam theory[10]. It is not, however, an open source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AeroFlex is a MATLAB toolbox for studying the flight dynamics of highly flexible airplanes, which makes use of the same formulation as UM/NAST, and is open source.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ASWING is a program for the aerodynamic, structural, and control-response analysis of aircraft with flexible wings and fuselages of high to moderate aspect ratio. It uses a displacement-based nonlinear beam structural formulation coupled to a general extented lifting-line aerodynamic model to simulate the flight of aircraft with or without a user-defined control law. ASWING is licensed for commercial use.","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic understanding of the theory will help the user of this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"theory.md\"\n ]\n Depth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following examples are a useful starting point for those new to the package. They explain several of its functionalities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"literate/conventionalHALEmodel.md\",\n    \"literate/OMCgustTests.md\",\n    \"literate/typicalSectionFlutterAndDivergence.md\",\n    \"literate/archUnderFollowerPressure.md\",\n    \"literate/compositeCantileverMD.md\",\n    \"literate/PazyWingTorsionTest.md\",\n    \"literate/PazyWingPitchRange.md\",\n    \"literate/PazyWingFlutterPitchRange.md\",\n    \"literate/sweptTipRotor.md\",\n    \"literate/twoStoryFrame.md\",\n    \"literate/initialDispAndVelBeam.md\",\n    \"literate/flyingScissors.md\",\n    \"literate/heliosTrim.md\",\n    \"literate/BWBflutter.md\",\n    \"literate/conventionalHALECheckedPitchManeuver.md\",\n    \"literate/conventionalHALECheckedRollManeuver.md\",\n]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Hodges, D. H. \"Nonlinear Composite Beam Theory\". 2006. American Institute of Aeronautics and Astronautics. 10.2514/4.866821","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Hodges, D. H., Shang, X. and Cesnik, C. E. S. \"Finite element solution of nonlinear intrinsic equations for curved composite beams\". 1996. Journal of the American Helicopter Society. 10.2514/6.1995-1174","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Yu, W. and Blair, M. \"GEBT: A general-purpose nonlinear analysis tool for composite beams\". 2012. Composite Structures. 10.1016/j.compstruct.2012.04.007","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Wang, Q. and Yu, W. \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\". 2017. Journal of Renewable and Sustainable Energy. 10.1063/1.4985091","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Leishman, J. G. \"Principles of Helicopter Aerodynamics\". 2006. Cambridge University Press.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6]: Peters, D. A., Karunamoorthy, S. and Cao, W. \"Finite state induced flow models. I: Two-dimensional thin airfoil\". 1995. Journal of Aircraft. 10.2514/3.46718","category":"page"},{"location":"","page":"Home","title":"Home","text":"[7]: Leishman, J. G. and Beddoes, T. S. \"A Semi‐Empirical Model for Dynamic Stall\". 1989. Journal of the American Helicopter Society. 10.4050/JAHS.34.3.3","category":"page"},{"location":"","page":"Home","title":"Home","text":"[8]: dos Santos, L. G. P. and Marques, F. D. \"Improvements on the Beddoes-Leishman dynamic stall model for low speed applications\". 2021. Journal of Fluids and Structures. 10.1016/j.jfluidstructs.2021.103375","category":"page"},{"location":"","page":"Home","title":"Home","text":"[9]: J. C. Simo and L. Vu-Quoc. \"On the Dynamics of Flexible Beams Under Large Overall Motions—The Plane Case: Part II\". 1986. Journal of Applied Mechanics. 10.1115/1.3171871","category":"page"},{"location":"","page":"Home","title":"Home","text":"[10]: Su, W and Cesnik, C. E. S. \"Strain-based geometrically nonlinear beam formulation for modeling very flexible aircraft\". 2011. International Journal of Solids and Structures. 10.1016/j.ijsolstr.2011.04.012","category":"page"}]
}
