var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"CurrentModule = AeroBeams","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/","page":"References","title":"References","text":"Modules = [AeroBeams]","category":"page"},{"location":"references/#AeroBeams.AeroBeams","page":"References","title":"AeroBeams.AeroBeams","text":"Module for the AeroBeams package\n\n\n\n\n\n","category":"module"},{"location":"references/#AeroBeams.I3","page":"References","title":"AeroBeams.I3","text":"I3 = Matrix(1.0*LinearAlgebra.I,3,3)\n\n3x3 identity matrix\n\n\n\n\n\n","category":"constant"},{"location":"references/#AeroBeams.I6","page":"References","title":"AeroBeams.I6","text":"I6 = Matrix(1.0*LinearAlgebra.I,6,6)\n\n6x6 identity matrix\n\n\n\n\n\n","category":"constant"},{"location":"references/#AeroBeams.a1","page":"References","title":"AeroBeams.a1","text":"const a1 = [1.0; 0.0; 0.0]\n\nFirst vector of basis A, resolved in that basis\n\n\n\n\n\n","category":"constant"},{"location":"references/#AeroBeams.BC","page":"References","title":"AeroBeams.BC","text":"@with_kw mutable struct BC\n\nBoundary conditions composite type\n\nFields\n\nname::String = name of the BC\nbeam::Beam = beam at which the BC is applied\nnode::Int64 = node of the beam at which the BC is applied\ntypes::Vector{String} = types of BCs applied to the node (generalized forces and displacements)\nvalues::Vector{Union{<:Number,<:Function}} = corresponding values of the applied BCs (constants or functions of time)\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.Beam","page":"References","title":"AeroBeams.Beam","text":"@with_kw mutable struct Beam\n\nBeam composite type\n\nFields\n\nname::String = name of the beam\nconnectedNodesThis::Int64 = which node is connected to another beam\nconnectedBeams::Union{Nothing, Beam} = to which beam the current beam is connected\nconnectedNodesOther::Int64 = to which node of the other beam it is connected\nlength::Float64 = total arclength of the beam\nrotationParametrization::String = rotation parametrization for the undeformed geometry definition\np0::Vector{Float64} = corresponding rotation parameters\nk::Vector{Float64} = initial curvatures of the beam in the undeformed geometry (torsional, flapwise bending, in-plane bending)\nnElements::Int64 = number of elements\nnormalizedNodalPositions::Vector{Float64} = nodal positions normalized by the length\nelementRange::Vector{Int64} = current beam's range of elements in the model\nconstitutiveRelation::{String} = constitutive relation of the material\nC::Matrix{Float64} = sectional stiffness matrix\nI::Matrix{Float64} = sectional inertia matrix\n\nNotes\n\nSome fields have meaningful default values, others need inputs\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.ComplementaryElementalStates","page":"References","title":"AeroBeams.ComplementaryElementalStates","text":"mutable struct ComplementaryElementalStates\n\nComplementaryElementalStates composite type\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.ComplementaryElementalStatesRates","page":"References","title":"AeroBeams.ComplementaryElementalStatesRates","text":"mutable struct ComplementaryElementalStatesRates\n\nComplementaryElementalStatesRates composite type\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.DynamicProblem","page":"References","title":"AeroBeams.DynamicProblem","text":"@with_kw mutable struct DynamicProblem <: Problem\n\nDynamicProblem composite type\n\nDefines the problem of dynamic type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.EigenProblem","page":"References","title":"AeroBeams.EigenProblem","text":"@with_kw mutable struct EigenProblem <: Problem\n\nEigenProblem composite type\n\nDefines the problem of eigen type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.Element","page":"References","title":"AeroBeams.Element","text":"mutable struct Element <: BeamElement\n\nElement composite type\n\nFields\n\nparent::Beam\nlocalID::Int64\n\nNotes\n\nFinite elements belong to a Beam\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.ElementalStates","page":"References","title":"AeroBeams.ElementalStates","text":"mutable struct ElementalStates\n\nElementalStates composite type\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.ElementalStatesRates","page":"References","title":"AeroBeams.ElementalStatesRates","text":"mutable struct ElementalStatesRates\n\nElementalStatesRates composite type\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.InitialVelocitiesUpdateOptions","page":"References","title":"AeroBeams.InitialVelocitiesUpdateOptions","text":"@with_kw mutable struct InitialVelocitiesUpdateOptions\n\nInitialVelocitiesUpdateOptions composite type\n\nDefines variables for the update of the initial velocities states\n\nFields\n\nΔt::Number \nmaxIter::Int64 \nrelaxFactor::Float64 \ntol::Float64\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.ModeShape","page":"References","title":"AeroBeams.ModeShape","text":"mutable struct ModeShape{T<:Union{Float64,ComplexF64}}\n\nModeShape composite type\n\nFields\n\nmode::Int64\nfrequency::Float64\ndamping::Float64\nelementalStates::Vector{ElementalStates{T}}\ncomplementaryElementalStates::Vector{ComplementaryElementalStates{T}}\nnodalStates::Vector{NodalStates{T}}\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.Model","page":"References","title":"AeroBeams.Model","text":"@with_kw mutable struct Model\n\nModel composite type\n\nFields\n\nname::String = name of the model\nunits::UnitSystem = unit system (length, force, angle and frequency) \nbeams::Vector{Beam} = beams that compose the model's assembly\ninitialPosition::Vector{<:Number} = initial position of the first node of the first beam of the model, defined in basis A \ngravityVector::Vector{<:Number} = gravity vector, defined in the I (inertial) frame\nBCs::Dict{Int64,Int64} = boundary conditions applied to the model\nnElementsTotal::Int64 = total number of elements of the beam's assembly\nnNodesTotal::Int64 = total number of nodes of the beam's assembly\nelementNodes::Vector{Vector{Int64}} = a nElementsTotal x 2 matrix in which the row represents the element, and the columns are the corresponding element's nodes\np_A0::Vector{Float64} = initial Euler 3-2-1 rotation parameters that bring basis I to basis A\nR_A::Matrix{Float64}= 1.0I(3) = initial rotation tensor that brings basis I to basis A, resolved in basis A\nnTrimVariables::Int64 = number of trim variables\ntrimLoadsLinks::Vector{TrimLoadsLink} = trim links among loads\n\nNotes\n\nThe default is an empty model\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.NewtonRaphson","page":"References","title":"AeroBeams.NewtonRaphson","text":"@with_kw mutable struct NewtonRaphson <: SystemSolver\n\nNewton-Raphson system solver composite type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.NodalStates","page":"References","title":"AeroBeams.NodalStates","text":"mutable struct NodalStates\n\nNodalStates composite type\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.PointInertia","page":"References","title":"AeroBeams.PointInertia","text":"@with_kw mutable struct PointInertia\n\nPointInertia composite type\n\nFields\n\nelementID::Int64\nmass::Number \nη::Vector{Number} = position relative to element's midpoint\nIxx::Number \nIyy::Number \nIzz::Number \nIxy::Number \nIxz::Number \nIyz::Number \ninertiaMatrix::Union{Matrix{Number},Matrix{Nothing}} \n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.Problem","page":"References","title":"AeroBeams.Problem","text":"abstract type Problem\n\nDefines a general Problem type\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.SpecialNode","page":"References","title":"AeroBeams.SpecialNode","text":"@with_kw mutable struct SpecialNode\n\nSpecial node composite type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.SteadyProblem","page":"References","title":"AeroBeams.SteadyProblem","text":"@with_kw mutable struct SteadyProblem <: Problem\n\nSteadyProblem composite type\n\nDefines the problem of steady type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.SystemSolver","page":"References","title":"AeroBeams.SystemSolver","text":"abstract type SystemSolver\n\nDefines a general problem for the system of equations\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.TrimLoadsLink","page":"References","title":"AeroBeams.TrimLoadsLink","text":"@with_kw mutable struct TrimLoadsLink\n\nTrimLoadsLink composite type\n\nFields\n\nmasterBC::BC\nslaveBCs::Vector{BC}\nmasterBeam::Beam\nmasterNodeLocalID::Int64\nslaveBeams::Vector{Beam}\nslaveNodesLocalIDs::Vector{Int64}\nmasterNodeGlobalID::Int64\nslaveNodesGlobalIDs::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.TrimProblem","page":"References","title":"AeroBeams.TrimProblem","text":"@with_kw mutable struct TrimProblem <: Problem\n\nTrimProblem composite type\n\nDefines the problem of trim type\n\nFields\n\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.UnitSystem","page":"References","title":"AeroBeams.UnitSystem","text":"@with_kw mutable struct UnitSystem \n\nA composite type with fields for length, force, angle and frequency units (this is only for plotting purposes and does not influence calculations)\n\nFields:\n\nlength::String\nforce::String\nangle::String\nfrequency::String\n\n\n\n\n\n","category":"type"},{"location":"references/#AeroBeams.add_initial_displacements_and_velocities_to_beam!-Tuple{Beam}","page":"References","title":"AeroBeams.add_initial_displacements_and_velocities_to_beam!","text":"addinitialdisplacementsandvelocitiestobeam!(beam::Beam,conditionTypes::Vector{String},conditionFuns::Vector{<:Function})\n\nAdds initial generalized displacements and velocities to the beam\n\nArguments\n\nbeam::Beam\nconditionTypes::Vector{String}\nconditionFuns::Vector{<:Function}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.add_loads_to_beam!-Tuple{Beam}","page":"References","title":"AeroBeams.add_loads_to_beam!","text":"addloadsto_beam!(;beam::Beam,loadTypes::Vector{String},loadFuns::Vector{<:Function})\n\nAdds loads to the beam\n\nArguments\n\nbeam::Beam\nloadTypes::Vector{String}\nloadFuns::Vector{<:Function}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.add_point_inertia_to_element!-Tuple{AeroBeams.Element, PointInertia}","page":"References","title":"AeroBeams.add_point_inertia_to_element!","text":"addpointinertiatoelement!(element::Element,pointInertia::PointInertia)\n\nAdds the point inertia's matrix to the element's sectional inertia matrix\n\nArguments\n\nelement::Element\npointInertia::PointInertia\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.add_point_inertias_to_beam!-Tuple{Beam}","page":"References","title":"AeroBeams.add_point_inertias_to_beam!","text":"addpointinertiastobeam!(;beam::Beam,inertias::Vector{PointInertia})\n\nAdds point inertias to the beam\n\nArguments\n\nbeam::Beam\ninertias::Vector{PointInertia}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.assemble_model!-Tuple{Model, Vector{Beam}}","page":"References","title":"AeroBeams.assemble_model!","text":"assemble_model!(model::Model,beams::Vector{Beam})\n\nLoads the assembly of beams into the model\n\nArguments\n\nmodel::Model = model at hand\nbeams::Vector{Beam} = beams to load into the model\n\nNotes\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.assemble_system_arrays!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.assemble_system_arrays!","text":"assemblesystemarrays!(problem::Problem)\n\nAssembles the residual vector, Jacobian and inertia matrices of the system of equations\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.copy_initial_states!-Tuple{AeroBeams.Problem, AeroBeams.Problem}","page":"References","title":"AeroBeams.copy_initial_states!","text":"copyinitialstates!(problem::Problem,problemCopy::Problem)\n\nCopies the initial states to the original problem\n\nArguments\n\nproblem::Problem\nproblemCopy::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.create_beam_elements!-Tuple{Beam}","page":"References","title":"AeroBeams.create_beam_elements!","text":"createbeamelements!(beam::Beam)\n\nInitializes the element and node ranges, and creates beam elements\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.curvature_quantities-Tuple{Vector{Float64}}","page":"References","title":"AeroBeams.curvature_quantities","text":"curvature_quantities(k::Vector{Float64})\n\nGets some useful functions of the curvature vector\n\nArguments\n\nk::Vector{Float64} = curvature vector\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.distributed_external_loads-Tuple{AeroBeams.Problem, AeroBeams.Element, Float64}","page":"References","title":"AeroBeams.distributed_external_loads","text":"distributedexternalloads(problem::Problem,element::Element,σ::Float64)\n\nComputes the nodal resultants from the externally applied distributed loads on the current element\n\nArguments\n\nmodel::Model\nelement::Element\nσ::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.distributed_external_loads_Jacobians-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.distributed_external_loads_Jacobians","text":"distributedexternalloads_Jacobians(element::Element)\n\nComputes the contributions of the externally applied distributed loads to the Jacobian matrix\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.distributed_loads_Jacobians!-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.distributed_loads_Jacobians!","text":"distributedloadsJacobians!(element::Element)\n\nComputes the contributions of the distributed loads to the Jacobian matrix\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.divide_inplace-Tuple{Number, Vararg{Any}}","page":"References","title":"AeroBeams.divide_inplace","text":"divide_inplace(divisor::Number, vars...)\n\nDivides the input variables in-place\n\nArguments\n\ndivisor::Number = divisor\nvars... = variables to be divided\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_accelerations_basis_b!","page":"References","title":"AeroBeams.element_accelerations_basis_b!","text":"elementaccelerationsbasis_b!(model::Model,element::Element,σ::Float64=1.0,timeNow::Float64=0.0)\n\nGets the generalized accelerations of basis b at the element's midpoint, resolved in basis A\n\nArguments\n\nmodel::Model\nelement::Element\nσ::Float64 = load factor\ntimeNow::Float64 = current time\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.element_arrays!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_arrays!","text":"element_arrays!(problem::Problem,model::Model,element::Element)\n\nGets the elemental contributions to the system's arrays (residual, Jacobian, inertia)\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_distributed_loads!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_distributed_loads!","text":"elementdistributedloads!(problem::Problem,model::Model,element::Element)\n\nGets the nodal resultants from distributed loads on the current element, resolved in basis A\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_inertia!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_inertia!","text":"element_inertia!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the inertia matrix\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_jacobian!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_jacobian!","text":"element_jacobian!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the Jacobian matrix\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_modal_states-Union{Tuple{T}, Tuple{AeroBeams.Element, Vector{T}, Float64}} where T<:Union{Float64, ComplexF64}","page":"References","title":"AeroBeams.element_modal_states","text":"elementmodalstates(element::Element,eigenvector::Vector{T},forceScaling::Float64)\n\nGets the modal states (generalized displacements, forces, strains, velocities and momenta) of the element at midpoint and at the nodes\n\nArguments\n\nelement::Element\neigenvector::Vector{T}\nforceScaling::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_momenta!-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.element_momenta!","text":"element_momenta!(element::Element)\n\nComputes the momenta for the current element, resolved in basis B\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_momenta_rates!-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.element_momenta_rates!","text":"elementmomentarates!(element::Element)\n\nComputes the momenta rates for the current element, resolved in basis B\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_nodal_states!-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.element_nodal_states!","text":"elementnodalstates!(element::Element)\n\nUpdates the nodal states of the element\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_residual!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_residual!","text":"element_residual!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the residual array\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_rotation_variables!-Tuple{AeroBeams.Problem, AeroBeams.Element}","page":"References","title":"AeroBeams.element_rotation_variables!","text":"elementrotationvariables!(problem::Problem,element::Element)\n\nGets the rotation variables for the current element\n\nArguments\n\nproblem::Problem\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_states!-Tuple{AeroBeams.Problem, Model, AeroBeams.Element}","page":"References","title":"AeroBeams.element_states!","text":"element_states!(problem::Problem,model::Model,element::Element)\n\nGets the states (generalized displacements, forces and velocities) of the element\n\nArguments\n\nproblem::Problem\nmodel::Model\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_states_rates!-Tuple{AeroBeams.Problem, AeroBeams.Element}","page":"References","title":"AeroBeams.element_states_rates!","text":"elementstatesrates!(problem::Problem,element::Element)\n\nGets the states' rates of the current element\n\nArguments\n\nproblem::Problem\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_strains!-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.element_strains!","text":"element_strains!(element::Element)\n\nComputes the strains for the current element, resolved in basis B\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.element_velocities_basis_b!","page":"References","title":"AeroBeams.element_velocities_basis_b!","text":"elementvelocitiesbasis_b!(model::Model,element::Element,σ::Float64=1.0,timeNow::Float64=0.0)\n\nGets the generalized velocities of basis b at the element's midpoint, resolved in basis A\n\nArguments\n\nmodel::Model\nelement::Element\nσ::Float64 = load factor\ntimeNow::Float64 = current time\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.force_scaling-Tuple{Vector{Matrix{Float64}}}","page":"References","title":"AeroBeams.force_scaling","text":"force_scaling(S::Vector{Matrix{Float64}})\n\nGets the appropriate force scaling for the linear system of equations\n\nArguments\n\nS::Vector{Matrix{Float64}} = array of elemental sectional compliance matrices\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_element_distributed_loads-Tuple{Beam, Float64, Float64}","page":"References","title":"AeroBeams.get_element_distributed_loads","text":"getelementdistributedloads(parent::Beam,Δℓ::Float64,x1n1::Float64)\n\nGets the distributed loads in the element's local coordinate\n\nArguments\n\nparent::Beam\nΔℓ::Float64\nx1_n1::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_equivalent_states_rates!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.get_equivalent_states_rates!","text":"getequivalentstates_rates!(problem::Problem)\n\nGets the equivalent states' rates at the begin of the current time step \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_hinged_nodes_matrices-Tuple{Beam, Vector{Int64}}","page":"References","title":"AeroBeams.get_hinged_nodes_matrices","text":"gethingednodes_matrices(parent::Beam,nodesLocalID::Vector{Int64})\n\nGets the TF matrices resulting from hinged and not hinged nodal DoFs times the identity matrix\n\nArguments\n\nparent::Beam\nnodesLocalID::Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_initial_displacements_derivatives!-Tuple{Beam}","page":"References","title":"AeroBeams.get_initial_displacements_derivatives!","text":"getinitialdisplacements_derivatives!(beam::Beam)\n\nGets the derivatives of the initial generalized displacements\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_mode_shapes!-Union{Tuple{T}, Tuple{AeroBeams.Problem, Matrix{T}, Vector{Float64}, Vector{Float64}}} where T<:Union{Float64, ComplexF64}","page":"References","title":"AeroBeams.get_mode_shapes!","text":"getmodeshapes!(problem::Problem,eigenvectorsOscillatory::Matrix{T},frequenciesOscillatory::Vector{Float64},dampingsOscillatory::Vector{Float64})\n\nGets the mode shapes given by the eigenvectors\n\nArguments\n\nproblem::Problem\neigenvectorsOscillatory::Matrix{T}\nfrequenciesOscillatory::Vector{Float64}\ndampingsOscillatory::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_rotation_tensors!-Tuple{Beam}","page":"References","title":"AeroBeams.get_rotation_tensors!","text":"getrotationtensors!(beam::Beam)\n\nValidates the input rotation parameters and rotation parametrization, and gets the corresponding rotation tensors from basis A to basis b and of the cross-section\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_special_nodes!-Tuple{Model}","page":"References","title":"AeroBeams.get_special_nodes!","text":"getspecialnodes!(model::Model)\n\nGets the special nodes in the system of equations: connection, boundary, and BC'ed nodes\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_system_indices!-Tuple{Model}","page":"References","title":"AeroBeams.get_system_indices!","text":"getsystemindices!(model::Model)\n\nGets the indices (for equations and DOFs) of the system of equations\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.get_velocity_dofs_to_update!-Tuple{Beam}","page":"References","title":"AeroBeams.get_velocity_dofs_to_update!","text":"getvelocitydofstoupdate!(beam::Beam)\n\nGets the velocity DOFs (V and Ω) to be updated on the initial dynamic solution\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.gravitational_loads-Tuple{Model, AeroBeams.Element, Float64}","page":"References","title":"AeroBeams.gravitational_loads","text":"gravitational_loads(model::Model,element::Element,σ::Float64)\n\nComputes the nodal resultants from the distributed gravitational loads on the current element\n\nArguments\n\nmodel::Model\nelement::Element\nσ::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.gravitational_loads_Jacobians-Tuple{AeroBeams.Element}","page":"References","title":"AeroBeams.gravitational_loads_Jacobians","text":"gravitationalloadsJacobians(element::Element)\n\nComputes the contributions of the gravitational loads to the Jacobian matrix\n\nArguments\n\nelement::Element\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.initialize_basis_A_rotation!-Tuple{Model}","page":"References","title":"AeroBeams.initialize_basis_A_rotation!","text":"initializebasisA_rotation!(model::Model)\n\nInitializes the rotation tensor from basis I (fixed, inertial) to basis A, and its transpose\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.initialize_system_arrays!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.initialize_system_arrays!","text":"initializesystemarrays!(problem::Problem)\n\nInitializes the system arrays to the correct size\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.initialize_time_variables!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.initialize_time_variables!","text":"initializetimevariables!(problem::Problem)\n\nValidates and initializes the time variables\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.interpolate_distributed_loads-Tuple{AeroBeams.Problem, Array{Float64}}","page":"References","title":"AeroBeams.interpolate_distributed_loads","text":"interpolatedistributedloads(problem::Problem,loadArray::Array{Float64})\n\nInterpolates the loads array at the current time\n\nArguments\n\nproblem::Problem\nloadArray::Array{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.mul3-Tuple{Matrix{<:Number}, Matrix{<:Number}, Matrix{<:Number}, Vector{<:Number}}","page":"References","title":"AeroBeams.mul3","text":"mul3(A1::Matrix{<:Number},A2::Matrix{<:Number},A3::Matrix{<:Number},b::Vector{<:Number})\n\nGets the scalar product of a third-order tensor represented by matrices A1, A2, and A3 with the vector b\n\nArguments\n\nA1::Matrix{<:Number}\nA2::Matrix{<:Number}\nA3::Matrix{<:Number}\nb::Vector{<:Number}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.plot_undeformed_assembly","page":"References","title":"AeroBeams.plot_undeformed_assembly","text":"plotundeformedassembly(model::Model)\n\nPlots the nodal coordinates of the assembly of beams\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.position_vector_from_curvature-Tuple{Matrix{Float64}, Vector{Float64}, Float64}","page":"References","title":"AeroBeams.position_vector_from_curvature","text":"positionvectorfrom_curvature(R0::Matrix{Float64}, k::Vector{Float64}, x1::Float64)\n\nGets the position vector at an arclength value\n\nArguments\n\nR0::Matrix{Float64} = initial rotation tensor (at arclength position zero)\nk::Vector{Float64} = curvature vector\nx1::Float64 = arclength position\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.precompute_distributed_loads!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.precompute_distributed_loads!","text":"precomputedistributedloads!(problem::Problem)\n\nPre-computes the distributed loads over all elements' nodes, over every time step\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.quaternion_from_rotation_tensor-Tuple{Matrix{<:Number}}","page":"References","title":"AeroBeams.quaternion_from_rotation_tensor","text":"quaternionfromrotation_tensor(R::Matrix{<:Number})\n\nComputes the quaternion (Euler parameters) given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_angle-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.rotation_angle","text":"rotation_angle(p::Vector{<:Union{Float64,ComplexF64}})\n\nGets the rotation angle\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_parameter_scaling-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.rotation_parameter_scaling","text":"rotationparameterscaling(p::Vector{<:Union{Float64,ComplexF64}})\n\nScales the Wiener-Milenkovic rotation parameters\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = unscaled rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_parameters_WM-Tuple{Matrix{<:Number}}","page":"References","title":"AeroBeams.rotation_parameters_WM","text":"rotationparametersWM(R::Matrix{<:Number})\n\nComputes the Wiener-Milenkovic rotation parameters given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_E313-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.rotation_tensor_E313","text":"rotationtensorE321(p::::Vector{<:Union{Float64,ComplexF64}})\n\nGets the rotation tensor according to Euler parameters sequence 3-1-3\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_E321-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.rotation_tensor_E321","text":"rotationtensorE321(p::Vector{<:Union{Float64,ComplexF64}})\n\nGets the rotation tensor according to Euler parameters sequence 3-2-1\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_WM-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.rotation_tensor_WM","text":"rotationtensorWM(p::Vector{<:Union{Float64,ComplexF64}})\n\nGets the rotation tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_derivatives_extended_parameters-NTuple{17, Any}","page":"References","title":"AeroBeams.rotation_tensor_derivatives_extended_parameters","text":"rotationtensorderivativesextendedparameters(p,pNorm,λ,ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²)\n\nGets the derivatives of the rotation tensor with respect to the extended rotation parameters\n\nArguments\n\np,pNorm,λ,ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_derivatives_extended_parameters-Tuple{Vector{Float64}}","page":"References","title":"AeroBeams.rotation_tensor_derivatives_extended_parameters","text":"rotationtensorderivativesextendedparameters(p::Vector{Float64})\n\nGets the derivatives of the rotation tensor with respect to the extended rotation parameters\n\nArguments\n\np::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_derivatives_scaled_parameters-NTuple{14, Any}","page":"References","title":"AeroBeams.rotation_tensor_derivatives_scaled_parameters","text":"rotationtensorderivativesscaledparameters(ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²)\n\nGets the derivatives of the rotation tensor with respect to the scaled rotation parameters\n\nArguments\n\nps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_derivatives_time_extended_parameters-NTuple{32, Any}","page":"References","title":"AeroBeams.rotation_tensor_derivatives_time_extended_parameters","text":"rotationtensorderivativestimeextendedparameters(ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,Θps1,Θps2,Θps3,υ,υ²,υ²ps1,υ²ps2,υ²ps3,ps1dot,ps2dot,ps3dot,ps1p1,ps2p1,ps3p1,ps1p2,ps2p2,ps3p2,ps1p3,ps2p3,ps3p3)\n\nGets the derivatives of the time derivative of the rotation tensor with respect to the extended rotation parameters \n\nArguments\n\nps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,Θps1,Θps2,Θps3,υ,υ²,υ²ps1,υ²ps2,υ²ps3,ps1dot,ps2dot,ps3dot,ps1p1,ps2p1,ps3p1,ps1p2,ps2p2,ps3p2,ps1p3,ps2p3,ps3_p3\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_from_curvature-Tuple{Matrix{Float64}, Vector{Float64}, Float64}","page":"References","title":"AeroBeams.rotation_tensor_from_curvature","text":"rotationtensorfrom_curvature(R0::Matrix{Float64}, k::Vector{Float64}, x1::Float64)\n\nGets the rotation tensor at an arclength position \n\nArguments\n\nR0::Matrix{Float64} = initial rotation tensor (at arclength position zero)\nk::Vector{Float64} = curvature vector\nx1::Float64 = arclength position\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_time_derivative-NTuple{5, Any}","page":"References","title":"AeroBeams.rotation_tensor_time_derivative","text":"rotationtensortimederivative(Rps1,Rps2,Rps3,ps_p,pdot)\n\nGets the time derivative of the rotation tensor \n\nArguments\n\nRps1,Rps2,Rps3,psp,pdot\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.rotation_tensor_time_derivative-Tuple{Vector{Float64}, Vector{Float64}}","page":"References","title":"AeroBeams.rotation_tensor_time_derivative","text":"rotationtensortime_derivative(p::Vector{Float64},pdot::Vector{Float64})\n\nGets the derivatives of the time derivative of the rotation tensor, given the rotation parameters and their rates \n\nArguments\n\np::Vector{Float64}\npdot::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.round_off!","page":"References","title":"AeroBeams.round_off!","text":"round_off!(x)\n\nRounds the array to input tolerance (defaults to machine epsilon)\n\nArguments\n\nx\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.save_load_factor_data!-Tuple{AeroBeams.Problem, Float64, Vector{Float64}}","page":"References","title":"AeroBeams.save_load_factor_data!","text":"saveloadfactor_data!(problem::Problem,σ::Float64,x::Vector{Float64})\n\nSaves the solution at the current load factor\n\nArguments\n\nproblem::Problem\nσ::Float64\nx::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.save_time_step_data!-Tuple{AeroBeams.Problem, Number}","page":"References","title":"AeroBeams.save_time_step_data!","text":"savetimestep_data!(problem::Problem,timeNow::Number)\n\nSaves the solution at the current time step\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.scaling_derivatives_extended_parameters-Tuple{Float64, Vector{Float64}, Float64}","page":"References","title":"AeroBeams.scaling_derivatives_extended_parameters","text":"scalingderivativesextended_parameters(λ::Float64,p::Vector{Float64},pNorm::Float64)\n\nGets the derivatives of the scaling factor with respect to the extended rotation parameters\n\nArguments\n\nλ::Float64 = scaling factor\np::Vector{Float64} = rotation parameters\npNorm::Float64 = norm of rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.set_BCs!-Tuple{Model, Vector{BC}}","page":"References","title":"AeroBeams.set_BCs!","text":"set_BCs!(model::Model)\n\nSets the BCs onto the model\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.set_initial_states!","page":"References","title":"AeroBeams.set_initial_states!","text":"setinitialstates!(problem::Problem,skipSizeAssertion::Bool=false)\n\nSets the initial elemental and nodal states into the states array\n\nArguments\n\nproblem::Problem\nskipSizeAssertion::Bool\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.set_nodal_coordinates!-Tuple{Beam}","page":"References","title":"AeroBeams.set_nodal_coordinates!","text":"setnodalcoordinates!(beam::Beam)\n\nSets the nodal coordinates of each element into the beam\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve!","text":"solve!(problem::Problem)\n\nSolves a problem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_NewtonRaphson!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_NewtonRaphson!","text":"solve_NewtonRaphson!(problem::Problem)\n\nSolves the nonlinear system of equations at current time step \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_dynamic!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_dynamic!","text":"solve_dynamic!(problem::Problem)\n\nSolves a dynamic problem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_eigen!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_eigen!","text":"solve_eigen!(problem::Problem)\n\nSolves an eigenproblem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_initial_dynamic!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_initial_dynamic!","text":"solveinitialdynamic!(problem::Problem)\n\nGets consistent initial conditions and solves the first time step\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_linear_system!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_linear_system!","text":"solvelinearsystem!(problem::Problem)\n\nSolves the linear system of equations at current time step and load factor\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_steady!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_steady!","text":"solve_steady!(problem::Problem)\n\nSolves a steady problem (includes trim and the steady part of eigen problems) \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.solve_time_step!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.solve_time_step!","text":"solvetimestep!(problem::Problem)\n\nSolves the current time step  \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.special_node_arrays!-Tuple{AeroBeams.Problem, Model, AeroBeams.SpecialNode}","page":"References","title":"AeroBeams.special_node_arrays!","text":"specialnodearrays!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nGets the nodal contributions to the system's arrays (residual, Jacobian, inertia)\n\nArguments\n\nproblem::Problem\nmodel::Model\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.special_node_follower_loads_jacobians!-Tuple{AeroBeams.Problem, AeroBeams.SpecialNode}","page":"References","title":"AeroBeams.special_node_follower_loads_jacobians!","text":"specialnodefollowerloadsjacobians!(problem::Problem,specialNode::SpecialNode)\n\nGets the contributions from the nodal follower loads to the Jacobian matrix\n\nArguments\n\nproblem::Problem\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.special_node_jacobian!-Tuple{AeroBeams.Problem, Model, AeroBeams.SpecialNode}","page":"References","title":"AeroBeams.special_node_jacobian!","text":"specialnodejacobian!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the contributions from the current node to the Jacobian matrix\n\nArguments\n\nproblem::Problem\nmodel::Model\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.special_node_residual!-Tuple{AeroBeams.Problem, Model, AeroBeams.SpecialNode}","page":"References","title":"AeroBeams.special_node_residual!","text":"specialnoderesidual!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the contributions from the current node to the residual array\n\nArguments\n\nproblem::Problem\nmodel::Model\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.special_node_states!-Tuple{AeroBeams.Problem, Model, AeroBeams.SpecialNode}","page":"References","title":"AeroBeams.special_node_states!","text":"specialnodestates!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nGets the nodal states\n\nArguments\n\nproblem::Problem\nmodel::Model\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_operator_transpose_WM-Tuple{Vector{Float64}, Float64, Float64}","page":"References","title":"AeroBeams.tangent_operator_transpose_WM","text":"tangentoperatortranspose_WM(ps::Vector{Float64},ps0::Float64,υ²::Float64)\n\nGets the transpose of tangent operator tensor according to Wiener-Milenkovic parameters\n\nArguments\n\nps::Vector{Float64} = scaled rotation parameters\nps0::Float64\nυ²::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_operator_transpose_WM-Tuple{Vector{Float64}}","page":"References","title":"AeroBeams.tangent_operator_transpose_WM","text":"tangentoperatortranspose_WM(p::Vector{Float64})\n\nGets the transpose of tangent operator tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{Float64} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_operator_transpose_inverse_WM-Tuple{Vector{<:Union{Float64, ComplexF64}}}","page":"References","title":"AeroBeams.tangent_operator_transpose_inverse_WM","text":"tangentoperatortransposeinverseWM(p::Vector{<:Union{Float64,ComplexF64}})\n\nGets the inverse of the transpose of the tangent operator tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{<:Union{Float64,ComplexF64}} = rotation parameters\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_operator_transpose_inverse_WM-Tuple{Vector{Float64}, Float64}","page":"References","title":"AeroBeams.tangent_operator_transpose_inverse_WM","text":"tangentoperatortransposeinverseWM(ps::Vector{Float64},ps0::Float64)\n\nGets the inverse of the transpose of the tangent operator tensor according to Wiener-Milenkovic parameters\n\nArguments\n\nps::Vector{Float64} = scaled rotation parameters\nps0::Float64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_tensor_functions_derivatives_extended_parameters-NTuple{9, Any}","page":"References","title":"AeroBeams.tangent_tensor_functions_derivatives_extended_parameters","text":"tangenttensorfunctionsderivativesextendedparameters(HT,ps1,ps2,ps3,υ²,υ²ps1,υ²ps2,υ²ps3,ps_p)\n\nGets the derivatives of the tangent tensor's transpose and its inverse with respect to the extended rotation parameters\n\nArguments\n\nHT,ps1,ps2,ps3,υ²,υ²ps1,υ²ps2,υ²ps3,psp\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tangent_tensor_transpose_derivatives_extended_parameters-Tuple{Vector{Float64}}","page":"References","title":"AeroBeams.tangent_tensor_transpose_derivatives_extended_parameters","text":"tangenttensortransposederivativesextended_parameters(p::Vector{Float64})\n\nGets the derivatives of the tangent tensor's transpose with respect to the extended rotation parameters\n\nArguments\n\np::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.tilde-Tuple{Vector{<:Number}}","page":"References","title":"AeroBeams.tilde","text":"tilde(v::Vector{<:Number})\n\nGets the skew-symmetric matrix associated with a vector\n\nArguments\n\nv::Vector{<:Number} = three-element vector\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.time_march!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.time_march!","text":"time_march!(problem::Problem)\n\nMarches the dynamic problem in time\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_BC_data!","page":"References","title":"AeroBeams.update_BC_data!","text":"updateBCdata!(bc::BC,timeNow::Float64=0.0)\n\nUpdates the boundary conditions at the current time\n\nArguments\n\nbc::BC\ntimeNow::Float64\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.update_basis_A_orientation!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.update_basis_A_orientation!","text":"updatebasisA_orientation!(problem::Problem)\n\nUpdates the orientation of the basis A for the next time step\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_beam!-Tuple{Beam}","page":"References","title":"AeroBeams.update_beam!","text":"update_beam!(beam::Beam)\n\nValidates and updates the beam construction\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_element_distributed_loads!-Tuple{AeroBeams.Element, String, Function}","page":"References","title":"AeroBeams.update_element_distributed_loads!","text":"updateelementdistributed_loads!(element::Element,loadType::String,loadFun::Function)\n\nUpdate the distributed loads in the element's local coordinate\n\nArguments\n\nelement::Element\nloadType::String\nloadFun::Function\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_initial_conditions!-Tuple{Model}","page":"References","title":"AeroBeams.update_initial_conditions!","text":"updateinitialconditions!(model::Model)\n\nUpdates the initial condition states on all elements of the assembly\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_initial_velocities!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.update_initial_velocities!","text":"updateinitialvelocities!(problem::Problem)\n\nUpdates the velocity states by running a very small time step\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_loads_trim_links_global_ids!-Tuple{Model}","page":"References","title":"AeroBeams.update_loads_trim_links_global_ids!","text":"updateloadstrimlinksglobal_ids!(model::Model)\n\nUpdates the nodes' global IDs of the loads trim links\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_model!-Tuple{Model}","page":"References","title":"AeroBeams.update_model!","text":"update_model!(model::Model)\n\nUpdates the model with its current settings\n\nArguments\n\nmodel::Model \n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_special_node_jacobian!","page":"References","title":"AeroBeams.update_special_node_jacobian!","text":"updatespecialnodejacobian!(jacobian,forceScaling,Fp,Mp,ζonElements,eqsFu,eqsFp,eqsFF,eqsFM,eqsFFsep,eqsFMsep,DOFuF,DOFpM,DOFtrimLoads,uIsPrescribed,pIsPrescribed,isLoad=trues(6),isTrim=falses(6))\n\nUpdates the Jacobian matrix with the contributions from the current BC (if any) on the current node \n\nArguments\n\nproblem::Problem\nmodel::Model\nspecialNode::SpecialNode\n\n\n\n\n\n","category":"function"},{"location":"references/#AeroBeams.update_states!-Tuple{AeroBeams.Problem}","page":"References","title":"AeroBeams.update_states!","text":"update_states!(problem::Problem)\n\nUpdates the elemental and nodal states\n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.update_time_variables!-Tuple{AeroBeams.Problem, Int64}","page":"References","title":"AeroBeams.update_time_variables!","text":"updatetimevariables!(problem::Problem,timeIndex::Int64)\n\nUpdates the time variables (time, time step, time indices)\n\nArguments\n\nproblem::Problem\ntimeIndex::Int64\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_and_update_motion_basis_A!-Tuple{Model}","page":"References","title":"AeroBeams.validate_and_update_motion_basis_A!","text":"validateandupdatemotionbasis_A!(model::Model)\n\nValidates and updates the motion variables of basis A\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_beam!-Tuple{Beam}","page":"References","title":"AeroBeams.validate_beam!","text":"validate_beam!(beam::Beam)\n\nValidates the beam inputs\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_connected_beams-Tuple{Beam}","page":"References","title":"AeroBeams.validate_connected_beams","text":"validateconnectedbeams(beam::Beam)\n\nChecks that the beam connections are consistent\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_distributed_loads!-Tuple{Beam}","page":"References","title":"AeroBeams.validate_distributed_loads!","text":"validatedistributedloads!(beam::Beam)\n\nValidates and updates the distributed loads\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_hinged_nodes!-Tuple{Beam}","page":"References","title":"AeroBeams.validate_hinged_nodes!","text":"validatehingednodes!(beam::Beam)\n\nValidates the hinged nodes and DoFs\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_initial_conditions!-Tuple{Beam}","page":"References","title":"AeroBeams.validate_initial_conditions!","text":"validateinitialconditions!(beam::Beam)\n\nValidate initial generalized displacements/velocities defined in basis b, and transform to function if input as constant vector\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_model!-Tuple{Model}","page":"References","title":"AeroBeams.validate_model!","text":"validate_model!(model::Model)\n\nValidates the inputs to the model\n\nArguments\n\nmodel::Model\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_normalized_nodal_positions!-Tuple{Beam}","page":"References","title":"AeroBeams.validate_normalized_nodal_positions!","text":"validatenormalizednodal_positions!(beam::Beam)\n\nValidates the normalized nodal positions if they were input, or updates them if they were not\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_rotation_parametrization-Tuple{Beam}","page":"References","title":"AeroBeams.validate_rotation_parametrization","text":"validaterotationparametrization(beam::Beam)\n\nValidates the input rotation parameters and rotation parametrization\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_sectional_matrices-Tuple{Beam}","page":"References","title":"AeroBeams.validate_sectional_matrices","text":"validatesectionalmatrices(beam::Beam)\n\nChecks that sectional matrices are input as a single one for the whole beam or are input in a per element basis \n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"method"},{"location":"references/#AeroBeams.validate_unit_system-Tuple{AeroBeams.UnitSystem}","page":"References","title":"AeroBeams.validate_unit_system","text":"validateunitsystem(units::UnitSystem)\n\nValidates the unit system\n\nFields:\n\nunits::UnitSystem\n\n\n\n\n\n","category":"method"},{"location":"#AeroBeams","page":"Home","title":"AeroBeams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AeroBeams.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add AeroBeams","category":"page"}]
}
