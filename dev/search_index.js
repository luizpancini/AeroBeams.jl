var documenterSearchIndex = {"docs":
[{"location":"publicAPI/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"publicAPI/#Creating-an-aerodynamic-derivatives-solver","page":"Public API","title":"Creating an aerodynamic derivatives solver","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"AD\nFD","category":"page"},{"location":"publicAPI/#AeroBeams.AD","page":"Public API","title":"AeroBeams.AD","text":"AD (Automatic Differentiation) DerivationMethod composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.FD","page":"Public API","title":"AeroBeams.FD","text":"FD (Finite Differences) DerivationMethod composite type\n\nFields\n\nmethod::FiniteDifferenceMethod\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-an-aerodynamic-solver","page":"Public API","title":"Creating an aerodynamic solver","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"QuasiSteady\nIndicial\nBLi\nBLo\nInflow\nTableLookup\nThinAirfoilTheory\nIndicialGust","category":"page"},{"location":"publicAPI/#AeroBeams.QuasiSteady","page":"Public API","title":"AeroBeams.QuasiSteady","text":"QuasiSteady AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.Indicial","page":"Public API","title":"AeroBeams.Indicial","text":"Indicial AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.BLi","page":"Public API","title":"AeroBeams.BLi","text":"Incompressible modified Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.BLo","page":"Public API","title":"AeroBeams.BLo","text":"Original Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.Inflow","page":"Public API","title":"AeroBeams.Inflow","text":"Inflow AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.TableLookup","page":"Public API","title":"AeroBeams.TableLookup","text":"TableLookup FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.ThinAirfoilTheory","page":"Public API","title":"AeroBeams.ThinAirfoilTheory","text":"ThinAirfoilTheory FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.IndicialGust","page":"Public API","title":"AeroBeams.IndicialGust","text":"IndicialGust GustAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-an-airfoil","page":"Public API","title":"Creating an airfoil","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_Airfoil\ncreate_flapped_Airfoil","category":"page"},{"location":"publicAPI/#AeroBeams.create_Airfoil","page":"Public API","title":"AeroBeams.create_Airfoil","text":"create_Airfoil(; kwargs...)\n\nAirfoil constructor\n\nArguments\n\nname::String = name of the airfoil\nRe::Number = Reynolds number\nMa::Number = Mach number\nU::Number = relative airspeed\nb::Number = semichord\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_flapped_Airfoil","page":"Public API","title":"AeroBeams.create_flapped_Airfoil","text":"create_flapped_Airfoil(;name::String,flapSiteID::Int64,Re::Number=0,Ma::Number=0)\n\nAirfoil constructor (with a trailing-edge flap) \n\nArguments\n\nname::String = name of the airfoil\nflapSiteID::Int64 = flap site ID\nRe::Number = Reynolds number\nMa::Number = Mach number\nU::Number = relative airspeed\nb::Number = semichord\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-an-aerodynamic-surface","page":"Public API","title":"Creating an aerodynamic surface","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_AeroSurface","category":"page"},{"location":"publicAPI/#AeroBeams.create_AeroSurface","page":"Public API","title":"AeroBeams.create_AeroSurface","text":"create_AeroSurface(; kwargs...)\n\nAerodynamic surface constructor\n\nKeyword arguments\n\nsolver::AeroSolver = aerodynamic solver for pitch-plunge-induced loads\nflapLoadsSolver::FlapAeroSolver = aerodynamic solver for flap-induced loads\ngustLoadsSolver::GustAeroSolver = aerodynamic solver for gust-induced loads\nderivationMethod::DerivationMethod = method for calculation of aerodynamic derivatives\nairfoil::Airfoil = airfoil section\nc::Union{<:Function,Number} = chord\nΛ::Union{<:Function,Number} = sweep angle\nnormSparPos::Union{<:Function,Float64} = normalized position of the spar (beam reference line) on the chord\nnormFlapSpan::Union{Nothing,Vector{<:Number}} = normalized position of the trailing-edge flap along the span (beam arclength)\nnormFlapPos::Union{Nothing,Float64} = normalized position of the trailing-edge flap hinge on the chord\nδIsTrimVariable::Bool = flag for trailing-edge deflection being a trim variable\nδ::Union{Nothing,<:Function,Number} = trailing-edge deflection [rad]\nflapSiteID::Union{Nothing,Int64} = trailing-edge flap site ID\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with local airspeed\nhasTipCorrection::Bool = flag to employ a tip correction on aerodynamic coefficients\ntipLossFunction::String = respective tip loss function\ntipLossDecayFactor::Float64 = respective tip loss factor\nsmallAngles::Bool = flag to employ small angles approximation on the calculation of the angle of attack\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-an-atmosphere","page":"Public API","title":"Creating an atmosphere","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"standard_atmosphere","category":"page"},{"location":"publicAPI/#AeroBeams.standard_atmosphere","page":"Public API","title":"AeroBeams.standard_atmosphere","text":"standard_atmosphere(altitude::Number)\n\nAtmosphere constructor based on the International Standard Atmosphere (https://en.wikipedia.org/wiki/InternationalStandardAtmosphere)\n\nArguments\n\naltitude::Number\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-boundary-conditions","page":"Public API","title":"Creating boundary conditions","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_BC","category":"page"},{"location":"publicAPI/#AeroBeams.create_BC","page":"Public API","title":"AeroBeams.create_BC","text":"create_BC(; kwargs...)\n\nBC constructor\n\nKeyword arguments\n\nname::String = name of the BC\nbeam::Beam = beam at which the BC is applied\nnode::Int64 = node of the beam at which the BC is applied\ntypes::Vector{String}= types of BCs applied to the node (generalized forces and displacements)\nvalues = corresponding values of the applied BCs (constants or functions of time)\ntoBeTrimmed::Union{BitVector,Vector{Bool}} = TF on whether the BC is to be trimmed\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-beam","page":"Public API","title":"Creating a beam","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_Beam\nupdate_beam!\nadd_point_inertias_to_beam!\nadd_loads_to_beam!\nadd_initial_displacements_and_velocities_to_beam!\nadd_springs_to_beam!\nadd_spring_to_beams!","category":"page"},{"location":"publicAPI/#AeroBeams.create_Beam","page":"Public API","title":"AeroBeams.create_Beam","text":"create_Beam(; kwargs...)\n\nBeam constructor\n\nKeyword Arguments\n\nname::String = name of the beam\nlength::Number = (arc)length of the beam\nrotationParametrization::String = type of rotation parametrization to define basis b\np0::Vector{<:Number} = rotation parameters from basis A to basis b\nk::Vector{<:Number} = undeformed beam's curvatures per unit length\ninitialPosition::Vector{<:Number} = initial position of the beam's first node relative to the beam's origin (which may be another beam's node)\nnElements::Int64 = number of elements for discretization\nnormalizedNodalPositions::Vector{Float64} = normalized nodal positions of beam elements\nC::Vector{<:Matrix{<:Number}} = array of sectional stiffness matrices\nI::Vector{<:Matrix{<:Number}} = array of sectional inertia matrices\nconnectedBeams::Union{Nothing,Vector{Beam}} = array of beams to which this beam is connected (a non-recursive property)\nconnectedNodesThis::Vector{Int64} = nodes of this beam which are connected to other beams' nodes (a non-recursive property)\nconnectedNodesOther::Vector{Int64} = respective nodes of the other beams (a non-recursive property)\npointInertias::Vector{PointInertia} = attached point inertias\nhingedNodes::Vector{Int64} = nodes with a hinge\nhingedNodesDoF::Union{Vector{Vector{Bool}},Vector{BitVector}} = respective hinged degrees-of-freedom\nu0_of_x1::Union{Vector{<:Number},<:Function,Nothing} = initial displacement (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\np0_of_x1::Union{Vector{<:Number},<:Function,Nothing} = initial rotation parameters (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\nudot0_of_x1::Union{Vector{<:Number},<:Function,Nothing} = initial displacement's rates (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\npdot0_of_x1::Union{Vector{<:Number},<:Function,Nothing} = initial rotation parameters' rates (resolved in the undeformed beam basis, b) of the beam as a function of its arclength coordinate (x1)\nf_A_of_x1t::Union{Nothing,<:Function} = distributed dead forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nm_A_of_x1t::Union{Nothing,<:Function} = distributed dead moments initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nf_b_of_x1t::Union{Nothing,<:Function} = distributed dead forces initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nm_b_of_x1t::Union{Nothing,<:Function} = distributed dead moments initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nff_A_of_x1t::Union{Nothing,<:Function} = distributed follower forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nmf_A_of_x1t::Union{Nothing,<:Function} = distributed moments forces initially resolved in basis A, as a function of the beam arclength coordinate (x1) and time (t)\nff_b_of_x1t::Union{Nothing,<:Function} = distributed follower forces initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\nmf_b_of_x1t::Union{Nothing,<:Function} = distributed follower moments initially resolved in basis b, as a function of the beam arclength coordinate (x1) and time (t)\naeroSurface::Union{Nothing,AeroSurface} = attached aerodynamic surface\nsprings::Vector{Spring} = array of attached springs\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.update_beam!","page":"Public API","title":"AeroBeams.update_beam!","text":"update_beam!(beam::Beam)\n\nValidates and updates the beam construction\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_point_inertias_to_beam!","page":"Public API","title":"AeroBeams.add_point_inertias_to_beam!","text":"add_point_inertias_to_beam!(beam::Beam; inertias::Vector{PointInertia})\n\nAdds point inertias to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\ninertias::Vector{PointInertia}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_loads_to_beam!","page":"Public API","title":"AeroBeams.add_loads_to_beam!","text":"add_loads_to_beam!(beam::Beam; loadTypes::Vector{String},loadFuns::Vector{<:Function})\n\nAdds loads to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nloadTypes::Vector{String}\nloadFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_initial_displacements_and_velocities_to_beam!","page":"Public API","title":"AeroBeams.add_initial_displacements_and_velocities_to_beam!","text":"add_initial_displacements_and_velocities_to_beam!(beam::Beam; conditionTypes::Vector{String},conditionFuns::Vector{<:Function})\n\nAdds initial generalized displacements and velocities to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nconditionTypes::Vector{String}\nconditionFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_springs_to_beam!","page":"Public API","title":"AeroBeams.add_springs_to_beam!","text":"add_springs_to_beam!(; beam::Beam,springs::Vector{Spring})\n\nAdds simply-attached springs to a beam\n\nKeyword arguments\n\nbeam::Beam\nsprings::Vector{Spring}\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.add_spring_to_beams!","page":"Public API","title":"AeroBeams.add_spring_to_beams!","text":"add_spring_to_beams!(; beams::Vector{Beam},spring::Spring)\n\nAdds a doubly-attached spring to the beams\n\nKeyword arguments\n\nbeams::Vector{Beam}\nspring::Spring\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-gust","page":"Public API","title":"Creating a gust","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_SharpEdgedGust\ncreate_OneMinusCosineGust\ncreate_Continuous1DGust\ncreate_DiscreteSpaceGust\ncreate_Continuous1DSpaceGust\ncreate_Continuous2DSpaceGust","category":"page"},{"location":"publicAPI/#AeroBeams.create_SharpEdgedGust","page":"Public API","title":"AeroBeams.create_SharpEdgedGust","text":"create_SharpEdgedGust(; kwargs...)\n\nCreates a sharp-edged gust\n\nKeyword arguments\n\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_OneMinusCosineGust","page":"Public API","title":"AeroBeams.create_OneMinusCosineGust","text":"create_OneMinusCosineGust(; kwargs...)\n\nCreates a one-minus-cosine gust\n\nKeyword arguments\n\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous1DGust","page":"Public API","title":"AeroBeams.create_Continuous1DGust","text":"create_Continuous1DGust(; kwargs...)\n\nCreates a continuous 1D gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\ngenerationMethod::String = method for generation of gust velocity (\"sinusoids\" or \"whiteNoise\")\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\ngenerationDuration::Number = duration of the gust considered for its generation\nL::Number = turbulence length scale [m]\nωmin::Number = minimum frequency of the PSD [rad/s]\nωmax::Number = maximum frequency of the PSD [rad/s]\nUref::Number = reference airspeed\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\nplotPSD::Bool = flag to plot the PSD\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_DiscreteSpaceGust","page":"Public API","title":"AeroBeams.create_DiscreteSpaceGust","text":"create_DiscreteSpaceGust(; kwargs...)\n\nCreates a discrete space gust\n\nKeyword arguments\n\ntype::String = type of gust\nlength::Number = length of the gust (in longitudinal direction)\nwidth::Number = width of the gust (in spanwise direction)\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous1DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous1DSpaceGust","text":"create_Continuous1DSpaceGust(; kwargs...)\n\nCreates a continuous 1D space gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\nlength::Number = length of the gust (in longitudinal direction)\nN::Int64 = number of nodes for length discretization\nL::Number = turbulence length scale\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Continuous2DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous2DSpaceGust","text":"create_Continuous2DSpaceGust(; kwargs...)\n\nCreates a continuous 2D space gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\nlength::Number = length of the gust (in longitudinal direction)\nwidth::Number = width of the gust (in lateral direction)\nNx::Int64 = number of nodes for length discretization\nNy::Int64 = number of nodes for width discretization\nL::Number = turbulence length scale\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-link","page":"Public API","title":"Creating a link","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_TrimLoadsLink\ncreate_FlapLink","category":"page"},{"location":"publicAPI/#AeroBeams.create_TrimLoadsLink","page":"Public API","title":"AeroBeams.create_TrimLoadsLink","text":"create_TrimLoadsLink(; masterBC::BC,slaveBCs::Vector{BC})\n\nTrim loads link constructor (a link between trim loads so that they are equal)\n\nKeyword arguments\n\nmasterBC::BC = master BC\nslaveBCs::Vector{BC} = slave BCs\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_FlapLink","page":"Public API","title":"AeroBeams.create_FlapLink","text":"create_FlapLink(; kwargs...)\n\nFlap link constructor (a link between flapped surfaces)\n\nKeyword arguments\n\nmasterBeam::Beam = beam of the master surface\nslaveBeams::Vector{Beam} = beams of the slave surfaces\nδMultipliers::Vector{<:Number} = multiplication factors of flap deflection in slave surfaces relative to the master surface\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-model","page":"Public API","title":"Creating a model","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_Model\nupdate_model!\nset_motion_basis_A!","category":"page"},{"location":"publicAPI/#AeroBeams.create_Model","page":"Public API","title":"AeroBeams.create_Model","text":"create_Model(; kwargs...)\n\nCreates a model\n\nKeyword arguments\n\nname::String = name of the model\nunits::create_UnitsSystem = units system\nbeams::Vector{Beam} = beams in the assembly\ninitialPosition::Vector{<:Number} = initial position vector of the first node of the first beam, resolved in the inertial frame I\ngravityVector::Vector{<:Number} = gravity vector\nBCs::Vector{BC} = boundary condtions\np_A0::Vector{Float64} = initial rotation parameters that bring basis I to basis A\nu_A::Union{Vector{<:Number},<:Function,Nothing} = displacement of basis A relative to basis I\nv_A::Union{Vector{<:Number},<:Function,Nothing} = velocity of basis A relative to basis I\nω_A::Union{Vector{<:Number},<:Function,Nothing} = angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Number},<:Function,Nothing} = acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Number},<:Function,Nothing} = angular acceleration of basis A relative to basis I\naltitude::Union{Nothing,Number} = altidude\natmosphere::Union{Nothing,Atmosphere} = atmosphere\ngust::Union{Nothing,Gust} = gust\ntrimLoadsLinks::Vector{TrimLoadsLink} = links between trim loads\nflapLinks::Vector{FlapLink} = links between flapped surfaces\nrotationConstraints::Vector{RotationConstraint} = rotation constraints\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.update_model!","page":"Public API","title":"AeroBeams.update_model!","text":"update_model!(model::Model)\n\nUpdates the model with its current settings\n\nArguments\n\nmodel::Model \n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.set_motion_basis_A!","page":"Public API","title":"AeroBeams.set_motion_basis_A!","text":"set_motion_basis_A!(; kwargs...)\n\nSets the motion of basis A into the model\n\nKeyword arguments\n\nmodel::Model = model\nu_A::Union{Vector{<:Number},<:Function,Nothing} = displacement of basis A relative to basis I\nv_A::Union{Vector{<:Number},<:Function,Nothing} = velocity of basis A relative to basis I\nω_A::Union{Vector{<:Number},<:Function,Nothing} = angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Number},<:Function,Nothing} = acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Number},<:Function,Nothing} = angular acceleration of basis A relative to basis I\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-point-inertia","page":"Public API","title":"Creating a point inertia","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"PointInertia","category":"page"},{"location":"publicAPI/#AeroBeams.PointInertia","page":"Public API","title":"AeroBeams.PointInertia","text":"PointInertia composite type\n\nFields\n\nelementID::Int64 = local element ID to which the point inertia is attached\nmass::Number = mass\nη::Vector{Number} = position relative to element's midpoint's reference line\nIxx::Number = mass moment of inertia about the x1-axis\nIyy::Number = mass moment of inertia about the x2-axis\nIzz::Number = mass moment of inertia about the x3-axis\nIxy::Number = mass product of inertia with respect to the x1-axis and x2-axis\nIxz::Number = mass product of inertia with respect to the x1-axis and x3-axis\nIyz::Number = mass product of inertia with respect to the x2-axis and x3-axis\ninertiaMatrix::Union{Matrix{Number},Matrix{Nothing}} = mass moment of inertia matrix (tensor)\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#Creating-and-solving-a-problem","page":"Public API","title":"Creating and solving a problem","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"InitialVelocitiesUpdateOptions\ncreate_SteadyProblem\ncreate_TrimProblem\ncreate_EigenProblem\ncreate_DynamicProblem\nsolve!\nsolve_eigen!","category":"page"},{"location":"publicAPI/#AeroBeams.InitialVelocitiesUpdateOptions","page":"Public API","title":"AeroBeams.InitialVelocitiesUpdateOptions","text":"InitialVelocitiesUpdateOptions composite type\n\nDefines variables for the update of the initial velocities states\n\nFields\n\nΔt::Number = time step\nmaxIter::Int64 = maximum number of iterations\nrelaxFactor::Float64 = relaxation factor\ntol::Float64 = convergence tolerance\ndisplayProgress::Bool = flag to display progress\n\n\n\n\n\n","category":"type"},{"location":"publicAPI/#AeroBeams.create_SteadyProblem","page":"Public API","title":"AeroBeams.create_SteadyProblem","text":"create_SteadyProblem(; kwargs...)\n\nSteady problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_TrimProblem","page":"Public API","title":"AeroBeams.create_TrimProblem","text":"create_TrimProblem(; kwargs...)\n\nTrim problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\ngetInertiaMatrix::Bool = flag to compute inertia matrix\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_EigenProblem","page":"Public API","title":"AeroBeams.create_EigenProblem","text":"create_EigenProblem(; kwargs...)\n\nEigen problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\nnModes::Int64=Inf64 = number of modes to be computed\nfrequencyFilterLimits::Vector{Float64} = limits of the frequency filter\nnormalizeModeShapes::Bool = flag to normalize mode shapes\nx0::Vector{Float64} = initial states\njacobian::SparseMatrixCSC{Float64,Int64} = Jacobian matrix\ninertia::SparseMatrixCSC{Float64,Int64} = inertia matrix\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_DynamicProblem","page":"Public API","title":"AeroBeams.create_DynamicProblem","text":"create_DynamicProblem(; kwargs...)\n\nDynamic problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\ninitialTime::Number = initial time\nΔt::Union{Nothing,Number} = time step\nfinalTime::Union{Nothing,Number} = final time\ntimeVector::Union{Nothing,Vector{Float64}} = time vector\nadaptableΔt::Bool = flag for adaptable time step\nminΔt::Union{Nothing,Number} = minimum time step (when adaptable)\nmaxΔt::Union{Nothing,Number} = maximum time step (when adaptable)\nδb::Float64 = discontinuities boundary convergence norm\nskipInitialStatesUpdate::Bool = flag to skip update of initial states\ninitialVelocitiesUpdateOptions::InitialVelocitiesUpdateOptions = options for the initial velocities update\ntrackingTimeSteps::Bool = flag to track time step solutions\ntrackingFrequency::Int64 = frequency of time steps in which to track solution\ndisplayProgress::Bool = flag to display progress\ndisplayFrequency::Int64 = frequency of time steps in which to display progress\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.solve!","page":"Public API","title":"AeroBeams.solve!","text":"solve!(problem::Problem)\n\nSolves a problem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.solve_eigen!","page":"Public API","title":"AeroBeams.solve_eigen!","text":"solve_eigen!(problem::Problem)\n\nSolves an eigenproblem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-rotation-constraint","page":"Public API","title":"Creating a rotation constraint","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_RotationConstraint","category":"page"},{"location":"publicAPI/#AeroBeams.create_RotationConstraint","page":"Public API","title":"AeroBeams.create_RotationConstraint","text":"create_RotationConstraint(; kwargs...)\n\nRotation constraint constructor\n\nKeyword arguments\n\nmasterBeam::Beam = master beam\nslaveBeam::Beam = slave beam\nmasterElementLocalID::Int64 = local ID of the master element\nslaveElementLocalID::Int64 = local ID of the slave element\nDOF::Int64 = constrained rotation degree-of-freedom\nvalue::Number = value of the slave DOF relative to the master DOF\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-sample-model","page":"Public API","title":"Creating a sample model","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"tip_loss_factor_Pazy\ngeometrical_properties_Pazy\ncreate_Pazy\ncreate_PazyFFWT\ncreate_SMW\ncreate_TDWing\ncreate_Helios\ncreate_conventional_HALE\ncreate_BWB","category":"page"},{"location":"publicAPI/#AeroBeams.tip_loss_factor_Pazy","page":"Public API","title":"AeroBeams.tip_loss_factor_Pazy","text":"tip_loss_factor_Pazy(θ::Number,U::Number)\n\nComputes the tip loss factor for the Pazy wing's tip correction function\n\nArguments\n\nθ::Number = root pitch angle, in degrees\nU::Number = airspeed\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.geometrical_properties_Pazy","page":"Public API","title":"AeroBeams.geometrical_properties_Pazy","text":"geometrical_properties_Pazy()\n\nReturns the fixed geometrical (and discretization) properties of the Pazy wing\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Pazy","page":"Public API","title":"AeroBeams.create_Pazy","text":"create_Pazy(; kwargs...)\n\nCreates the Pazy wing\n\nReturns the wing model and geometrical properties\n\nArguments\n\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with airspeed\nupright::Bool = flag to set the wing in the upright position\nairfoil::Airfoil = airfoil section\nθ::Real = pitch angle at the root [rad]\nΛ::Real = sweep angle [rad]\nwithTipCorrection::Bool = flag for aerodynamic tip correction \nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\naltitude::Real = altitude\ng::Real = acceleration of gravity\nairspeed::Real = airspeed\ntipMass::Real = mass of a point inertia added to the tip of the wing\nξtipMass::Vector{<:Real} = position vector of the tip mass relative to the tip of the spar, resolved in the local basis\ntipMassInertia::Matrix{<:Real} = mass moment of inertia matrix of the tip mass\nadditionalBCs::Vector{BC} = additional BCs (beyond the clamp)\ngust::Union{Nothing,Gust} = gust\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_PazyFFWT","page":"Public API","title":"AeroBeams.create_PazyFFWT","text":"create_PazyFFWT(; kwargs...)\n\nCreates a version of the Pazy wing with flared folding wingtip (FFWT)\n\nArguments\n\np0::Vector{<:Number} = initial rotation parameters\nairfoil::Airfoil = airfoil section\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nwithTipCorrection::Bool = flag for aerodynamic tip correction \nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\nhingeNode::Int64 = hinge node\nhingeAngle::Number = hinge (fold) angle\nflareAngle::Number = flare angle\nkSpring::Number = stiffness of the hinge\ng::Number=0 = local acceleration of gravity\nairspeed::Number = local airspeed\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_SMW","page":"Public API","title":"AeroBeams.create_SMW","text":"create_SMW(; kwargs...)\n\nCreates the 16 meters wing (SMW) of the conventional HALE aircraft described by Patil, Hodges and Cesnik in: Nonlinear Aeroelasticity and Flight Dynamics of HALE (2001)\n\nReturns the wing model and its span\n\nArguments\n\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with airspeed\nairfoil::Airfoil = airfoil section\nθ::Real = pitch angle\nk1::Real = twisting curvature\nk2::Real = flapwise bending curvature\nnElem::Int64 = number of elements for discretization\naltitude::Real = altitude\nairspeed::Real = airspeed\ng::Real = acceleration of gravity\nstiffnessFactor::Real = stiffness factor for beam structural properties\n∞::Real = value of rigid structural properties\ntipF3::Real = tip dead transverse force applied at the tip\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_TDWing","page":"Public API","title":"AeroBeams.create_TDWing","text":"create_TDWing(; kwargs...)\n\nCreates the wing described by Tang and Dowell in: Experimental and Theoretical Study on Aeroelastic Response of High-Aspect-Ratio Wings (2001)\n\nReturns the wing model\n\nArguments\n\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with airspeed\nairfoil::Airfoil = airfoil section\nθ::Real = pitch angle\nnElem::Int64 = number of elements for discretization\nairspeed::Real = airspeed\ng::Real = acceleration of gravity\n∞::Real = value of rigid structural properties\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_Helios","page":"Public API","title":"AeroBeams.create_Helios","text":"create_Helios(; kwargs...)\n\nCreates a model based on the flying-wing aircraft described by Patil and Hodges in: Flight Dynamics of Highly Flexible Flying Wings (2006)\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\ng::Number = local acceleration of gravity\nwingAirfoil::Airfoil = airfoil section of the wing\npodAirfoil::Airfoil = airfoil section of the pods\nbeamPods::Bool = flag to include pods\nstiffnessFactor::Number = stiffness factor for the wing structure\n∞::Number = value for rigid structural properties\nnElemStraightSemispan::Int64 = number of elements in the straight section of the semispan\nnElemDihedralSemispan::Int64 = number of elements in the dihedral section of the semispan\nnElemPod::Int64 = number of elements in the pods\npayloadPounds::Number = payload, in pounds\nairspeed::Number = local initial/trim airspeed\nδIsTrimVariable::Bool = flag for flap deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδ::Union{Nothing,Number,<:Function} = flap deflection\nthrust::Union{Number,<:Function} = motors' thrust\nreducedChord::Bool = flag to employ a reduced (7 ft) chord\npayloadOnWing::Bool = flag to set the payload on the wing's reference line\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_conventional_HALE","page":"Public API","title":"AeroBeams.create_conventional_HALE","text":"create_conventional_HALE(; kwargs...)\n\nCreates a model based on the conventional HALE aircraft described by Patil, Hodges and Cesnik in: Nonlinear Aeroelasticity and Flight Dynamics of HALE (2001)\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nflapLoadsSolver::FlapAeroSolver = aerodynamic solver for flap loads\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nstabilizersAero::Bool = flag for stabilizers with aerodynamic surfaces\nincludeVS::Bool = flag to include a vertical stabilizer in the model   \nnElemWing::Int64 = number of elements of the full wing\nnElemHorzStabilizer::Int64 = number of elements of the horizontal stabilizer\nnElemTailBoom::Int64 = number of elements of the tail boom\nnElemVertStabilizer::Int64 = number of elements of the vertical stabilizer\n∞::Number=1e12 = value of rigid structural properties\nstiffnessFactor::Number = stiffness factor for the wing structure\nk1::Number = undeformed wing torsional curvature\nk2::Number = undeformed wing flapwise bending curvature\nairspeed::Number = local initial/trim airspeed\nδElevIsTrimVariable::Bool = flag for elevator deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Number,<:Function} = elevator deflection\nthrust::Union{Number,<:Function} = motors' thrust\ng::Number = local acceleration of gravity\nwingCd0::Number = parisite drag coefficient for the wing\nwingcnδ::Number = cn vs δ slope for the wing\nwingcmδ::Number = cm vs δ slope for the wing\nwingcdδ::Number = cd vs δ slope for the wing\nstabsCd0::Number = parisite drag coefficient for the stabilizers\nstabscnδ::Number = cn vs δ slope for the stabilizers\nstabscmδ::Number = cm vs δ slope for the stabilizers\nstabscdδ::Number = cd vs δ slope for the stabilizers\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.create_BWB","page":"Public API","title":"AeroBeams.create_BWB","text":"create_BWB(; kwargs...)\n\nCreates a model based on the blended-wing-body described by Weihua Su's PhD thesis\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives \n∞::Number=1e12 = value of rigid structural properties\nstiffnessFactor::Number = stiffness factor for the wing structure\nairspeed::Number = local initial/trim airspeed\nδElevIsTrimVariable::Bool = flag for elevator deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Number,<:Function} = elevator deflection\nthrust::Union{Number,<:Function} = motors' thrust\ng::Number = local acceleration of gravity\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with airspeed\nhasTipCorrection::Bool = flag to employ aerodynamic tip correction\ntipLossDecayFactor::Number = tip loss decay factor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-spring","page":"Public API","title":"Creating a spring","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_Spring","category":"page"},{"location":"publicAPI/#AeroBeams.create_Spring","page":"Public API","title":"AeroBeams.create_Spring","text":"create_Spring(; kwargs...)\n\nCreates a spring\n\nKeyword arguments\n\nbasis::String = basis on which stiffnesses are defined\nelementsIDs::Vector{Int64} = local IDs of the element(s)' node(s) to which the spring is attached\nnodesSides::Vector{Int64} = sides (1 or 2) of the node(s) to which the spring is attached\nku::Vector{<:Number} = translational stiffness vector\nkp::Vector{<:Number} = rotational stiffness vector\nkTranslational::Number = translational stiffness (same in all directions)\nkTwist::Number = twist stiffness (rotation about x1 direction)\nkIPBending::Number = in-plane bending stiffness (rotation about x3 direction)\nkOOPBending::Number = out-of-plane bending stiffness (rotation about x2 direction)\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-system-solver","page":"Public API","title":"Creating a system solver","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_NewtonRaphson","category":"page"},{"location":"publicAPI/#AeroBeams.create_NewtonRaphson","page":"Public API","title":"AeroBeams.create_NewtonRaphson","text":"create_NewtonRaphson(; kwargs...)\n\nNewton-Raphson nonlinear system solver constructor\n\nKeyword arguments\n\nabsoluteTolerance::Float64 = absolute convergence tolerance\nrelativeTolerance::Float64 = relative convergence tolerance\nmaximumIterations::Int64 = maximum number of iterations\ndesiredIterations::Int64 = desired number of iterations\nmaximumAbsoluteError::Number = maximum absolute error for divergence detection\nmaximumRelativeError::Number = maximum relative error for divergence detection\ninitialLoadFactor::Number = initial load factor\nminimumLoadFactor::Float64 = minimum load factor\nmaximumLoadFactorStep::Float64 = maximum load factor step\nminimumLoadFactorStep::Float64 = minimum load factor step\nρ::Float64 = relaxation factor for trim variables\ntrackingLoadSteps::Bool = flag to track partial load steps solutions\ndisplayStatus::Bool = flag to display status\nminConvRateAeroJacUpdate::Number = minimum convergence rate to skip computation of aerodynamic Jacobians\nminConvRateJacUpdate::Number = minimum convergence rate to skip computation of structural Jacobians\nalwaysUpdateJacobian::Bool = flag to update Jacobians on every iteration\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Creating-a-units-system","page":"Public API","title":"Creating a units system","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"create_UnitsSystem","category":"page"},{"location":"publicAPI/#AeroBeams.create_UnitsSystem","page":"Public API","title":"AeroBeams.create_UnitsSystem","text":"create_UnitsSystem(; kwargs...)\n\nCreates a system composed of length, force, angle, frequency and mass units (this is only for plotting purposes and does not influence calculations)\n\nKeyword arguments\n\nlength::String = length unit\nforce::String = force unit\nangle::String = angle unit\nfrequency::String = frequency unit\nmass::String = mass unit\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Utilities","page":"Public API","title":"Utilities","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"round_off!\nrms\ntilde\nisotropic_stiffness_matrix\ninertia_matrix\nrotation_tensor_E321\nrotation_tensor_E313\nrotation_tensor_WM\nrotation_parameters_WM\nypr_from_rotation_tensor\nquaternion_from_rotation_tensor\nmode_tracking\nget_FFT_and_PSD","category":"page"},{"location":"publicAPI/#AeroBeams.round_off!","page":"Public API","title":"AeroBeams.round_off!","text":"round_off!(x)\n\nRounds the array or number to input tolerance (defaults to machine epsilon)\n\nArguments\n\nx = array / number\ntol = tolerance\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rms","page":"Public API","title":"AeroBeams.rms","text":"rms(x)\n\nComputes the root mean square of an array\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.tilde","page":"Public API","title":"AeroBeams.tilde","text":"tilde(v::Vector{<:Number})\n\nComputes the skew-symmetric matrix associated with a vector\n\nArguments\n\nv::Vector{<:Number} = three-element vector\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.isotropic_stiffness_matrix","page":"Public API","title":"AeroBeams.isotropic_stiffness_matrix","text":"isotropic_stiffness_matrix(; kwargs...)\n\nCreates a 6x6 sectional stiffness matrix\n\nArguments\n\n∞::Number = value for rigid properties\nEA::Number = axial stiffness\nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\nGJ::Number = torsional stiffness\nEIy::Number = bending stiffness about the x2 direction\nEIz::Number = bending stiffness about the x3 direction\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.inertia_matrix","page":"Public API","title":"AeroBeams.inertia_matrix","text":"inertia_matrix(; kwargs...)\n\nCreates a 6x6 sectional inertia matrix\n\nArguments\n\nρA::Number = mass per unit length\nρIy::Number = mass moment of inertia per unit length about the x2-axis\nρIz::Number = mass moment of inertia per unit length about the x3-axis\nρIs::Number = mass moment of inertia per unit length about the x1-axis\ne2::Number = offset of center of gravity in the x2 direction with respect to the local reference line\ne3::Number = offset of center of gravity in the x3 direction with respect to the local reference line\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E321","page":"Public API","title":"AeroBeams.rotation_tensor_E321","text":"rotation_tensor_E321(p::Vector{<:Number})\n\nComputes the rotation tensor according to Euler parameters sequence 3-2-1\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_E313","page":"Public API","title":"AeroBeams.rotation_tensor_E313","text":"rotation_tensor_E313(p::Vector{<:Number})\n\nComputes the rotation tensor according to Euler parameters sequence 3-1-3\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_tensor_WM","page":"Public API","title":"AeroBeams.rotation_tensor_WM","text":"rotation_tensor_WM(p::Vector{<:Number})\n\nComputes the rotation tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.rotation_parameters_WM","page":"Public API","title":"AeroBeams.rotation_parameters_WM","text":"rotation_parameters_WM(R::Matrix{<:Number})\n\nComputes the Wiener-Milenkovic rotation parameters given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.ypr_from_rotation_tensor","page":"Public API","title":"AeroBeams.ypr_from_rotation_tensor","text":"ypr_from_rotation_tensor(R::Matrix{<:Number},tol::Float64=1e-6)\n\nComputes the Euler angles from the sequence 3-2-1 given the rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\ntol::Float64 = round-off tolerance\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.quaternion_from_rotation_tensor","page":"Public API","title":"AeroBeams.quaternion_from_rotation_tensor","text":"quaternion_from_rotation_tensor(R::Matrix{<:Number})\n\nComputes the quaternion (Euler parameters) given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.mode_tracking","page":"Public API","title":"AeroBeams.mode_tracking","text":"mode_tracking(controlParam::Vector{<:Number},freqs::Array{Vector{Float64}},damps::Array{Vector{Float64}},eigenvectors::Array{Matrix{ComplexF64}})\n\nApplies mode tracking based on eigenvectors match\n\nArguments\n\ncontrolParam::Vector{<:Number} = vector of control parameter\nfreqs::Array{Vector{Float64}} = frequencies vector\ndamps::Array{Vector{Float64}} = dampings vector\neigenvectors::Array{Matrix{ComplexF64}} = complex-valued eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.get_FFT_and_PSD","page":"Public API","title":"AeroBeams.get_FFT_and_PSD","text":"get_FFT_and_PSD(t::Vector{<:Number},y::Vector{<:Number}; tol::Float64=1e3*eps())\n\nComputes the FFT and PSD of signal y(t)\n\nArguments\n\nt::Vector{<:Number} = time signal\ny::Vector{<:Number} = quantity signal\n\nKeyword arguments\n\ntol::Float64 = tolerance for time signal being equally spaced\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#Visualizing-the-results","page":"Public API","title":"Visualizing the results","text":"","category":"section"},{"location":"publicAPI/","page":"Public API","title":"Public API","text":"plot_undeformed_assembly\nplot_steady_deformation\nplot_steady_outputs\nplot_mode_shapes\nplot_dynamic_deformation\nplot_time_outputs","category":"page"},{"location":"publicAPI/#AeroBeams.plot_undeformed_assembly","page":"Public API","title":"AeroBeams.plot_undeformed_assembly","text":"plot_undeformed_assembly(model::Model,view::Tuple{Int64,Int64}=(45,45),equalAspectRatio::Bool=true)\n\nPlots the nodal coordinates of the assembly of beams\n\nArguments\n\nmodel::Model\nview::Tuple{<:Number,<:Number} = view angles\nequalAspectRatio::Bool = flag to set equal aspect ratio plot\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_steady_deformation","page":"Public API","title":"AeroBeams.plot_steady_deformation","text":"plot_steady_deformation(problem::Problem; kwargs...)\n\nPlots the initial and final deformed states for the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nplotBCs::Bool = flag to plot BCs\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nscale::Number = displacements and rotations scale\nlw::Number = linewidth\ncolorUndef = color for undeformed assembly\ncolorDef = color for deformed assembly\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nΔuDef::Vector{<:Number} = displacement vector for first node of deformed assembly relative to the undeformed one\nplotLimits::Union{Nothing,Vector{Tuple{T1,T2}}} = plot axis limits    \nshowScale::Bool = flag to show scale on plot\nscalePos::Vector{<:Number} = position of scale on plot\nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_steady_outputs","page":"Public API","title":"AeroBeams.plot_steady_outputs","text":"plot_steady_outputs(problem::Problem; kwargs...)\n\nPlots outputs of a steady problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\noutputs::Vector{String} = list of outputs\nbeamGroups = list of beams in each group for which arclengths are concatenated\nlw::Number = linewidth\ncolorScheme = color scheme\nlegendPos = legend position\nsave::Bool = flag to save figures\nsaveFolder::String = relative path of folder where to save figures\nfigureExtension::String = figure extension\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_mode_shapes","page":"Public API","title":"AeroBeams.plot_mode_shapes","text":"plot_mode_shapes(problem::Problem; kwargs...)\n\nPlots the mode shapes of the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nplotBCs::Bool = flag to plot BCs\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nnModes::Union{Nothing,Int64} = number of modes to plot\nscale::Number = displacements and rotations scale\nfrequencyLabel::String = option for frequency label (only frequency or frequency and damping)\nlw::Number = linewidth\ncolorSteady = color for steadily deformed assembly\nmodalColorScheme = color scheme for mode shapes\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_dynamic_deformation","page":"Public API","title":"AeroBeams.plot_dynamic_deformation","text":"plot_dynamic_deformation(problem::Problem; kwargs...)\n\nPlots the animated deformation of the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nrefBasis::String = reference basis for plot\nplotFrequency::Int64 = frequency of time steps to plot\nplotUndeformed::Bool = flag to plot undeformed assembly\nplotBCs::Bool = flag to plot BCs\nplotDistLoads::Bool = flag to plot distributed loads (includes gravitational and aerodynamic loads)\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nfps::Number = frame rate for gif\nscale::Number = displacements and rotations scale\nfrequencyLabel::String = option for frequency label (only frequency or frequency and damping)\nlw::Number = linewidth\ncolorUndef = color for undeformed assembly\ncolorDef = color for deformed assembly\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nplotLimits::Union{Nothing,Vector{Tuple{T1,T2}}} = plot axis limits\nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\nshowScale::Bool = flag to show scale on plot\nshowTimeStamp::Bool = flag to show time stamp on plot\nscalePos::Vector{<:Number} = position of scale on plot\ntimeStampPos::Vector{<:Number} = position of time stamp on plot\ndisplayProgress::Bool = flag to display progress of gif creation\n\n\n\n\n\n","category":"function"},{"location":"publicAPI/#AeroBeams.plot_time_outputs","page":"Public API","title":"AeroBeams.plot_time_outputs","text":"plot_time_outputs(problem::Problem; kwargs...)\n\nPlots outputs of a dynamic problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nnodes::Vector{Tuple{Int64,Int64}} = global IDs of nodes for which to plot\nelements::Vector{Int64} = global IDs of elements for which to plot\nnodalOutputs::Vector{String} = nodal outputs to plot\nelementalOutputs::Vector{String} = elemental outputs to plot\nlw::Number = linewidth\ncolorScheme = color scheme\nshowLegend::Bool = flag to show legend\nlegendPos = legend position\nsave::Bool = flag to save figures\nsaveFolder::String = relative path of folder where to save figures\nfigureExtension::String = figure extension\n\n\n\n\n\n","category":"function"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"EditURL = \"../../test/examples/archUnderFollowerPressure.jl\"","category":"page"},{"location":"archUnderFollowerPressure/#Arch-under-follower-pressure","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"","category":"section"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"This example simulates the static response of an arch subjected to a normal (follower) pressure. Let's begin by loading the package.","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"using AeroBeams","category":"page"},{"location":"archUnderFollowerPressure/#Beam","page":"Arch under follower pressure","title":"Beam","text":"","category":"section"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"The first step is to create a beam. The arch has radius R and spans over and angle θ. The curvature of the beam is thus 1/R, and the total length is L=Rθ. We define the beam orientation such that the arch spans from an angle -θ/2 to θ/2 about a vertical line. This is done by specifying the rotation parameters from basis A to basis b, p0, with the Euler parameters sequence 3-2-1: the angle of rotation about the second axis is -θ/2. The cross-section has area A and bending moment of inertia Iy. The elastic modulus of the material is E. We discretize the beam into nElem finite elements.","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"R,θ = 2.54,120*π/180\nk2 = 1/R\nL = R*θ\nA,Iy = 4.05e-4,13.1e-8\nE = 70.4e9\nEA,EIy = E*A,E*Iy\nnElem = 80\nbeam = create_Beam(name=\"beam\",length=L,nElements=nElem,C=[isotropic_stiffness_matrix(∞=1e12,EA=EA,EIy=EIy)],rotationParametrization=\"E321\",p0=[0;-θ/2;0],k=[0;k2;0]);\nnothing #hide","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"BCs","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"λ = 11\nq = -λ*EIy/R^2\nadd_loads_to_beam!(beam,loadTypes=[\"ff_b_of_x1t\"],loadFuns=[(x1,t)->[0; 0; q]])\nclamp1 = create_BC(name=\"clamp1\",beam=beam,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamp2 = create_BC(name=\"clamp2\",beam=beam,node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"Model","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"archUnderFollowerPressure = create_Model(name=\"archUnderFollowerPressure\",beams=[beam],BCs=[clamp1,clamp2])","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"Set system solver options","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"σ0 = 0\nσstep = 0.02\nNR = create_NewtonRaphson(initialLoadFactor=σ0,maximumLoadFactorStep=σstep)","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"Create and solve the problem","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"problem = create_SteadyProblem(model=archUnderFollowerPressure,systemSolver=NR)\nsolve!(problem)","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"Get solution at partial load steps","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"σVector = problem.savedσ\nmid_u3 = [problem.nodalStatesOverσ[i][div(nElem,2)].u_n2[3] for i in 1:length(σVector)]\n\nprintln(\"Finished archUnderFollowerPressure.jl\")","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"","category":"page"},{"location":"archUnderFollowerPressure/","page":"Arch under follower pressure","title":"Arch under follower pressure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"EditURL = \"../../test/examples/archUnderDeadPressure.jl\"","category":"page"},{"location":"archUnderDeadPressure/#Arch-under-dead-pressure","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"This example simulates the static response of an arch subjected to a vertical pressure. Let's begin by loading the package.","category":"page"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"using AeroBeams","category":"page"},{"location":"archUnderDeadPressure/#Beam","page":"Arch under dead pressure","title":"Beam","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"The first step is to create a beam. The arch has radius R and spans over and angle θ. The curvature of the beam is thus 1/R, and the total length is L=Rθ. We define the beam orientation such that the arch spans from an angle -θ/2 to θ/2 about a vertical line. This is done by specifying the rotation parameters from basis A to basis b, p0, with the Euler parameters sequence 3-2-1: the angle of rotation about the second axis is -θ/2. The cross-section has area A and bending moment of inertia Iy. The elastic modulus of the material is E. We discretize the beam into nElem finite elements.","category":"page"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"R,θ = 2.54,120*π/180\nk2 = 1/R\nL = R*θ\nA,Iy = 4.05e-4,13.1e-8\nE = 70.4e9\nEA,EIy = E*A,E*Iy\nnElem = 80\nbeam = create_Beam(name=\"beam\",length=L,nElements=nElem,C=[isotropic_stiffness_matrix(∞=1e12,EA=EA,EIy=EIy)],rotationParametrization=\"E321\",p0=[0;-θ/2;0],k=[0;k2;0]);\nnothing #hide","category":"page"},{"location":"archUnderDeadPressure/#BCs","page":"Arch under dead pressure","title":"BCs","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"λ = 8.7\nq = -λ*EIy/R^2\nadd_loads_to_beam!(beam,loadTypes=[\"f_A_of_x1t\"],loadFuns=[(x1,t)->[0; 0; q]])\nclamp1 = create_BC(name=\"clamp1\",beam=beam,node=1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])\nclamp2 = create_BC(name=\"clamp2\",beam=beam,node=nElem+1,types=[\"u1A\",\"u2A\",\"u3A\",\"p1A\",\"p2A\",\"p3A\"],values=[0,0,0,0,0,0])","category":"page"},{"location":"archUnderDeadPressure/#Model","page":"Arch under dead pressure","title":"Model","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"archUnderDeadPressure = create_Model(name=\"archUnderDeadPressure\",beams=[beam],BCs=[clamp1,clamp2])","category":"page"},{"location":"archUnderDeadPressure/#Set-system-solver-options","page":"Arch under dead pressure","title":"Set system solver options","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"σ0 = 0\nσstep = 0.02\nNR = create_NewtonRaphson(initialLoadFactor=σ0,maximumLoadFactorStep=σstep)","category":"page"},{"location":"archUnderDeadPressure/#Create-and-solve-the-problem","page":"Arch under dead pressure","title":"Create and solve the problem","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"problem = create_SteadyProblem(model=archUnderDeadPressure,systemSolver=NR)\nsolve!(problem)","category":"page"},{"location":"archUnderDeadPressure/#Get-solution-at-partial-load-steps","page":"Arch under dead pressure","title":"Get solution at partial load steps","text":"","category":"section"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"σVector = problem.savedσ\nmid_u3 = [problem.nodalStatesOverσ[i][div(nElem,2)].u_n2[3] for i in 1:length(σVector)]\n\nprintln(\"Finished archUnderDeadPressure.jl\")","category":"page"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"","category":"page"},{"location":"archUnderDeadPressure/","page":"Arch under dead pressure","title":"Arch under dead pressure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#AeroBeams.jl","page":"Home","title":"AeroBeams.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AeroBeams.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AeroBeams is a finite-element implementation of the geometrically exact beam theory of [1], augmented with aerodynamic formulations in order to solve aeroelastic problems. The structural part of the code was developed based on the works of [2], [3] and [4], whereas the aerodynamic part follows [5], [6] and [7].","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install AeroBeams, simply go to the package manager mode in the Julia REPL by typing ], and then","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add AeroBeams","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Hodges, D. H. \"Nonlinear Composite Beam Theory\". 2006. American Institute of Aeronautics and Astronautics. 10.2514/4.866821","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Hodges, D. H., Shang, X. and Cesnik, C. E. S. \"Finite element solution of nonlinear intrinsic equations for curved composite beams\". 1996. Journal of the American Helicopter Society. 10.2514/6.1995-1174","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Yu, W. and Blair, M. \"GEBT: A general-purpose nonlinear analysis tool for composite beams\". 2012. Composite Structures. 10.1016/j.compstruct.2012.04.007","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] Wang, Q. and Yu, W. \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\". 2017. Journal of Renewable and Sustainable Energy. 10.1063/1.4985091","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] Leishman, J. G. \"Principles of Helicopter Aerodynamics\". 2006. Cambridge University Press.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6] Peters, D. A., Karunamoorthy, S. and Cao, W. \"Finite state induced flow models. I: Two-dimensional thin airfoil\". 1995. Journal of Aircraft. 10.2514/3.46718","category":"page"},{"location":"","page":"Home","title":"Home","text":"[7] dos Santos, L. G. P. and Marques, F. D. \"Improvements on the Beddoes-Leishman dynamic stall model for low speed applications\". 2021. Journal of Fluids and Structures. 10.1016/j.jfluidstructs.2021.103375","category":"page"}]
}
