var documenterSearchIndex = {"docs":
[{"location":"private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"private/#Aerodynamics","page":"Private API","title":"Aerodynamics","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.aero_steady_kinematics!\nAeroBeams.aero_unsteady_kinematics!\nAeroBeams.nondimensional_flow_parameters!\nAeroBeams.local_gust_velocity!\nAeroBeams.flap_deflection_rates!\nAeroBeams.aero_coefficients!\nAeroBeams.aero_state_matrices!\nAeroBeams.aero_loads_resultants!\nAeroBeams.attached_flow_aero_coefficients!\nAeroBeams.update_airfoil_parameters!\nAeroBeams.effective_angle_of_attack!\nAeroBeams.attached_flow_cn!\nAeroBeams.attached_flow_cm!\nAeroBeams.attached_flow_ct!\nAeroBeams.pitch_plunge_effective_normalwash\nAeroBeams.flap_effective_normalwash\nAeroBeams.flap_normalwash\nAeroBeams.gust_effective_normalwash\nAeroBeams.flap_normalwash_rate\nAeroBeams.cnαUₙTQC_rate\nAeroBeams.attached_flow_state_matrices!\nAeroBeams.BLi_aero_coefficients!\nAeroBeams.BLi_kinematics!\nAeroBeams.BLi_nonlinear_states!\nAeroBeams.BLi_motion_qualifiers!\nAeroBeams.BLi_breakpoint_angles!\nAeroBeams.BLi_time_delays!\nAeroBeams.BLi_separation_points!\nAeroBeams.BLi_quasi_steady_separation_points\nAeroBeams.BLi_stall_time!\nAeroBeams.BLi_DSV_loads!\nAeroBeams.BLi_cn!\nAeroBeams.BLi_cm!\nAeroBeams.BLi_ct!\nAeroBeams.BLi_state_matrices!\nAeroBeams.BLo_aero_coefficients!\nAeroBeams.BLo_nonlinear_states!\nAeroBeams.BLo_motion_qualifiers!\nAeroBeams.BLo_breakpoint_angle!\nAeroBeams.BLo_separation_points!\nAeroBeams.BLo_stall_time!\nAeroBeams.BLo_time_delays!\nAeroBeams.BLo_update_impulsive_parameters!\nAeroBeams.BLo_vortex_accumulation_rate!\nAeroBeams.BLo_cn!\nAeroBeams.BLo_cm!\nAeroBeams.BLo_ct!\nAeroBeams.BLo_state_matrices!\nAeroBeams.update_initial_aero_states!","category":"page"},{"location":"private/#AeroBeams.aero_steady_kinematics!","page":"Private API","title":"AeroBeams.aero_steady_kinematics!","text":"aerosteadykinematics!(element::Element,V,Ω)\n\nComputes the steady aerodynamic kinematic variables\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_unsteady_kinematics!","page":"Private API","title":"AeroBeams.aero_unsteady_kinematics!","text":"aerounsteadykinematics!(element::Element,Vdot,Ωdot)\n\nComputes the unsteady aerodynamic kinematic variables\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.nondimensional_flow_parameters!","page":"Private API","title":"AeroBeams.nondimensional_flow_parameters!","text":"nondimensionalflowparameters!(model::Model,element::Element)\n\nComputes the nondimensional flow parameters\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.local_gust_velocity!","page":"Private API","title":"AeroBeams.local_gust_velocity!","text":"localgustvelocity!(problem::Problem,model::Model,element::Element)\n\nComputes the gust velocity in the local, deformed aerodynamic basis (basis W)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.flap_deflection_rates!","page":"Private API","title":"AeroBeams.flap_deflection_rates!","text":"flapdeflectionrates!(problem,element::Element)\n\nComputes the current values of flap deflection rates\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_coefficients!","page":"Private API","title":"AeroBeams.aero_coefficients!","text":"aero_coefficients!(problem::Problem,element::Element,χ,δNow)\n\nComputes the aerodynamic coefficients\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_state_matrices!","page":"Private API","title":"AeroBeams.aero_state_matrices!","text":"aerostatematrices!(element::Element,δNow)\n\nComputes the aerodynamic state matrices\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_loads_resultants!","page":"Private API","title":"AeroBeams.aero_loads_resultants!","text":"aeroloadsresultants!(model::Model,element::Element)\n\nComputes the aerodynamic nodal loads resultants\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.attached_flow_aero_coefficients!","page":"Private API","title":"AeroBeams.attached_flow_aero_coefficients!","text":"attachedflowaero_coefficients!(element::Element,δNow)\n\nComputes the aerodynamic coefficients under attached flow conditions\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_airfoil_parameters!","page":"Private API","title":"AeroBeams.update_airfoil_parameters!","text":"updateairfoilparameters!(problem::Problem,element::Element)\n\nUpdates the aerodynamic parameters of the airfoil according to current nondimensional flow parameters \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.effective_angle_of_attack!","page":"Private API","title":"AeroBeams.effective_angle_of_attack!","text":"effectiveangleof_attack!(element::Element,χ,δNow)\n\nComputes the effective (unsteady) angle of attack\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.attached_flow_cn!","page":"Private API","title":"AeroBeams.attached_flow_cn!","text":"attachedflowcn!(element::Element,δNow)\n\nComputes the normal force aerodynamic coefficient for attached flow\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.attached_flow_cm!","page":"Private API","title":"AeroBeams.attached_flow_cm!","text":"attachedflowcm!(element::Element,δNow)\n\nComputes the pitching moment aerodynamic coefficient at the attachment point (i.e., the beam reference line) for attached flow\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.attached_flow_ct!","page":"Private API","title":"AeroBeams.attached_flow_ct!","text":"attachedflowct!(element::Element,δNow)\n\nComputes the tangential force aerodynamic coefficient for attached flow\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.pitch_plunge_effective_normalwash","page":"Private API","title":"AeroBeams.pitch_plunge_effective_normalwash","text":"pitchplungeeffective_normalwash(element::Element,χ)\n\nComputes the effective (unsteady) pitch-plunge-induced normalwash\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.flap_effective_normalwash","page":"Private API","title":"AeroBeams.flap_effective_normalwash","text":"flapeffectivenormalwash(element::Element,χ,δNow)\n\nComputes the effective (unsteady) flap-induced normalwash\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.flap_normalwash","page":"Private API","title":"AeroBeams.flap_normalwash","text":"flap_normalwash(element::Element,δNow)\n\nComputes the instantaneous (quasi-steady) flap-induced normalwash\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.gust_effective_normalwash","page":"Private API","title":"AeroBeams.gust_effective_normalwash","text":"gusteffectivenormalwash(element::Element,χ)\n\nComputes the effective (unsteady) gust-induced normalwash\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.flap_normalwash_rate","page":"Private API","title":"AeroBeams.flap_normalwash_rate","text":"flapnormalwashrate(element::Element,δNow)\n\nComputes the time rate of the instantaneous flap-induced normalwash\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.cnαUₙTQC_rate","page":"Private API","title":"AeroBeams.cnαUₙTQC_rate","text":"cnαUₙTQC_rate(element::Element)\n\nComputes the time rate of the product of cnα by UₙTQC\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.attached_flow_state_matrices!","page":"Private API","title":"AeroBeams.attached_flow_state_matrices!","text":"attachedflowstate_matrices!(element::Element,δNow)\n\nComputes the aerodynamic state matrices for the indicial and inflow solvers\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_aero_coefficients!","page":"Private API","title":"AeroBeams.BLi_aero_coefficients!","text":"BLiaerocoefficients!(problem::Problem,element::Element,χ,δNow)\n\nComputes the aerodynamic coefficients according to the modified incompressible flow Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_kinematics!","page":"Private API","title":"AeroBeams.BLi_kinematics!","text":"BLi_kinematics!(element::Element)\n\nComputes additional kinematics associated with the Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_nonlinear_states!","page":"Private API","title":"AeroBeams.BLi_nonlinear_states!","text":"BLinonlinearstates!(element::Element,χ)\n\nSets the nonlinear states of the Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_motion_qualifiers!","page":"Private API","title":"AeroBeams.BLi_motion_qualifiers!","text":"BLimotionqualifiers!(problem::Problem,element::Element)\n\nComputes motion qualifiers of the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_breakpoint_angles!","page":"Private API","title":"AeroBeams.BLi_breakpoint_angles!","text":"BLibreakpointangles!(element::Element)\n\nComputes the breakpoint angles of the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_time_delays!","page":"Private API","title":"AeroBeams.BLi_time_delays!","text":"BLitimedelays!(element::Element)\n\nComputes time delay variables for the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_separation_points!","page":"Private API","title":"AeroBeams.BLi_separation_points!","text":"BLiseparationpoints!(element::Element)\n\nComputes the flow separation points of the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_quasi_steady_separation_points","page":"Private API","title":"AeroBeams.BLi_quasi_steady_separation_points","text":"BLiquasisteadyseparationpoints(element::Element,Uₜ,Uₙ)\n\nComputes the quasi-steady flow separation points of the modified Beddoes-Leishman model for an element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_stall_time!","page":"Private API","title":"AeroBeams.BLi_stall_time!","text":"BListalltime!(problem::Problem,element::Element)\n\nComputes variables at the time of stall onset for the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_DSV_loads!","page":"Private API","title":"AeroBeams.BLi_DSV_loads!","text":"BLiDSVloads!(element::Element)\n\nComputes DSV loads for the modified Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_cn!","page":"Private API","title":"AeroBeams.BLi_cn!","text":"BLi_cn!(element::Element,δNow)\n\nComputes normal force coefficient for the modified incompressible Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_cm!","page":"Private API","title":"AeroBeams.BLi_cm!","text":"BLi_cm!(element::Element,δNow)\n\nComputes the pitching moment aerodynamic coefficient at the attachment point (i.e., the beam reference line) for the modified incompressible Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_ct!","page":"Private API","title":"AeroBeams.BLi_ct!","text":"BLi_ct!(element::Element,δNow)\n\nComputes the tangential force aerodynamic coefficient for the modified incompressible Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLi_state_matrices!","page":"Private API","title":"AeroBeams.BLi_state_matrices!","text":"BListatematrices!(element::Element,δNow)\n\nComputes the aerodynamic state matrices for the modified incompressible Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_aero_coefficients!","page":"Private API","title":"AeroBeams.BLo_aero_coefficients!","text":"BLoaerocoefficients!(problem::Problem,element::Element,χ,δNow)\n\nComputes the aerodynamic coefficients according to the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_nonlinear_states!","page":"Private API","title":"AeroBeams.BLo_nonlinear_states!","text":"BLononlinearstates!(element::Element,χ)\n\nSets the nonlinear states of the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_motion_qualifiers!","page":"Private API","title":"AeroBeams.BLo_motion_qualifiers!","text":"BLomotionqualifiers!(element::Element)\n\nComputes motion qualifiers of the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_breakpoint_angle!","page":"Private API","title":"AeroBeams.BLo_breakpoint_angle!","text":"BLobreakpointangle!(element::Element)\n\nComputes the breakpoint angle of the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_separation_points!","page":"Private API","title":"AeroBeams.BLo_separation_points!","text":"BLoseparationpoints!(element::Element)\n\nComputes the flow separation point of the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_stall_time!","page":"Private API","title":"AeroBeams.BLo_stall_time!","text":"BLostalltime!(problem::Problem,element::Element)\n\nComputes variables at the time of stall onset for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_time_delays!","page":"Private API","title":"AeroBeams.BLo_time_delays!","text":"BLotimedelays!(element::Element)\n\nComputes time delay variables for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_update_impulsive_parameters!","page":"Private API","title":"AeroBeams.BLo_update_impulsive_parameters!","text":"BLoupdateimpulsive_parameters!(element::Element)\n\nUpdates the impulsive parameters for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_vortex_accumulation_rate!","page":"Private API","title":"AeroBeams.BLo_vortex_accumulation_rate!","text":"BLovortexaccumulation_rate!(element::Element,χ)\n\nCompute the dynamic stall vortex accumulation rate for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_cn!","page":"Private API","title":"AeroBeams.BLo_cn!","text":"BLo_cn!(element::Element,χ,δNow)\n\nComputes normal force coefficient for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_cm!","page":"Private API","title":"AeroBeams.BLo_cm!","text":"BLo_cm!(element::Element,χ,δNow)\n\nComputes the pitching moment aerodynamic coefficient at the attachment point (i.e., the beam reference line) for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_ct!","page":"Private API","title":"AeroBeams.BLo_ct!","text":"BLo_ct!(element::Element,δNow)\n\nComputes the tangential force aerodynamic coefficient for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BLo_state_matrices!","page":"Private API","title":"AeroBeams.BLo_state_matrices!","text":"BLostatematrices!(element::Element,δNow)\n\nComputes the aerodynamic state matrices for the original Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_initial_aero_states!","page":"Private API","title":"AeroBeams.update_initial_aero_states!","text":"updateinitialaero_states!(problem::Problem)\n\nUpdates the initial aerodynamic states assuming their rates are zero\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroProperties","page":"Private API","title":"AeroProperties","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.FlowParameters\nAeroBeams.FlowAnglesAndRates\nAeroBeams.FlowVelocitiesAndRates\nAeroBeams.AeroCoefficients\nAeroBeams.BLiNamedStates\nAeroBeams.BLoNamedStates\nAeroBeams.BLiKinematics\nAeroBeams.BLiFlowVariables\nAeroBeams.BLoFlowVariables\nAeroBeams.BLiComplementaryVariables\nAeroBeams.BLoComplementaryVariables\nAeroBeams.AeroVariables\nAeroBeams.AeroProperties\nAeroBeams.initial_F_χ_χ\nAeroBeams.initial_F_χ_Vdot\nAeroBeams.initial_F_χ_Ωdot","category":"page"},{"location":"private/#AeroBeams.FlowParameters","page":"Private API","title":"AeroBeams.FlowParameters","text":"mutable struct FlowParameters\n\nFlowParameters composite type\n\nFields\n\nRe = Reynolds number\nMa = Mach number\nβₚ = Prandtl-Glauert compressibility factor\nβₚ² = Prandtl-Glauert compressibility factor squared\nΘ = Uᵢ/b*βₚ²\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.FlowAnglesAndRates","page":"Private API","title":"AeroBeams.FlowAnglesAndRates","text":"mutable struct FlowAnglesAndRates\n\nFlowAnglesAndRates composite type\n\nFields\n\nα = quasi-steady angle of attack\nβ = angle of sideslip\nαdot = quasi-steady angle of attack rate\nαₑ = effective angle of attack at 3/4-chord\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.FlowVelocitiesAndRates","page":"Private API","title":"AeroBeams.FlowVelocitiesAndRates","text":"mutable struct FlowVelocitiesAndRates\n\nFlowVelocitiesAndRates composite type\n\nFields\n\nU = wind velocity vector at spar position, resolved in basis W\nU∞ = norm of U\nUₛ = spanwise component of U\nUₜ = tangential component of U\nUₙ = normal component of U\nUᵢ = in-plane component of U\nΩₐ = spanwise angular velocity component, resolved in basis W\nUₙMid = relative normal wind velocity component at the airfoil's 1/2-chord\nUₙTQC = relative normal wind velocity component at the airfoil's 3/4-chord\nUdot = wind acceleration vector at spar position, resolved in basis W\nUₜdot = tangential component of Udot\nUₙdot = normal component of U\nUᵢdot = in-plane component of U\nΩₐdot = spanwise angular velocity component, resolved in basis W\nUₙdotMid = relative normal wind acceleration component at the airfoil's 1/2-chord\nUₙdotTQC = = relative normal wind acceleration component at the airfoil's 3/4-chord\nUₜGust = gust tangential velocity component\nUₙGust = gust normal velocity component\nwₑp = effective pitch-plunge-induced normal velocity component at the airfoil's 3/4-chord\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.AeroCoefficients","page":"Private API","title":"AeroBeams.AeroCoefficients","text":"mutable struct AeroCoefficients\n\nAeroCoefficients composite type\n\nFields\n\ncn = normal force coefficient\ncm = pitching moment coefficient about spar position\nct = tangential force coefficient\ncnC = circulatory component of cn\ncnI = inertial component of cn\ncnP = potential flow component of cn\ncmC = circulatory component of cm\ncmI = inertial component of cm\ncmRot = rotation-induced component of cm\ncnF = separated-flow circulatory component of cn\ncmF = separated-flow circulatory component of cm\nctF = separated-flow circulatory component of ct\ncnV = DSV-induced component of cn\ncmV = DSV-induced component of cm\nctV = DSV-induced component of ct\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLiNamedStates","page":"Private API","title":"AeroBeams.BLiNamedStates","text":"mutable struct BLiNamedStates\n\nBLiNamedStates composite type\n\nFields\n\nαlag \nf2primeN\nf2primeM\nf2primeT\nRD\nRD_stallOnsetRatio\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLoNamedStates","page":"Private API","title":"AeroBeams.BLoNamedStates","text":"mutable struct BLoNamedStates\n\nBLoNamedStates composite type\n\nFields\n\ncnPprime\nf2Prime\nfPrimeM\ncnVP\ncnVN\ncnV\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLiKinematics","page":"Private API","title":"AeroBeams.BLiKinematics","text":"mutable struct BLiKinematics\n\nBLiKinematics composite type\n\nFields\n\nr\nqR\nR\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLiFlowVariables","page":"Private API","title":"AeroBeams.BLiFlowVariables","text":"mutable struct BLiFlowVariables\n\nBLiFlowVariables composite type\n\nFields\n\nstallOnsetRatio\nupstroke\nS\nP\nT\nα1N\nα1M\nα1T\nfN\nfM\nfT\nfPrimeN\nfPrimeM\nfPrimeT\nTa_SO\nTfN\nTfM\nTfT\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLoFlowVariables","page":"Private API","title":"AeroBeams.BLoFlowVariables","text":"mutable struct BLoFlowVariables\n\nBLoFlowVariables composite type\n\nFields\n\nαlag\nq\nstallOnsetRatio\nupstroke\nα1\nf\nfPrime\nTf\nTv\nKa\nKq\nKaM\nKqM\nTᵢ\nKf\ncvdotP\ncvdotN\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLiComplementaryVariables","page":"Private API","title":"AeroBeams.BLiComplementaryVariables","text":"mutable struct BLiComplementaryVariables\n\nBLiComplementaryVariables composite type\n\nFields\n\nstallOnsetRatioPrev\nαlagPrev\nqRPrev\nPPrev\nupstrokePrev\nmaxStallOnsetRatio\nminStallOnsetRatio \nqRmax\nTs\ntv0P\nfDiff_tv0P\nqR_tv0P\nR_tv0P\nRD_tv0P\nupstroke_tv0P\nfDiff_tv0P2\nRD_tv0P2\nupstroke_tv0P2\ntv0N\nfDiff_tv0N\nqR_tv0N\nR_tv0N\nRD_tv0N\nupstroke_tv0N\nfDiff_tv0N2\nRD_tv0N2\nupstroke_tv0N2\nlastRD_tv0\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLoComplementaryVariables","page":"Private API","title":"AeroBeams.BLoComplementaryVariables","text":"mutable struct BLoComplementaryVariables\n\nBLoComplementaryVariables composite type\n\nFields\n\nstallOnsetRatioPrev\ntv0P\ntv0N\nτvP\nτvN\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.AeroVariables","page":"Private API","title":"AeroBeams.AeroVariables","text":"mutable struct AeroVariables\n\nAeroVariables composite type\n\nFields\n\nflowParameters::FlowParameters\nflowAnglesAndRates::FlowAnglesAndRates\nflowVelocitiesAndRates::FlowVelocitiesAndRates\naeroCoefficients::AeroCoefficients\nBLiKin::BLiKinematics\nBLiFlow::BLiFlowVariables\nBLoFlow::BLoFlowVariables\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.AeroProperties","page":"Private API","title":"AeroBeams.AeroProperties","text":"@with_kw mutable struct AeroProperties\n\nAeroProperties composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.initial_F_χ_χ","page":"Private API","title":"AeroBeams.initial_F_χ_χ","text":"initialFχ_χ(solver::AeroSolver,nStates::Int64)\n\nComputes the initial value of Fχχ (for zero relative airspeed) - theoretically, the ϵ value in the function should go to zero as the airspeed goes to zero, but numerical problems are found for the inflow solver\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initial_F_χ_Vdot","page":"Private API","title":"AeroBeams.initial_F_χ_Vdot","text":"initialFχ_Vdot(solver::AeroSolver,nStates::Int64,pitchPlungeStatesRange::Union{Nothing,UnitRange{Int64}},cnα::Number)\n\nComputes the initial value of FχVdot (for zero relative airspeed)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initial_F_χ_Ωdot","page":"Private API","title":"AeroBeams.initial_F_χ_Ωdot","text":"initialFχ_Ωdot(solver::AeroSolver,nStates::Int64,pitchPlungeStatesRange::Union{Nothing,UnitRange{Int64}},c::Number,normSparPos::Float64,cnα::Number)\n\nComputes the initial value of FχΩdot (for zero relative airspeed)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroSolver","page":"Private API","title":"AeroSolver","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.theodorsen_flap_constants\nAeroBeams.inflow_arrays","category":"page"},{"location":"private/#AeroBeams.theodorsen_flap_constants","page":"Private API","title":"AeroBeams.theodorsen_flap_constants","text":"function theodorsenflapconstants(normSparPos::Float64,normFlapPos::Float64)\n\nComputes Theodorsen's flap constants\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.inflow_arrays","page":"Private API","title":"AeroBeams.inflow_arrays","text":"inflow_arrays(N::Int64)\n\nComputes the fixed state arrays from Peters' inflow theory\n\n\n\n\n\n","category":"function"},{"location":"private/#Airfoil","page":"Private API","title":"Airfoil","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.AttachedFlowParameters\nAeroBeams.BLiParameters\nAeroBeams.BLoParameters\nAeroBeams.get_airfoil_coordinates","category":"page"},{"location":"private/#AeroBeams.AttachedFlowParameters","page":"Private API","title":"AeroBeams.AttachedFlowParameters","text":"@with_kw mutable struct AttachedFlowParameters\n\nAttachedFlowParameters composite type\n\nFields\n\nα₀N::Number\nϵₙ::Number\nϵₘ::Number\nη::Number\ncd₀::Number\ncdδ::Number\ncm₀::Number\ncmα::Number\ncmδ::Number\ncnα::Number\ncnδ::Number\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLiParameters","page":"Private API","title":"AeroBeams.BLiParameters","text":"@with_kw mutable struct BLiParameters\n\nBLiParameters composite type\n\nFields\n\nα₀N::Number\nαds₀::Number\nαₛₛ::Number\nα1₀N::Number\nα1₀M::Number\nα1₀T::Number\nβσ1N::Number\nβσ1T::Number\nβσ2N::Number\nβS2Nlpr::Number\nβS2Tlpr::Number\nβS1Nu::Number\nβS1Mu::Number\nβS1Tu::Number\nβS1Nd::Number\nβS1Md::Number\nβS1Td::Number\nβS2Nu::Number\nβS2Mu::Number\nβS2Tu::Number\nβS2Nd::Number\nβS2Md::Number\nβS2Td::Number\nγLS::Number\nδα₀::Number\nδα₁::Number\nϵₙ::Number\nϵₘ::Number\nη::Number\nκ₀::Number\nκ₁::Number\nκ₂::Number\nκ₃::Number\nλ₁::Number\nλ₂::Number\nμv₂::Number\nν₁::Number\nν₂::Number\nν₃::Number\nν₄::Number\nν₅::Number\nχu::Number\nχd::Number\nξ::Number\nζₐ::Number\ncd₀::Number\ncdδ::Number\ncm₀::Number\ncmδ::Number\ncnα::Number\ncnδ::Number\ndt::Number\ndm::Number\nE₀::Number\nE₁::Number\nf₀N::Number\nf₀M::Number\nf₀T::Number\nfbN::Number\nfbM::Number\nfbT::Number\ngᵥ::Number\ngᵥ₂::Number\nK₀::Number\nK₁::Number\nK₂::Number\nr₀::Number\nS1N::Number\nS1M::Number\nS1T::Number\nS2N::Number\nS2M::Number\nS2T::Number\nTa::Number\nTf::Number\nTg::Number\nTv::Number\nTv₂::Number\nVn₁::Number\nVn₂::Number\nVn₃::Number\nVm::Number\nVt::Number\nztd::Number\nztu::Number\nzm::Number\nλbWMat::Matrix{Float64}\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.BLoParameters","page":"Private API","title":"AeroBeams.BLoParameters","text":"@with_kw mutable struct BLoParameters\n\nBLoParameters composite type\n\nFields\n\nα₀N::Number\nα1₀::Number\nδα::Number\nϵₙ::Number\nϵₘ::Number\nη::Number\ncd₀::Number\ncdδ::Number\ncm₀::Number\ncmδ::Number\ncn₁::Number\ncnα::Number\ncnδ::Number\nDf::Number\nE₀::Number\nf₀::Number\nfb::Number\nK₀::Number\nK₁::Number\nK₂::Number\nS1::Number\nS2::Number\nTf₀::Number\nTp::Number\nTv₀::Number\nTvL::Number\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.get_airfoil_coordinates","page":"Private API","title":"AeroBeams.get_airfoil_coordinates","text":"getairfoilcoordinates(name::String)\n\nGets the coordinates of the airfoil\n\n\n\n\n\n","category":"function"},{"location":"private/#Atmosphere","page":"Private API","title":"Atmosphere","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.air_properties_from_pressure_and_temperature","category":"page"},{"location":"private/#AeroBeams.air_properties_from_pressure_and_temperature","page":"Private API","title":"AeroBeams.air_properties_from_pressure_and_temperature","text":"airpropertiesfrompressureand_temperature(p::Number,T::Number,R::Number,γ::Number,β::Number,S::Number)\n\nCalculates air properties from given pressure and temperature\n\n\n\n\n\n","category":"function"},{"location":"private/#Boundary-conditions","page":"Private API","title":"Boundary conditions","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.update_BC_data!","category":"page"},{"location":"private/#AeroBeams.update_BC_data!","page":"Private API","title":"AeroBeams.update_BC_data!","text":"updateBCdata!(bc::BC,timeNow::Number=0)\n\nUpdates the boundary conditions at the current time\n\n\n\n\n\n","category":"function"},{"location":"private/#Beam","page":"Private API","title":"Beam","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.validate_beam!\nAeroBeams.validate_sectional_matrices\nAeroBeams.validate_rotation_parametrization\nAeroBeams.validate_connected_beams\nAeroBeams.validate_initial_conditions!\nAeroBeams.validate_normalized_nodal_positions!\nAeroBeams.validate_hinged_nodes!\nAeroBeams.validate_distributed_loads!\nAeroBeams.velocity_dofs_to_update!\nAeroBeams.get_rotation_tensor!\nAeroBeams.initial_displacements_derivatives!\nAeroBeams.create_beam_elements!\nAeroBeams.set_nodal_coordinates!","category":"page"},{"location":"private/#AeroBeams.validate_beam!","page":"Private API","title":"AeroBeams.validate_beam!","text":"validate_beam!(beam::Beam)\n\nValidates the beam inputs\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_sectional_matrices","page":"Private API","title":"AeroBeams.validate_sectional_matrices","text":"validatesectionalmatrices(beam::Beam)\n\nChecks that sectional matrices are input as a single one for the whole beam or are input in a per element basis \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_rotation_parametrization","page":"Private API","title":"AeroBeams.validate_rotation_parametrization","text":"validaterotationparametrization(beam::Beam)\n\nValidates the input rotation parameters and rotation parametrization\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_connected_beams","page":"Private API","title":"AeroBeams.validate_connected_beams","text":"validateconnectedbeams(beam::Beam)\n\nChecks that the beam connections are consistent\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_initial_conditions!","page":"Private API","title":"AeroBeams.validate_initial_conditions!","text":"validateinitialconditions!(beam::Beam)\n\nValidate initial generalized displacements/velocities defined in basis b, and transform to function if input as constant vector\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_normalized_nodal_positions!","page":"Private API","title":"AeroBeams.validate_normalized_nodal_positions!","text":"validatenormalizednodal_positions!(beam::Beam)\n\nValidates the normalized nodal positions if they were input, or updates them if they were not\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_hinged_nodes!","page":"Private API","title":"AeroBeams.validate_hinged_nodes!","text":"validatehingednodes!(beam::Beam)\n\nValidates the hinged nodes and DoFs\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_distributed_loads!","page":"Private API","title":"AeroBeams.validate_distributed_loads!","text":"validatedistributedloads!(beam::Beam)\n\nValidates and updates the distributed loads\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.velocity_dofs_to_update!","page":"Private API","title":"AeroBeams.velocity_dofs_to_update!","text":"velocitydofsto_update!(beam::Beam)\n\nGets the velocity DOFs (V and Ω) to be updated on the initial dynamic solution\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_rotation_tensor!","page":"Private API","title":"AeroBeams.get_rotation_tensor!","text":"getrotationtensor!(beam::Beam)\n\nValidates the input rotation parameters and rotation parametrization, and gets the corresponding rotation tensor from basis A to basis b \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initial_displacements_derivatives!","page":"Private API","title":"AeroBeams.initial_displacements_derivatives!","text":"initialdisplacementsderivatives!(beam::Beam)\n\nComputes the derivatives of the initial generalized displacements with respect to the beam arclength coordinate, x₁\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.create_beam_elements!","page":"Private API","title":"AeroBeams.create_beam_elements!","text":"createbeamelements!(beam::Beam)\n\nInitializes the element and node ranges, and creates beam elements\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.set_nodal_coordinates!","page":"Private API","title":"AeroBeams.set_nodal_coordinates!","text":"setnodalcoordinates!(beam::Beam)\n\nSets the nodal coordinates of each element into the beam\n\n\n\n\n\n","category":"function"},{"location":"private/#Core","page":"Private API","title":"Core","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.element_arrays!\nAeroBeams.special_node_arrays!\nAeroBeams.element_velocities_basis_b!\nAeroBeams.element_accelerations_basis_b!\nAeroBeams.element_states!\nAeroBeams.element_states_rates!\nAeroBeams.element_rotation_variables!\nAeroBeams.element_distributed_loads!\nAeroBeams.gravitational_loads!\nAeroBeams.distributed_external_loads!\nAeroBeams.aerodynamic_loads!\nAeroBeams.wrapper_aerodynamic_loads_from_states!\nAeroBeams.wrapper_aerodynamic_loads_from_states_rates!\nAeroBeams.aero_loads_core!\nAeroBeams.interpolate_distributed_loads\nAeroBeams.element_strains!\nAeroBeams.element_momenta!\nAeroBeams.element_momenta_rates!\nAeroBeams.element_residual!\nAeroBeams.distributed_loads_derivatives_rotation_parameters!\nAeroBeams.gravitational_loads_derivatives_rotation_parameters\nAeroBeams.distributed_external_loads_derivatives_rotation_parameters\nAeroBeams.aero_loads_derivatives_rotation_parameters\nAeroBeams.aero_derivatives!\nAeroBeams.element_jacobian!\nAeroBeams.element_inertia!\nAeroBeams.element_nodal_states!\nAeroBeams.special_node_states!\nAeroBeams.spring_loads!\nAeroBeams.special_node_residual!\nAeroBeams.special_node_follower_loads_derivatives_rotation_parameters!\nAeroBeams.special_node_jacobian!\nAeroBeams.update_special_node_jacobian!\nAeroBeams.spring_loads_jacobians!\nAeroBeams.element_modal_states\nAeroBeams.update_states!\nAeroBeams.reset_dual_numbers\nAeroBeams.convert_to_values","category":"page"},{"location":"private/#AeroBeams.element_arrays!","page":"Private API","title":"AeroBeams.element_arrays!","text":"element_arrays!(problem::Problem,model::Model,element::Element)\n\nComputes the elemental contributions to the system's arrays (residual, Jacobian, inertia)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.special_node_arrays!","page":"Private API","title":"AeroBeams.special_node_arrays!","text":"specialnodearrays!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the nodal contributions to the system's arrays (residual, Jacobian, inertia)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_velocities_basis_b!","page":"Private API","title":"AeroBeams.element_velocities_basis_b!","text":"elementvelocitiesbasis_b!(model::Model,element::Element,σ::Float64=1.0,timeNow::Number=0.0)\n\nComputes the generalized velocities of basis b at the element's midpoint, resolved in basis A\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_accelerations_basis_b!","page":"Private API","title":"AeroBeams.element_accelerations_basis_b!","text":"elementaccelerationsbasis_b!(model::Model,element::Element,σ::Float64=1.0,timeNow::Number=0.0)\n\nComputes the generalized accelerations of basis b at the element's midpoint, resolved in basis A\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_states!","page":"Private API","title":"AeroBeams.element_states!","text":"element_states!(problem::Problem,model::Model,element::Element)\n\nGets the states (generalized displacements, forces, velocities and aerodynamic) of the element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_states_rates!","page":"Private API","title":"AeroBeams.element_states_rates!","text":"elementstatesrates!(problem::Problem,element::Element)\n\nComputes the states' rates of the current element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_rotation_variables!","page":"Private API","title":"AeroBeams.element_rotation_variables!","text":"elementrotationvariables!(problem::Problem,element::Element)\n\nComputes the rotation variables for the current element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_distributed_loads!","page":"Private API","title":"AeroBeams.element_distributed_loads!","text":"elementdistributedloads!(problem::Problem,model::Model,element::Element)\n\nComputes the nodal resultants from distributed loads on the current element, resolved in basis A\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.gravitational_loads!","page":"Private API","title":"AeroBeams.gravitational_loads!","text":"gravitational_loads!(model::Model,element::Element,σ::Float64)\n\nComputes the nodal resultants from the distributed gravitational loads on the current element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.distributed_external_loads!","page":"Private API","title":"AeroBeams.distributed_external_loads!","text":"distributedexternalloads!(problem::Problem,element::Element,σ::Float64)\n\nComputes the nodal resultants from the externally applied distributed loads on the current element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aerodynamic_loads!","page":"Private API","title":"AeroBeams.aerodynamic_loads!","text":"aerodynamic_loads!(problem::Problem,model::Model,element::Element)\n\nComputes the nodal resultants from the aerodynamic loads on the current element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.wrapper_aerodynamic_loads_from_states!","page":"Private API","title":"AeroBeams.wrapper_aerodynamic_loads_from_states!","text":"wrapperaerodynamicloadsfromstates!(states,problem::Problem,model::Model,element::Element)\n\nWrapper function for aerodynamic loads using elemental states as inputs\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.wrapper_aerodynamic_loads_from_states_rates!","page":"Private API","title":"AeroBeams.wrapper_aerodynamic_loads_from_states_rates!","text":"wrapperaerodynamicloadsfromstates_rates!(statesRates,problem::Problem,model::Model,element::Element)\n\nWrapper function for aerodynamic loads using elemental states' rates as inputs\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_loads_core!","page":"Private API","title":"AeroBeams.aero_loads_core!","text":"aeroloadscore!(problem::Problem,model::Model,element::Element,V,Ω,χ,Vdot,Ωdot,δNow)\n\nComputes the nodal resutants from aerodynamic loads and aerodynamic state matrices\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.interpolate_distributed_loads","page":"Private API","title":"AeroBeams.interpolate_distributed_loads","text":"interpolatedistributedloads(problem::Problem,loadArray::Array{Float64})\n\nInterpolates the loads array at the current time\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_strains!","page":"Private API","title":"AeroBeams.element_strains!","text":"element_strains!(element::Element)\n\nComputes the strains for the current element, resolved in basis B\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_momenta!","page":"Private API","title":"AeroBeams.element_momenta!","text":"element_momenta!(element::Element)\n\nComputes the momenta for the current element, resolved in basis B\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_momenta_rates!","page":"Private API","title":"AeroBeams.element_momenta_rates!","text":"elementmomentarates!(element::Element)\n\nComputes the momenta rates for the current element, resolved in basis B\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_residual!","page":"Private API","title":"AeroBeams.element_residual!","text":"element_residual!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the residual array\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.distributed_loads_derivatives_rotation_parameters!","page":"Private API","title":"AeroBeams.distributed_loads_derivatives_rotation_parameters!","text":"distributedloadsderivativesrotationparameters!(element::Element)\n\nComputes the derivatives of the distributed loads w.r.t the rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.gravitational_loads_derivatives_rotation_parameters","page":"Private API","title":"AeroBeams.gravitational_loads_derivatives_rotation_parameters","text":"gravitationalloadsderivativesrotationparameters(element::Element)\n\nComputes the contributions of the gravitational loads to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.distributed_external_loads_derivatives_rotation_parameters","page":"Private API","title":"AeroBeams.distributed_external_loads_derivatives_rotation_parameters","text":"distributedexternalloadsderivativesrotation_parameters(element::Element)\n\nComputes the contributions of the externally applied distributed loads to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_loads_derivatives_rotation_parameters","page":"Private API","title":"AeroBeams.aero_loads_derivatives_rotation_parameters","text":"aeroloadsderivativesrotationparameters(element::Element)\n\nComputes the derivatives of the aerodynamic loads w.r.t the extended rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.aero_derivatives!","page":"Private API","title":"AeroBeams.aero_derivatives!","text":"aero_derivatives!(problem::Problem,model::Model,element::Element)\n\nComputes the derivatives of the aerodynamic loads and aerodynamic states w.r.t remaining elemental states and their rates (excludes rotation parameters, already computed)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_jacobian!","page":"Private API","title":"AeroBeams.element_jacobian!","text":"element_jacobian!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_inertia!","page":"Private API","title":"AeroBeams.element_inertia!","text":"element_inertia!(problem::Problem,model::Model,element::Element)\n\nComputes the contributions from the current element to the inertia matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_nodal_states!","page":"Private API","title":"AeroBeams.element_nodal_states!","text":"elementnodalstates!(element::Element)\n\nUpdates the nodal states of the element\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.special_node_states!","page":"Private API","title":"AeroBeams.special_node_states!","text":"specialnodestates!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the nodal states\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.spring_loads!","page":"Private API","title":"AeroBeams.spring_loads!","text":"spring_loads!(model::Model,specialNode::SpecialNode)\n\nAdds the contributions of attached springs to the special node's loads\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.special_node_residual!","page":"Private API","title":"AeroBeams.special_node_residual!","text":"specialnoderesidual!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the contributions from the current node to the residual array\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.special_node_follower_loads_derivatives_rotation_parameters!","page":"Private API","title":"AeroBeams.special_node_follower_loads_derivatives_rotation_parameters!","text":"specialnodefollowerloadsderivativesrotationparameters!(problem::Problem,specialNode::SpecialNode)\n\nComputes the contributions from the nodal follower loads to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.special_node_jacobian!","page":"Private API","title":"AeroBeams.special_node_jacobian!","text":"specialnodejacobian!(problem::Problem,model::Model,specialNode::SpecialNode)\n\nComputes the contributions from the current node to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_special_node_jacobian!","page":"Private API","title":"AeroBeams.update_special_node_jacobian!","text":"updatespecialnodejacobian!(jacobian,forceScaling,Fp,Mp,ζonElements,eqsFu,eqsFp,eqsFF,eqsFM,eqsFFsep,eqsFMsep,DOFuF,DOFpM,DOFtrimLoads,uIsPrescribed,pIsPrescribed,isLoad=trues(6),isTrim=falses(6))\n\nUpdates the Jacobian matrix with the contributions from the current BC (if any) on the current node \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.spring_loads_jacobians!","page":"Private API","title":"AeroBeams.spring_loads_jacobians!","text":"springloadsjacobians!(model,jacobian,forceScaling,globalID,eqsFu,eqsFp,DOFuF,DOFpM,springs)\n\nAdds the contributions of the spring loads to the Jacobian matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.element_modal_states","page":"Private API","title":"AeroBeams.element_modal_states","text":"elementmodalstates(element::Element,eigenvector::Vector{T},forceScaling::Float64)\n\nComputes the modal states (generalized displacements, forces, strains, velocities and momenta) of the element at midpoint and at the nodes\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_states!","page":"Private API","title":"AeroBeams.update_states!","text":"update_states!(problem::Problem)\n\nUpdates the elemental and nodal states\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.reset_dual_numbers","page":"Private API","title":"AeroBeams.reset_dual_numbers","text":"resetdualnumbers(obj)\n\nResets dual numbers from the ForwardDiff package back into their values\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.convert_to_values","page":"Private API","title":"AeroBeams.convert_to_values","text":"converttovalues(arr)\n\nFunctional unit of resetdualnumbers()\n\n\n\n\n\n","category":"function"},{"location":"private/#Element","page":"Private API","title":"Element","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.ElementalStates\nAeroBeams.ComplementaryElementalStates\nAeroBeams.ElementalStatesRates\nAeroBeams.ComplementaryElementalStatesRates\nAeroBeams.NodalStates\nAeroBeams.Element\nAeroBeams.get_hinged_nodes_matrices\nAeroBeams.get_element_distributed_loads\nAeroBeams.update_element_distributed_loads!\nAeroBeams.add_point_inertia_to_element!","category":"page"},{"location":"private/#AeroBeams.ElementalStates","page":"Private API","title":"AeroBeams.ElementalStates","text":"mutable struct ElementalStates\n\nElementalStates composite type\n\nFields\n\nu::Vector{T} = displacements resolved in basis A\np::Vector{T} = rotation parameters resolved in basis A\nF::Vector{T} = sectional forces resolved in basis B\nM::Vector{T} = sectional moments resolved in basis B\nV::Vector{T} = sectional velocities resolved in basis B\nΩ::Vector{T} = sectional angular velocities resolved in basis B\nχ::Vector{T} = aerodynamic states\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.ComplementaryElementalStates","page":"Private API","title":"AeroBeams.ComplementaryElementalStates","text":"mutable struct ComplementaryElementalStates\n\nComplementaryElementalStates composite type\n\nFields\n\nγ::Vector{T} = force strains resolved in basis b\nκ::Vector{T} = moment strains resolved in basis b\nP::Vector{T} = linear momenta resolved in basis B\nH::Vector{T} = angular momenta resolved in basis B\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.ElementalStatesRates","page":"Private API","title":"AeroBeams.ElementalStatesRates","text":"mutable struct ElementalStatesRates\n\nElementalStatesRates composite type\n\nFields\n\nudot::Vector{Float64} = displacements derivatives\npdot::Vector{Float64} = rotation parameters derivatives\nVdot::Vector{Float64} = sectional velocities derivatives\nΩdot::Vector{Float64} = sectional angular velocities derivatives\nχdot::Vector{Float64} = aerodynamic states derivatives\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.ComplementaryElementalStatesRates","page":"Private API","title":"AeroBeams.ComplementaryElementalStatesRates","text":"mutable struct ComplementaryElementalStatesRates\n\nComplementaryElementalStatesRates composite type\n\nFields\n\nPdot::Vector{Float64} = linear momenta derivatives\nHdot::Vector{Float64} = angular momenta derivatives\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.NodalStates","page":"Private API","title":"AeroBeams.NodalStates","text":"mutable struct NodalStates\n\nNodalStates composite type\n\nFields\n\nu_n1::Vector{T} = displacements of node 1 resolved in basis A\nu_n2::Vector{T} = displacements of node 2 resolved in basis A\np_n1::Vector{T} = rotation parameters of node 1 resolved in basis A\np_n2::Vector{T} = rotation parameters of node 2 resolved in basis A\nu_n1_b::Vector{T} = displacements of node 1 resolved in basis b\nu_n2_b::Vector{T} = displacements of node 2 resolved in basis b\np_n1_b::Vector{T} = rotation parameters of node 1 resolved in basis b\np_n2_b::Vector{T} = rotation parameters of node 2 resolved in basis b\nF_n1::Vector{T} = sectional forces of node 1 resolved in basis B\nF_n2::Vector{T} = sectional forces of node 2 resolved in basis B\nM_n1::Vector{T} = sectional moments of node 1 resolved in basis B\nM_n2::Vector{T} = sectional moments of node 2 resolved in basis B\nθ_n1::T = rotation angle of node 1\nθ_n2::T = rotation angle of node 2\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.Element","page":"Private API","title":"AeroBeams.Element","text":"mutable struct Element <: BeamElement\n\nElement composite type\n\nNotes\n\nFinite elements belong to a Beam\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.get_hinged_nodes_matrices","page":"Private API","title":"AeroBeams.get_hinged_nodes_matrices","text":"gethingednodes_matrices(parent::Beam,nodesLocalID::Vector{Int64})\n\nGets the TF matrices resulting from hinged and not hinged nodal DoFs times the identity matrix\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_element_distributed_loads","page":"Private API","title":"AeroBeams.get_element_distributed_loads","text":"getelementdistributedloads(parent::Beam,Δℓ::Number,x1n1::Number)\n\nGets the distributed loads in the element's local coordinate\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_element_distributed_loads!","page":"Private API","title":"AeroBeams.update_element_distributed_loads!","text":"updateelementdistributed_loads!(element::Element,loadType::String,loadFun::Function)\n\nUpdate the distributed loads in the element's local coordinate\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.add_point_inertia_to_element!","page":"Private API","title":"AeroBeams.add_point_inertia_to_element!","text":"addpointinertiatoelement!(element::Element,pointInertia::PointInertia)\n\nAdds the point inertia's matrix to the element's sectional inertia matrix\n\nArguments\n\nelement::Element\npointInertia::PointInertia\n\n\n\n\n\n","category":"function"},{"location":"private/#Gust","page":"Private API","title":"Gust","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.SharpEdgedGust\nAeroBeams.OneMinusCosineGust\nAeroBeams.Continuous1DGust\nAeroBeams.DiscreteSpaceGust\nAeroBeams.Continuous1DSpaceGust\nAeroBeams.Continuous2DSpaceGust\nAeroBeams.stochastic_gust_velocity_from_white_noise","category":"page"},{"location":"private/#AeroBeams.SharpEdgedGust","page":"Private API","title":"AeroBeams.SharpEdgedGust","text":"@with_kw mutable struct SharpEdgedGust <: Gust\n\nSharpEdgedGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.OneMinusCosineGust","page":"Private API","title":"AeroBeams.OneMinusCosineGust","text":"@with_kw mutable struct OneMinusCosineGust <: Gust\n\nOneMinusCosineGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.Continuous1DGust","page":"Private API","title":"AeroBeams.Continuous1DGust","text":"@with_kw mutable struct Continuous1DGust <: Gust\n\nContinuous1DGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.DiscreteSpaceGust","page":"Private API","title":"AeroBeams.DiscreteSpaceGust","text":"@with_kw mutable struct DiscreteSpaceGust <: Gust\n\nDiscreteSpaceGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.Continuous1DSpaceGust","page":"Private API","title":"AeroBeams.Continuous1DSpaceGust","text":"@with_kw mutable struct Continuous1DSpaceGust <: Gust\n\nContinuous1DSpaceGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.Continuous2DSpaceGust","page":"Private API","title":"AeroBeams.Continuous2DSpaceGust","text":"@with_kw mutable struct Continuous2DSpaceGust <: Gust\n\nContinuousSpaceGust composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.stochastic_gust_velocity_from_white_noise","page":"Private API","title":"AeroBeams.stochastic_gust_velocity_from_white_noise","text":"stochasticgustvelocityfromwhite_noise(spectrum::String,t::Vector{<:Number},U::Number,L::Number=762,σ::Number=1)\n\nComputes a stochastic gust velocity array by coloring a white noise signal with the appropriate spectrum\n\n\n\n\n\n","category":"function"},{"location":"private/#Links","page":"Private API","title":"Links","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.TrimLoadsLink\nAeroBeams.FlapLink","category":"page"},{"location":"private/#AeroBeams.TrimLoadsLink","page":"Private API","title":"AeroBeams.TrimLoadsLink","text":"@with_kw mutable struct TrimLoadsLink\n\nTrimLoadsLink composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.FlapLink","page":"Private API","title":"AeroBeams.FlapLink","text":"@with_kw mutable struct FlapLink\n\nFlapLink composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#Model","page":"Private API","title":"Model","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.Model\nAeroBeams.validate_model!\nAeroBeams.validate_and_update_motion_basis_A!\nAeroBeams.assemble_model!\nAeroBeams.inertia_properties!\nAeroBeams.set_atmosphere!\nAeroBeams.update_linked_flap_deflections!\nAeroBeams.update_number_gust_states!\nAeroBeams.update_loads_trim_links_global_ids!\nAeroBeams.update_spring_nodes_ids!\nAeroBeams.update_relative_rotation_constraint_elements_ids!\nAeroBeams.initialize_basis_A_rotation!\nAeroBeams.update_initial_conditions!\nAeroBeams.set_BCs!\nAeroBeams.get_special_nodes!\nAeroBeams.get_system_indices!\nAeroBeams.update_relative_rotation_constraint_data!","category":"page"},{"location":"private/#AeroBeams.Model","page":"Private API","title":"AeroBeams.Model","text":"@with_kw mutable struct Model\n\nModel composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.validate_model!","page":"Private API","title":"AeroBeams.validate_model!","text":"validate_model!(model::Model)\n\nValidates the inputs to the model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.validate_and_update_motion_basis_A!","page":"Private API","title":"AeroBeams.validate_and_update_motion_basis_A!","text":"validateandupdatemotionbasis_A!(model::Model)\n\nValidates and updates the motion variables of basis A\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.assemble_model!","page":"Private API","title":"AeroBeams.assemble_model!","text":"assemble_model!(model::Model,beams::Vector{Beam})\n\nLoads the assembly of beams into the model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.inertia_properties!","page":"Private API","title":"AeroBeams.inertia_properties!","text":"inertia_properties!(model::Model)\n\nComputes the inertia properties of the undeformed assembly\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.set_atmosphere!","page":"Private API","title":"AeroBeams.set_atmosphere!","text":"set_atmosphere!(model::Model)\n\nSets the atmosphere data\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_linked_flap_deflections!","page":"Private API","title":"AeroBeams.update_linked_flap_deflections!","text":"updatelinkedflap_deflections!(model::Model)\n\nUpdates the linked flap deflections for the slave beams\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_number_gust_states!","page":"Private API","title":"AeroBeams.update_number_gust_states!","text":"updatenumbergust_states!(model::Model)\n\nUpdates the number of gust states in every element with aerodynamic surface\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_loads_trim_links_global_ids!","page":"Private API","title":"AeroBeams.update_loads_trim_links_global_ids!","text":"updateloadstrimlinksglobal_ids!(model::Model)\n\nUpdates the nodes' global IDs of the loads trim links\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_spring_nodes_ids!","page":"Private API","title":"AeroBeams.update_spring_nodes_ids!","text":"updatespringnodes_ids!(model::Model)\n\nUpdates the global IDs of the springs' nodes, the list of springed nodes and the list of springs on nodes\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_relative_rotation_constraint_elements_ids!","page":"Private API","title":"AeroBeams.update_relative_rotation_constraint_elements_ids!","text":"updaterelativerotationconstraintelements_ids!(model::Model)\n\nUpdates the global IDs of the elements with relative rotation constraints\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initialize_basis_A_rotation!","page":"Private API","title":"AeroBeams.initialize_basis_A_rotation!","text":"initializebasisA_rotation!(model::Model)\n\nInitializes the rotation tensor from basis I (fixed, inertial) to basis A, and its transpose\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_initial_conditions!","page":"Private API","title":"AeroBeams.update_initial_conditions!","text":"updateinitialconditions!(model::Model)\n\nUpdates the initial condition states on all elements of the assembly\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.set_BCs!","page":"Private API","title":"AeroBeams.set_BCs!","text":"set_BCs!(model::Model)\n\nSets the BCs onto the model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_special_nodes!","page":"Private API","title":"AeroBeams.get_special_nodes!","text":"getspecialnodes!(model::Model)\n\nGets the special nodes in the system of equations: connection, boundary, and BC'ed nodes\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_system_indices!","page":"Private API","title":"AeroBeams.get_system_indices!","text":"getsystemindices!(model::Model)\n\nGets the indices (for equations and DOFs) of the system of equations\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_relative_rotation_constraint_data!","page":"Private API","title":"AeroBeams.update_relative_rotation_constraint_data!","text":"updaterelativerotationconstraintdata!(model::Model)\n\nUpdates the aggregate data of relative rotation constraints\n\n\n\n\n\n","category":"function"},{"location":"private/#Problem","page":"Private API","title":"Problem","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.Problem\nAeroBeams.ModeShape\nAeroBeams.set_initial_states!\nAeroBeams.initialize_system_arrays!\nAeroBeams.precompute_distributed_loads!\nAeroBeams.solve_steady!\nAeroBeams.get_mode_shapes!\nAeroBeams.fix_nodal_modal_states!\nAeroBeams.solve_dynamic!\nAeroBeams.initialize_time_variables!\nAeroBeams.solve_initial_dynamic!\nAeroBeams.copy_initial_states!\nAeroBeams.update_initial_velocities!\nAeroBeams.time_march!\nAeroBeams.adaptable_time_march!\nAeroBeams.copy_state\nAeroBeams.restore_state!\nAeroBeams.update_time_variables!\nAeroBeams.update_basis_A_orientation!\nAeroBeams.get_equivalent_states_rates!\nAeroBeams.update_BL_complementary_variables!\nAeroBeams.BL_stall_boundary\nAeroBeams.solve_time_step!\nAeroBeams.save_time_step_data!","category":"page"},{"location":"private/#AeroBeams.Problem","page":"Private API","title":"AeroBeams.Problem","text":"abstract type Problem\n\nDefines a general Problem type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.ModeShape","page":"Private API","title":"AeroBeams.ModeShape","text":"mutable struct ModeShape{T<:Union{Float64,ComplexF64}}\n\nModeShape composite type\n\n\n\n\n\n","category":"type"},{"location":"private/#AeroBeams.set_initial_states!","page":"Private API","title":"AeroBeams.set_initial_states!","text":"setinitialstates!(problem::Problem)\n\nSets the initial elemental and nodal states into the states array\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initialize_system_arrays!","page":"Private API","title":"AeroBeams.initialize_system_arrays!","text":"initializesystemarrays!(problem::Problem)\n\nInitializes the system arrays to the correct size\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.precompute_distributed_loads!","page":"Private API","title":"AeroBeams.precompute_distributed_loads!","text":"precomputedistributedloads!(problem::Problem)\n\nPre-computes the distributed loads over all elements' nodes, over every time step\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.solve_steady!","page":"Private API","title":"AeroBeams.solve_steady!","text":"solve_steady!(problem::Problem)\n\nSolves a steady problem (includes trim and the steady part of eigen problems) \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_mode_shapes!","page":"Private API","title":"AeroBeams.get_mode_shapes!","text":"getmodeshapes!(problem::Problem,eigenvectors::Matrix{T},frequencies::Vector{Float64},dampings::Vector{Float64})\n\nGets the mode shapes given by the eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.fix_nodal_modal_states!","page":"Private API","title":"AeroBeams.fix_nodal_modal_states!","text":"fixnodalmodal_states!(problem::Problem)\n\nCorrects the nodal modal states which may not coincide depending on which element is considered\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.solve_dynamic!","page":"Private API","title":"AeroBeams.solve_dynamic!","text":"solve_dynamic!(problem::Problem)\n\nSolves a dynamic problem \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.initialize_time_variables!","page":"Private API","title":"AeroBeams.initialize_time_variables!","text":"initializetimevariables!(problem::Problem)\n\nValidates and initializes the time variables\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.solve_initial_dynamic!","page":"Private API","title":"AeroBeams.solve_initial_dynamic!","text":"solveinitialdynamic!(problem::Problem)\n\nGets consistent initial conditions and solves the first time step\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.copy_initial_states!","page":"Private API","title":"AeroBeams.copy_initial_states!","text":"copyinitialstates!(problem::Problem,problemCopy::Problem)\n\nCopies the initial states to the original problem\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_initial_velocities!","page":"Private API","title":"AeroBeams.update_initial_velocities!","text":"updateinitialvelocities!(problem::Problem)\n\nUpdates the velocity states by running a very small time step\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.time_march!","page":"Private API","title":"AeroBeams.time_march!","text":"time_march!(problem::Problem)\n\nMarches the dynamic problem in time\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.adaptable_time_march!","page":"Private API","title":"AeroBeams.adaptable_time_march!","text":"adaptabletimemarch!(problem::Problem)\n\nMarches the dynamic problem in time using an adaptable time step\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.copy_state","page":"Private API","title":"AeroBeams.copy_state","text":"copy_state(problem::Problem)\n\nCopies the current state of the problem\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.restore_state!","page":"Private API","title":"AeroBeams.restore_state!","text":"restore_state!(problem::Problem)\n\nRestores the state of the problem\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_time_variables!","page":"Private API","title":"AeroBeams.update_time_variables!","text":"updatetimevariables!(problem::Problem,timeIndex::Int64)\n\nUpdates the time variables (time, time step, time indices)\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_basis_A_orientation!","page":"Private API","title":"AeroBeams.update_basis_A_orientation!","text":"updatebasisAorientation!(problem::Problem,updateRAarray::Bool=true)\n\nUpdates the orientation of the basis A for the next time step\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.get_equivalent_states_rates!","page":"Private API","title":"AeroBeams.get_equivalent_states_rates!","text":"getequivalentstates_rates!(problem::Problem)\n\nGets the equivalent states' rates at the begin of the current time step \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.update_BL_complementary_variables!","page":"Private API","title":"AeroBeams.update_BL_complementary_variables!","text":"updateBLcomplementary_variables!(problem::Problem)\n\nUpdates the complementary variables of previous time step for the dynamic stall models\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.BL_stall_boundary","page":"Private API","title":"AeroBeams.BL_stall_boundary","text":"checkBLstall_boundary!(problem::Problem)\n\nComputes the maximum stall boundary value over all beam elements in the Beddoes-Leishman model\n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.solve_time_step!","page":"Private API","title":"AeroBeams.solve_time_step!","text":"solvetimestep!(problem::Problem)\n\nSolves the current time step  \n\n\n\n\n\n","category":"function"},{"location":"private/#AeroBeams.save_time_step_data!","page":"Private API","title":"AeroBeams.save_time_step_data!","text":"savetimestep_data!(problem::Problem,timeNow::Number)\n\nSaves the solution at the current time step\n\n\n\n\n\n","category":"function"},{"location":"private/#Rotation-constraint","page":"Private API","title":"Rotation constraint","text":"","category":"section"},{"location":"private/","page":"Private API","title":"Private API","text":"AeroBeams.RotationConstraint","category":"page"},{"location":"private/#AeroBeams.RotationConstraint","page":"Private API","title":"AeroBeams.RotationConstraint","text":"@with_kw mutable struct RotationConstraint\n\nRotationConstraint composite type\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#Sample-models","page":"Private API (cont'd)","title":"Sample models","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.Pazy_nodal_positions\nAeroBeams.Pazy_stiffness_matrices\nAeroBeams.Pazy_inertia_matrices","category":"page"},{"location":"privatecont/#AeroBeams.Pazy_nodal_positions","page":"Private API (cont'd)","title":"AeroBeams.Pazy_nodal_positions","text":"Pazynodalpositions()\n\nGets the normalized nodal positions of the Pazy wing\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.Pazy_stiffness_matrices","page":"Private API (cont'd)","title":"AeroBeams.Pazy_stiffness_matrices","text":"Pazystiffnessmatrices(GAy::Number,GAz::Number)\n\nGets the sectional stiffness matrices of the Pazy wing\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.Pazy_inertia_matrices","page":"Private API (cont'd)","title":"AeroBeams.Pazy_inertia_matrices","text":"Pazyinertiamatrices()\n\nGets the sectional inertia matrices of the Pazy wing\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#Special-node","page":"Private API (cont'd)","title":"Special node","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.SpecialNode","category":"page"},{"location":"privatecont/#AeroBeams.SpecialNode","page":"Private API (cont'd)","title":"AeroBeams.SpecialNode","text":"SpecialNode(localID::Int64,globalID::Int64,connectedElementsGlobalIDs::Vector{Int64},connectedElements::Vector{Element},ζonElements::Vector{Int64},springs::Vector{Spring}=Vector{Spring}(),BCs::Vector{BC}=Vector{BC}())\n\nCreates a special node\n\nArguments\n\nlocalID::Int64 = local ID of the node\nglobalID::Int64 = global ID of the node\nconnectedElementsGlobalIDs::Vector{Int64} = global IDs of the connected elements\nconnectedElements::Vector{Element} = connected elements\nζonElements::Vector{Int64} = local coordinate on parent element\nsprings::Vector{Spring} = attached springs\nBCs::Vector{BC} = associated boundary condtions\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#Spring","page":"Private API (cont'd)","title":"Spring","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.Spring","category":"page"},{"location":"privatecont/#AeroBeams.Spring","page":"Private API (cont'd)","title":"AeroBeams.Spring","text":"@with_kw mutable struct Spring\n\nSpring composite type\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#System-solver","page":"Private API (cont'd)","title":"System solver","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.SystemSolver\nAeroBeams.NewtonRaphson\nAeroBeams.solve_NewtonRaphson!\nAeroBeams.assemble_system_arrays!\nAeroBeams.solve_linear_system!\nAeroBeams.line_search\nAeroBeams.line_search_step_size\nAeroBeams.save_load_factor_data!\nAeroBeams.update_maximum_aero_loads!","category":"page"},{"location":"privatecont/#AeroBeams.SystemSolver","page":"Private API (cont'd)","title":"AeroBeams.SystemSolver","text":"abstract type SystemSolver\n\nDefines a general problem for the system of equations\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#AeroBeams.NewtonRaphson","page":"Private API (cont'd)","title":"AeroBeams.NewtonRaphson","text":"@with_kw mutable struct NewtonRaphson <: SystemSolver\n\nNewton-Raphson system solver composite type\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#AeroBeams.solve_NewtonRaphson!","page":"Private API (cont'd)","title":"AeroBeams.solve_NewtonRaphson!","text":"solve_NewtonRaphson!(problem::Problem)\n\nSolves the nonlinear system of equations at current time step \n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.assemble_system_arrays!","page":"Private API (cont'd)","title":"AeroBeams.assemble_system_arrays!","text":"assemblesystemarrays!(problem::Problem,x::Vector{Float64}=problem.x)\n\nAssembles the residual vector, Jacobian and inertia matrices of the system of equations\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.solve_linear_system!","page":"Private API (cont'd)","title":"AeroBeams.solve_linear_system!","text":"solvelinearsystem!(problem::Problem)\n\nSolves the linear system of equations at current time step and load factor\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.line_search","page":"Private API (cont'd)","title":"AeroBeams.line_search","text":"line_search(x,residual,jacobian,λ=1e-8)\n\nPerforms a line search to solve the current Newton step\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.line_search_step_size","page":"Private API (cont'd)","title":"AeroBeams.line_search_step_size","text":"linesearchstep_size(x,p,residual,jacobian,c1=1e-4,ρ=0.5)\n\nUpdates the step size (α) of the line search\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.save_load_factor_data!","page":"Private API (cont'd)","title":"AeroBeams.save_load_factor_data!","text":"saveloadfactor_data!(problem::Problem,σ::Float64,x::Vector{Float64})\n\nSaves the solution at the current load factor\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.update_maximum_aero_loads!","page":"Private API (cont'd)","title":"AeroBeams.update_maximum_aero_loads!","text":"updatemaximumaero_loads!(problem::Problem)\n\nUpdates the maximum absolute values of aerodynamic loads\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#Units-system","page":"Private API (cont'd)","title":"Units system","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.UnitsSystem\nAeroBeams.validate_units_system","category":"page"},{"location":"privatecont/#AeroBeams.UnitsSystem","page":"Private API (cont'd)","title":"AeroBeams.UnitsSystem","text":"@with_kw mutable struct UnitsSystem \n\nUnitsSystem composite type\n\n\n\n\n\n","category":"type"},{"location":"privatecont/#AeroBeams.validate_units_system","page":"Private API (cont'd)","title":"AeroBeams.validate_units_system","text":"validateunitssystem(units::UnitsSystem)\n\nValidates the units system\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#Utilities","page":"Private API (cont'd)","title":"Utilities","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.a1\nAeroBeams.a2\nAeroBeams.a3\nAeroBeams.I3\nAeroBeams.I6\nAeroBeams.divide_inplace!\nAeroBeams.multiply_inplace!\nAeroBeams.curvature_quantities\nAeroBeams.position_vector_from_curvature\nAeroBeams.rotation_tensor_from_curvature\nAeroBeams.rotation_parameter_scaling\nAeroBeams.rotation_tensor_derivatives_scaled_parameters\nAeroBeams.scaling_derivatives_extended_parameters\nAeroBeams.rotation_tensor_derivatives_extended_parameters\nAeroBeams.rotation_tensor_time_derivative\nAeroBeams.rotation_tensor_derivatives_time_extended_parameters\nAeroBeams.tangent_operator_transpose_inverse_WM\nAeroBeams.tangent_tensor_functions_derivatives_extended_parameters\nAeroBeams.force_scaling\nAeroBeams.rotation_angle\nAeroBeams.highest_in_rowcol","category":"page"},{"location":"privatecont/#AeroBeams.a1","page":"Private API (cont'd)","title":"AeroBeams.a1","text":"const a1 = [1.0; 0.0; 0.0]\n\nFirst vector of basis A, resolved in that basis\n\n\n\n\n\n","category":"constant"},{"location":"privatecont/#AeroBeams.a2","page":"Private API (cont'd)","title":"AeroBeams.a2","text":"const a2 = [0.0; 1.0; 0.0]\n\nSecond vector of basis A, resolved in that basis\n\n\n\n\n\n","category":"constant"},{"location":"privatecont/#AeroBeams.a3","page":"Private API (cont'd)","title":"AeroBeams.a3","text":"const a3 = [0.0; 0.0; 1.0]\n\nThird vector of basis A, resolved in that basis\n\n\n\n\n\n","category":"constant"},{"location":"privatecont/#AeroBeams.I3","page":"Private API (cont'd)","title":"AeroBeams.I3","text":"I3 = Matrix(1.0*LinearAlgebra.I,3,3)\n\n3x3 identity matrix\n\n\n\n\n\n","category":"constant"},{"location":"privatecont/#AeroBeams.I6","page":"Private API (cont'd)","title":"AeroBeams.I6","text":"I6 = Matrix(1.0*LinearAlgebra.I,6,6)\n\n6x6 identity matrix\n\n\n\n\n\n","category":"constant"},{"location":"privatecont/#AeroBeams.divide_inplace!","page":"Private API (cont'd)","title":"AeroBeams.divide_inplace!","text":"divide_inplace!(divisor::Number, vars...)\n\nDivides the input variables in-place\n\nArguments\n\ndivisor::Number = divisor\nvars... = variables to be divided\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.multiply_inplace!","page":"Private API (cont'd)","title":"AeroBeams.multiply_inplace!","text":"multiply_inplace!(divisor::Number, vars...)\n\nMultiplies the input variables in-place\n\nArguments\n\nmultiplier::Number = multiplier\nvars... = variables to be multiplied\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.curvature_quantities","page":"Private API (cont'd)","title":"AeroBeams.curvature_quantities","text":"curvature_quantities(k::Vector{<:Number})\n\nComputes some useful functions of the curvature vector\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.position_vector_from_curvature","page":"Private API (cont'd)","title":"AeroBeams.position_vector_from_curvature","text":"positionvectorfrom_curvature(R0::Matrix{Float64}, k::Vector{<:Number}, x1::Number)\n\nComputes the position vector at an arclength value\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_tensor_from_curvature","page":"Private API (cont'd)","title":"AeroBeams.rotation_tensor_from_curvature","text":"rotationtensorfrom_curvature(R0::Matrix{Float64}, k::Vector{<:Number}, x1::Number)\n\nComputes the rotation tensor at an arclength position \n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_parameter_scaling","page":"Private API (cont'd)","title":"AeroBeams.rotation_parameter_scaling","text":"rotationparameterscaling(p::Vector{<:Number})\n\nScales the Wiener-Milenkovic rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_tensor_derivatives_scaled_parameters","page":"Private API (cont'd)","title":"AeroBeams.rotation_tensor_derivatives_scaled_parameters","text":"rotationtensorderivativesscaledparameters(ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²)\n\nComputes the derivatives of the rotation tensor with respect to the scaled rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.scaling_derivatives_extended_parameters","page":"Private API (cont'd)","title":"AeroBeams.scaling_derivatives_extended_parameters","text":"scalingderivativesextended_parameters(λ::Float64,p::Vector{<:Number},pNorm::Number)\n\nComputes the derivatives of the scaling factor with respect to the extended rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_tensor_derivatives_extended_parameters","page":"Private API (cont'd)","title":"AeroBeams.rotation_tensor_derivatives_extended_parameters","text":"rotationtensorderivativesextendedparameters(p,pNorm,λ,ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,υ,υ²)\n\nComputes the derivatives of the rotation tensor with respect to the extended rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_tensor_time_derivative","page":"Private API (cont'd)","title":"AeroBeams.rotation_tensor_time_derivative","text":"rotationtensortimederivative(Rps1,Rps2,Rps3,ps_p,pdot)\n\nComputes the time derivative of the rotation tensor \n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_tensor_derivatives_time_extended_parameters","page":"Private API (cont'd)","title":"AeroBeams.rotation_tensor_derivatives_time_extended_parameters","text":"rotationtensorderivativestimeextendedparameters(ps,ps0,ps1,ps2,ps3,ps1s,ps2s,ps3s,ps1ps2,ps1ps3,ps2ps3,Θ,Θps1,Θps2,Θps3,υ,υ²,υ²ps1,υ²ps2,υ²ps3,ps1dot,ps2dot,ps3dot,ps1p1,ps2p1,ps3p1,ps1p2,ps2p2,ps3p2,ps1p3,ps2p3,ps3p3)\n\nComputes the derivatives of the time derivative of the rotation tensor with respect to the extended rotation parameters \n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.tangent_operator_transpose_inverse_WM","page":"Private API (cont'd)","title":"AeroBeams.tangent_operator_transpose_inverse_WM","text":"tangentoperatortransposeinverseWM(p::Vector{<:Number})\n\nComputes the inverse of the transpose of the tangent operator tensor according to Wiener-Milenkovic parameters\n\n\n\n\n\ntangentoperatortransposeinverseWM(ps::Vector{Float64},ps0::Float64)\n\nComputes the inverse of the transpose of the tangent operator tensor according to Wiener-Milenkovic parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.tangent_tensor_functions_derivatives_extended_parameters","page":"Private API (cont'd)","title":"AeroBeams.tangent_tensor_functions_derivatives_extended_parameters","text":"tangenttensorfunctionsderivativesextendedparameters(HT,ps1,ps2,ps3,υ²,υ²ps1,υ²ps2,υ²ps3,ps_p)\n\nComputes the derivatives of the tangent tensor's transpose and its inverse with respect to the extended rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.force_scaling","page":"Private API (cont'd)","title":"AeroBeams.force_scaling","text":"force_scaling(S::Vector{Matrix{Float64}})\n\nComputes the appropriate force scaling for the linear system of equations\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.rotation_angle","page":"Private API (cont'd)","title":"AeroBeams.rotation_angle","text":"rotation_angle(p::Vector{<:Number})\n\nComputes the rotation angle\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.highest_in_rowcol","page":"Private API (cont'd)","title":"AeroBeams.highest_in_rowcol","text":"highestinrowcol(O::Matrix{<:Number})\n\nFinds the unrepeated columns of the n highest values in matrix O, where n is the size of O\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#Visualization","page":"Private API (cont'd)","title":"Visualization","text":"","category":"section"},{"location":"privatecont/","page":"Private API (cont'd)","title":"Private API (cont'd)","text":"AeroBeams.plot_output_of_x1\nAeroBeams.plot_output_of_time!\nAeroBeams.get_undeformed_airfoil_coords\nAeroBeams.plot_BCs!\nAeroBeams.draw_BC!\nAeroBeams.draw_concentrated_force!\nAeroBeams.draw_concentrated_moment!\nAeroBeams.draw_generalized_displacement!\nAeroBeams.plot_distributed_loads!\nAeroBeams.draw_distributed_forces!\nAeroBeams.draw_distributed_moments!\nAeroBeams.draw_aero_loads!\nAeroBeams.draw_circular_vector!","category":"page"},{"location":"privatecont/#AeroBeams.plot_output_of_x1","page":"Private API (cont'd)","title":"AeroBeams.plot_output_of_x1","text":"plotoutputof_x1(beamGroups; x1,output,ind,units,YLabel,colorScheme=:rainbow,lw=1,legendPos=:best)\n\nPlots output along the arclength coordinate for each beam group\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.plot_output_of_time!","page":"Private API (cont'd)","title":"AeroBeams.plot_output_of_time!","text":"plotoutputof_time!(plt; t,output,element=NaN,node=NaN,units,YLabel,lw=1,colorScheme=:rainbow,legendPos=:best)\n\nPlots output over time\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.get_undeformed_airfoil_coords","page":"Private API (cont'd)","title":"AeroBeams.get_undeformed_airfoil_coords","text":"getundeformedairfoil_coords(element::Element)\n\nComputes the undeformed nodal airfoil coordinates\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.plot_BCs!","page":"Private API (cont'd)","title":"AeroBeams.plot_BCs!","text":"plot_BCs!(plt,problem::Problem,element::Element)\n\nPlots all boundary conditions at the current time\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_BC!","page":"Private API (cont'd)","title":"AeroBeams.draw_BC!","text":"draw_BC!(plt,problem::Problem,element::Element)\n\nDraws boundary condition\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_concentrated_force!","page":"Private API (cont'd)","title":"AeroBeams.draw_concentrated_force!","text":"drawconcentratedforce!(plt,problem::Problem,element::Element)\n\nDraws concentrated force\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_concentrated_moment!","page":"Private API (cont'd)","title":"AeroBeams.draw_concentrated_moment!","text":"drawconcentratedmoment!(plt,problem::Problem,element::Element)\n\nDraws concentrated moment\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_generalized_displacement!","page":"Private API (cont'd)","title":"AeroBeams.draw_generalized_displacement!","text":"drawgeneralizeddisplacement!(plt,problem::Problem,element::Element)\n\nDraws generalized displacement boundary condition\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.plot_distributed_loads!","page":"Private API (cont'd)","title":"AeroBeams.plot_distributed_loads!","text":"plotdistributedloads!(plt,problem::Problem,element::Element)\n\nPlots all distributed loads at the current time\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_distributed_forces!","page":"Private API (cont'd)","title":"AeroBeams.draw_distributed_forces!","text":"drawdistributedforces!(element::Element)\n\nDraws distributed forces\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_distributed_moments!","page":"Private API (cont'd)","title":"AeroBeams.draw_distributed_moments!","text":"drawdistributedmoments!(element::Element)\n\nDraws distributed moments\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_aero_loads!","page":"Private API (cont'd)","title":"AeroBeams.draw_aero_loads!","text":"drawaeroloads!(element::Element)\n\nDraws aerodynamic loads\n\n\n\n\n\n","category":"function"},{"location":"privatecont/#AeroBeams.draw_circular_vector!","page":"Private API (cont'd)","title":"AeroBeams.draw_circular_vector!","text":"drawaeroloads!(element::Element)\n\nDraws aerodynamic loads\n\n\n\n\n\n","category":"function"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#Creating-an-aerodynamic-derivatives-solver","page":"Public API","title":"Creating an aerodynamic derivatives solver","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"AD\nFD","category":"page"},{"location":"public/#AeroBeams.AD","page":"Public API","title":"AeroBeams.AD","text":"struct AD <: DerivationMethod\n\nAD (Automatic Differentiation) DerivationMethod composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.FD","page":"Public API","title":"AeroBeams.FD","text":"struct FD <: DerivationMethod\n\nFD (Finite Differences) DerivationMethod composite type\n\nFields\n\nmethod::FiniteDifferenceMethod\n\n\n\n\n\n","category":"type"},{"location":"public/#Creating-an-aerodynamic-solver","page":"Public API","title":"Creating an aerodynamic solver","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"QuasiSteady\nIndicial\nBLi\nBLo\nInflow\nTableLookup\nThinAirfoilTheory\nIndicialGust","category":"page"},{"location":"public/#AeroBeams.QuasiSteady","page":"Public API","title":"AeroBeams.QuasiSteady","text":"struct QuasiSteady <: AeroSolver\n\nQuasiSteady AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.Indicial","page":"Public API","title":"AeroBeams.Indicial","text":"struct Indicial <: AeroSolver\n\nIndicial AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.BLi","page":"Public API","title":"AeroBeams.BLi","text":"struct BLi <: AeroSolver\n\nIncompressible modified Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.BLo","page":"Public API","title":"AeroBeams.BLo","text":"struct BLo <: AeroSolver\n\nOriginal Beddoes-Leishman AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.Inflow","page":"Public API","title":"AeroBeams.Inflow","text":"struct Inflow <: AeroSolver\n\nInflow AeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.TableLookup","page":"Public API","title":"AeroBeams.TableLookup","text":"struct TableLookup <: FlapAeroSolver\n\nTableLookup FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.ThinAirfoilTheory","page":"Public API","title":"AeroBeams.ThinAirfoilTheory","text":"mutable struct ThinAirfoilTheory <: FlapAeroSolver\n\nThinAirfoilTheory FlapAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.IndicialGust","page":"Public API","title":"AeroBeams.IndicialGust","text":"struct IndicialGust <: GustAeroSolver\n\nIndicialGust GustAeroSolver composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#Creating-an-airfoil","page":"Public API","title":"Creating an airfoil","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Airfoil\ncreate_Airfoil\ncreate_flapped_Airfoil","category":"page"},{"location":"public/#AeroBeams.Airfoil","page":"Public API","title":"AeroBeams.Airfoil","text":"@with_kw mutable struct Airfoil\n\nAirfoil composite type\n\nFields\n\nname::String\ncoordinates::Matrix{Float64}\nattachedFlowParameters::AttachedFlowParameters\nparametersBLi::BLiParameters\nparametersBLo::BLoParameters\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_Airfoil","page":"Public API","title":"AeroBeams.create_Airfoil","text":"create_Airfoil(;name::String,Re::Number=0,Ma::Number=0,U::Number=0,b::Number=0)\n\nInitializes the airfoil with the predefined name \n\nArguments\n\nname::String\nRe::Number\nMa::Number\nU::Number\nb::Number\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_flapped_Airfoil","page":"Public API","title":"AeroBeams.create_flapped_Airfoil","text":"createflappedAirfoil(;name::String,flapSiteID::Int64,Re::Number=0,Ma::Number=0)\n\nInitializes the airfoil with the predefined name and flap site ID \n\nArguments\n\nname::String\nflapSiteID::Int64\nRe::Number\nMa::Number\nU::Number\nb::Number\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-an-aerodynamic-surface","page":"Public API","title":"Creating an aerodynamic surface","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"AeroSurface\ncreate_AeroSurface","category":"page"},{"location":"public/#AeroBeams.AeroSurface","page":"Public API","title":"AeroBeams.AeroSurface","text":"@with_kw mutable struct AeroSurface\n\nAeroSurface composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_AeroSurface","page":"Public API","title":"AeroBeams.create_AeroSurface","text":"create_AeroSurface(;solver::AeroSolver=Indicial(),flapLoadsSolver::FlapAeroSolver=ThinAirfoilTheory(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),derivationMethod::DerivationMethod=AD(),airfoil::Airfoil,c::Union{<:Function,Number},Λ::Union{<:Function,Number}=0.0,normSparPos::Union{<:Function,Float64},normFlapSpan::Union{Nothing,Vector{<:Number}}=nothing,normFlapPos::Union{Nothing,Float64}=nothing,δIsTrimVariable::Bool=false,δ::Union{Nothing,<:Function,Number}=nothing,flapSiteID::Union{Nothing,Int64}=nothing,updateAirfoilParameters::Bool=true,hasTipCorrection::Bool=false,tipLossFunction::Union{Nothing,<:Function}=nothing,tipLossDecayFactor::Number=Inf64,smallAngles::Bool=false)\n\nCreates and aerodynamic surface\n\nKeyword arguments\n\n-solver::AeroSolver\n\nflapLoadsSolver::FlapAeroSolver\ngustLoadsSolver::GustAeroSolver\nderivationMethod::DerivationMethod\nairfoil::Airfoil\nc::Union{<:Function,Number}\nΛ::Union{<:Function,Number}\nnormSparPos::Union{<:Function,Float64}\nnormFlapSpan::Union{Nothing,Vector{<:Number}}\nnormFlapPos::Union{Nothing,Float64}\nδIsTrimVariable::Bool\nδ::Union{Nothing,<:Function,Number}\nflapSiteID::Union{Nothing,Int64}\nupdateAirfoilParameters::Bool\nhasTipCorrection::Bool\ntipLossFunction::String\ntipLossDecayFactor::Float64\nsmallAngles::Bool\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-an-atmosphere","page":"Public API","title":"Creating an atmosphere","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Atmosphere\nstandard_atmosphere","category":"page"},{"location":"public/#AeroBeams.Atmosphere","page":"Public API","title":"AeroBeams.Atmosphere","text":"@with_kw μtable struct Atmosphere\n\nAtmosphere composite type\n\nFields\n\nρ::Number\nμ::Number\na::Number\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.standard_atmosphere","page":"Public API","title":"AeroBeams.standard_atmosphere","text":"standard_atmosphere(altitude::Number)\n\nCalculates air properties from the International Standard Atmosphere (https://en.wikipedia.org/wiki/InternationalStandardAtmosphere)\n\nFields\n\naltitude::Number\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-boundary-conditions","page":"Public API","title":"Creating boundary conditions","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"BC\ncreate_BC","category":"page"},{"location":"public/#AeroBeams.BC","page":"Public API","title":"AeroBeams.BC","text":"@with_kw mutable struct BC\n\nBoundary conditions composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_BC","page":"Public API","title":"AeroBeams.create_BC","text":"create_BC(;name::String=\"\",beam::Beam,node::Int64,types::Vector{String},values,toBeTrimmed::Union{BitVector,Vector{Bool}}=falses(length(types)))\n\nBC constructor\n\nKeyword arguments\n\nname::String = name of the BC\nbeam::Beam = beam at which the BC is applied\nnode::Int64 = node of the beam at which the BC is applied\ntypes::Vector{String}= types of BCs applied to the node (generalized forces and displacements)\nvalues = corresponding values of the applied BCs (constants or functions of time)\ntoBeTrimmed::Union{BitVector,Vector{Bool}} = TF on whether the BC is to be trimmed\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-beam","page":"Public API","title":"Creating a beam","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Beam\ncreate_Beam\nupdate_beam!\nadd_point_inertias_to_beam!\nadd_loads_to_beam!\nadd_initial_displacements_and_velocities_to_beam!\nadd_springs_to_beam!\nadd_spring_to_beams!","category":"page"},{"location":"public/#AeroBeams.Beam","page":"Public API","title":"AeroBeams.Beam","text":"@with_kw mutable struct Beam\n\nBeam composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_Beam","page":"Public API","title":"AeroBeams.create_Beam","text":"create_Beam()\n\nCreates a beam\n\nKeyword Arguments\n\nname::String\nlength::Number\nrotationParametrization::String\np0::Vector{<:Number}\nk::Vector{<:Number}\ninitialPosition::Vector{<:Number}\nnElements::Int64\nnormalizedNodalPositions::Vector{Float64}\nC::Vector{<:Matrix{<:Number}}\nI::Vector{<:Matrix{<:Number}}\nconnectedBeams::Union{Nothing,Vector{Beam}}\nconnectedNodesThis::Vector{Int64}\nconnectedNodesOther::Vector{Int64}\npointInertias::Vector{PointInertia}\nhingedNodes::Vector{Int64}\nhingedNodesDoF::Union{Vector{Vector{Bool}},Vector{BitVector}}\nu0_of_x1::Union{Vector{<:Number},<:Function,Nothing}\np0_of_x1::Union{Vector{<:Number},<:Function,Nothing}\nudot0_of_x1::Union{Vector{<:Number},<:Function,Nothing}\npdot0_of_x1::Union{Vector{<:Number},<:Function,Nothing}\nf_A_of_x1t::Union{Nothing,<:Function}\nm_A_of_x1t::Union{Nothing,<:Function}\nf_b_of_x1t::Union{Nothing,<:Function}\nm_b_of_x1t::Union{Nothing,<:Function}\nff_A_of_x1t::Union{Nothing,<:Function}\nmf_A_of_x1t::Union{Nothing,<:Function}\nff_b_of_x1t::Union{Nothing,<:Function}\nmf_b_of_x1t::Union{Nothing,<:Function}\naeroSurface::Union{Nothing,AeroSurface}\nsprings::Vector{Spring}\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.update_beam!","page":"Public API","title":"AeroBeams.update_beam!","text":"update_beam!(beam::Beam)\n\nValidates and updates the beam construction\n\nArguments\n\nbeam::Beam\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.add_point_inertias_to_beam!","page":"Public API","title":"AeroBeams.add_point_inertias_to_beam!","text":"addpointinertiastobeam!(;beam::Beam,inertias::Vector{PointInertia})\n\nAdds point inertias to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\ninertias::Vector{PointInertia}\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.add_loads_to_beam!","page":"Public API","title":"AeroBeams.add_loads_to_beam!","text":"addloadsto_beam!(;beam::Beam,loadTypes::Vector{String},loadFuns::Vector{<:Function})\n\nAdds loads to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nloadTypes::Vector{String}\nloadFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.add_initial_displacements_and_velocities_to_beam!","page":"Public API","title":"AeroBeams.add_initial_displacements_and_velocities_to_beam!","text":"addinitialdisplacementsandvelocitiestobeam!(beam::Beam,conditionTypes::Vector{String},conditionFuns::Vector{<:Function})\n\nAdds initial generalized displacements and velocities to the beam\n\nArguments\n\nbeam::Beam\n\nKeyword arguments\n\nconditionTypes::Vector{String}\nconditionFuns::Vector{<:Function}\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.add_springs_to_beam!","page":"Public API","title":"AeroBeams.add_springs_to_beam!","text":"addspringsto_beam!(; beam::Beam,springs::Vector{Spring})\n\nAdds simply-attached springs to a beam\n\nKeyword arguments\n\nbeam::Beam\nsprings::Vector{Spring}\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.add_spring_to_beams!","page":"Public API","title":"AeroBeams.add_spring_to_beams!","text":"addspringto_beams!(; beams::Vector{Beam},spring::Spring)\n\nAdds a doubly-attached spring to the beams\n\nKeyword arguments\n\nbeams::Vector{Beam}\nspring::Spring\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-gust","page":"Public API","title":"Creating a gust","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_SharpEdgedGust\ncreate_OneMinusCosineGust\ncreate_Continuous1DGust\ncreate_DiscreteSpaceGust\ncreate_Continuous1DSpaceGust\ncreate_Continuous2DSpaceGust","category":"page"},{"location":"public/#AeroBeams.create_SharpEdgedGust","page":"Public API","title":"AeroBeams.create_SharpEdgedGust","text":"create_SharpEdgedGust(; initialTime::Number=0,duration::Number=Inf,convectiveVelocity::Number=0,verticalVelocity::Number,p::Vector{<:Number}=zeros(3))\n\nCreates a sharp-edged gust\n\nKeyword arguments\n\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_OneMinusCosineGust","page":"Public API","title":"AeroBeams.create_OneMinusCosineGust","text":"create_OneMinusCosineGust(; initialTime::Number=0,duration::Number,convectiveVelocity::Number=0,verticalVelocity::Number,p::Vector{<:Number}=zeros(3))\n\nCreates a one-minus-cosine gust\n\nKeyword arguments\n\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_Continuous1DGust","page":"Public API","title":"AeroBeams.create_Continuous1DGust","text":"create_Continuous1DGust(; spectrum::String=\"vK\",generationMethod::String=\"sinusoids\",initialTime::Number=0,duration::Number,generationDuration::Number=duration,L::Number=762,ωmin::Number=0,ωmax::Number=200π,Uref::Number,convectiveVelocity::Number=0,σ::Number,p::Vector{<:Number}=zeros(3),seed::Int64=123456,plotPSD::Bool=false)\n\nCreates a continuous 1D gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\ngenerationMethod::String = method for generation of gust velocity (\"sinusoids\" or \"whiteNoise\")\ninitialTime::Number = time when the gust begins\nduration::Number = duration of the gust\ngenerationDuration::Number = duration of the gust considered for its generation\nL::Number = turbulence length scale [m]\nωmin::Number = minimum frequency of the PSD [rad/s]\nωmax::Number = maximum frequency of the PSD [rad/s]\nUref::Number = reference airspeed\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\nplotPSD::Bool = TF to plot the PSD\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_DiscreteSpaceGust","page":"Public API","title":"AeroBeams.create_DiscreteSpaceGust","text":"create_DiscreteSpaceGust(; type::String,length::Number,width::Number,convectiveVelocity::Number=0,verticalVelocity::Number,c0::Vector{<:Number}=zeros(3),p::Vector{<:Number}=zeros(3))\n\nCreates a discrete space gust\n\nKeyword arguments\n\ntype::String = type of gust\nlength::Number = length of the gust (in longitudinal direction)\nwidth::Number = width of the gust (in spanwise direction)\nconvectiveVelocity::Number = convective velocity of the gust (in longitudinal direction)\nverticalVelocity::Number = peak \"vertical\" velocity of the gust (in lift direction)\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_Continuous1DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous1DSpaceGust","text":"create_Continuous1DSpaceGust(; spectrum::String,length::Number,N::Int64=1001,L::Number=762,σ::Number=1,c0::Vector{<:Number}=zeros(3),p::Vector{<:Number}=zeros(3),seed::Int64=123456)\n\nCreates a continuous 1D space gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\nlength::Number = length of the gust (in longitudinal direction)\nN::Int64 = number of nodes for length discretization\nL::Number = turbulence length scale\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_Continuous2DSpaceGust","page":"Public API","title":"AeroBeams.create_Continuous2DSpaceGust","text":"create_Continuous2DSpaceGust(; spectrum::String,length::Number,width::Number,Nx::Int64=101,Ny::Int64=101,L::Number=762,σ::Number=1,c0::Vector{<:Number}=zeros(3),p::Vector{<:Number}=zeros(3),seed::Int64=123456)\n\nCreates a continuous 2D space gust\n\nKeyword arguments\n\nspectrum::String = spectrum of the PSD: von Kármán (\"vK\") or Dryden (\"Dryden\")\nlength::Number = length of the gust (in longitudinal direction)\nwidth::Number = width of the gust (in lateral direction)\nNx::Int64 = number of nodes for length discretization\nNy::Int64 = number of nodes for width discretization\nL::Number = turbulence length scale\nσ::Number = turbulence intensity (RMS) of \"vertical\" gust velocity component\nc0::Vector{<:Number} = position vector of the front of the gust, resolved in the inertial basis\np::Vector{<:Number} = Euler rotation parameters (3-2-1 sequence) from the inertial basis to the gust basis\nseed::Int64 = seed for random numbers generation (reproducibility)\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-link","page":"Public API","title":"Creating a link","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_TrimLoadsLink\ncreate_FlapLink","category":"page"},{"location":"public/#AeroBeams.create_TrimLoadsLink","page":"Public API","title":"AeroBeams.create_TrimLoadsLink","text":"create_TrimLoadsLink(;masterBC::BC,slaveBCs::Vector{BC})\n\nCreates a link between trim loads so that they are equal\n\nKeyword arguments\n\nmasterBC::BC = master BC\nslaveBCs::Vector{BC} = slave BCs\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_FlapLink","page":"Public API","title":"AeroBeams.create_FlapLink","text":"create_FlapLink(;masterBeam::Beam,slaveBeams::Vector{Beam},δMultipliers::Vector{<:Number}=ones(length(slaveBeams)))\n\nCreates a link between flapped surfaces\n\nKeyword arguments\n\nmasterBeam::Beam = beam of the master surface\nslaveBeams::Vector{Beam} = beams of the slave surfaces\nδMultipliers::Vector{<:Number} = multiplication factors of flap deflection in slave surfaces relative to the master surface\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-model","page":"Public API","title":"Creating a model","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_Model\nupdate_model!\nset_motion_basis_A!","category":"page"},{"location":"public/#AeroBeams.create_Model","page":"Public API","title":"AeroBeams.create_Model","text":"createModel(;name::String=\"\",units::UnitsSystem=createUnitsSystem(),beams::Vector{Beam},initialPosition::Vector{<:Number}=zeros(3),gravityVector::Vector{<:Number}=zeros(3),BCs::Vector{BC}=Vector{BC}(),pA0::Vector{Float64}=zeros(3),uA::Union{Vector{<:Number},<:Function,Nothing}=nothing,vA::Union{Vector{<:Number},<:Function,Nothing}=nothing,ωA::Union{Vector{<:Number},<:Function,Nothing}=nothing,vdotA::Union{Vector{<:Number},<:Function,Nothing}=nothing,ωdotA::Union{Vector{<:Number},<:Function,Nothing}=nothing,altitude::Union{Nothing,Number}=nothing,atmosphere::Union{Nothing,Atmosphere}=nothing,gust::Union{Nothing,Gust}=nothing,trimLoadsLinks::Vector{TrimLoadsLink}=Vector{TrimLoadsLink}(),flapLinks::Vector{FlapLink}=Vector{FlapLink}(),rotationConstraints::Vector{RotationConstraint}=Vector{RotationConstraint}())\n\nCreates a model\n\nKeyword arguments\n\nname::String = name of the model\nunits::create_UnitsSystem = units system\nbeams::Vector{Beam} = beams in the assembly\ninitialPosition::Vector{<:Number} = initial position vector of the first node of the first beam, resolved in the inertial frame I\ngravityVector::Vector{<:Number} = gravity vector\nBCs::Vector{BC} = boundary condtions\np_A0::Vector{Float64} = initial rotation parameters that bring basis I to basis A\nu_A::Union{Vector{<:Number},<:Function,Nothing} = displacement of basis A relative to basis I\nv_A::Union{Vector{<:Number},<:Function,Nothing} = velocity of basis A relative to basis I\nω_A::Union{Vector{<:Number},<:Function,Nothing} = angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Number},<:Function,Nothing} = acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Number},<:Function,Nothing} = angular acceleration of basis A relative to basis I\naltitude::Union{Nothing,Number} = altidude\natmosphere::Union{Nothing,Atmosphere} = atmosphere\ngust::Union{Nothing,Gust} = gust\ntrimLoadsLinks::Vector{TrimLoadsLink} = links between trim loads\nflapLinks::Vector{FlapLink} = links between flapped surfaces\nrotationConstraints::Vector{RotationConstraint} = rotation constraints\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.update_model!","page":"Public API","title":"AeroBeams.update_model!","text":"update_model!(model::Model)\n\nUpdates the model with its current settings\n\nArguments\n\nmodel::Model \n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.set_motion_basis_A!","page":"Public API","title":"AeroBeams.set_motion_basis_A!","text":"setmotionbasisA!(; model::Model,uA::Union{Vector{<:Number},<:Function,Nothing}=nothing,vA::Union{Vector{<:Number},<:Function,Nothing}=nothing,ωA::Union{Vector{<:Number},<:Function,Nothing}=nothing,vdotA::Union{Vector{<:Number},<:Function,Nothing}=nothing,ωdotA::Union{Vector{<:Number},<:Function,Nothing}=nothing)\n\nSets the motion of basis A into the model\n\nKeyword arguments\n\nmodel::Model = model\nu_A::Union{Vector{<:Number},<:Function,Nothing} = displacement of basis A relative to basis I\nv_A::Union{Vector{<:Number},<:Function,Nothing} = velocity of basis A relative to basis I\nω_A::Union{Vector{<:Number},<:Function,Nothing} = angular velocity of basis A relative to basis I\nvdot_A::Union{Vector{<:Number},<:Function,Nothing} = acceleration of basis A relative to basis I\nωdot_A::Union{Vector{<:Number},<:Function,Nothing} = angular acceleration of basis A relative to basis I\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-point-inertia","page":"Public API","title":"Creating a point inertia","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"PointInertia","category":"page"},{"location":"public/#AeroBeams.PointInertia","page":"Public API","title":"AeroBeams.PointInertia","text":"@with_kw mutable struct PointInertia\n\nPointInertia composite type\n\nFields\n\nelementID::Int64 = local element ID to which the point inertia is attached\nmass::Number = mass\nη::Vector{Number} = position relative to element's midpoint's reference line\nIxx::Number = mass moment of inertia about the x1-axis\nIyy::Number = mass moment of inertia about the x2-axis\nIzz::Number = mass moment of inertia about the x3-axis\nIxy::Number = mass product of inertia with respect to the x1-axis and x2-axis\nIxz::Number = mass product of inertia with respect to the x1-axis and x3-axis\nIyz::Number = mass product of inertia with respect to the x2-axis and x3-axis\ninertiaMatrix::Union{Matrix{Number},Matrix{Nothing}} = mass moment of inertia matrix (tensor)\n\n\n\n\n\n","category":"type"},{"location":"public/#Creating-a-problem","page":"Public API","title":"Creating a problem","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"InitialVelocitiesUpdateOptions\nSteadyProblem\ncreate_SteadyProblem\nTrimProblem\ncreate_TrimProblem\nEigenProblem\ncreate_EigenProblem\nDynamicProblem\ncreate_DynamicProblem\nsolve!\nsolve_eigen!","category":"page"},{"location":"public/#AeroBeams.InitialVelocitiesUpdateOptions","page":"Public API","title":"AeroBeams.InitialVelocitiesUpdateOptions","text":"@with_kw mutable struct InitialVelocitiesUpdateOptions\n\nInitialVelocitiesUpdateOptions composite type\n\nDefines variables for the update of the initial velocities states\n\nFields\n\nΔt::Number = time step\nmaxIter::Int64 = maximum number of iterations\nrelaxFactor::Float64 = relaxation factor\ntol::Float64 = convergence tolerance\ndisplayProgress::Bool = flag to display progress\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.SteadyProblem","page":"Public API","title":"AeroBeams.SteadyProblem","text":"@with_kw mutable struct SteadyProblem <: Problem\n\nSteadyProblem composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_SteadyProblem","page":"Public API","title":"AeroBeams.create_SteadyProblem","text":"createSteadyProblem(;model::Model,systemSolver::SystemSolver=createNewtonRaphson(),getLinearSolution::Bool=false,x0::Vector{Float64}=zeros(0))\n\nSteady problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.TrimProblem","page":"Public API","title":"AeroBeams.TrimProblem","text":"@with_kw mutable struct TrimProblem <: Problem\n\nTrimProblem composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_TrimProblem","page":"Public API","title":"AeroBeams.create_TrimProblem","text":"createTrimProblem(;model::Model,systemSolver::SystemSolver=createNewtonRaphson(),getLinearSolution::Bool=false,getInertiaMatrix::Bool=true,x0::Vector{Float64}=zeros(0))\n\nTrim problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\ngetInertiaMatrix::Bool = flag to compute inertia matrix\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.EigenProblem","page":"Public API","title":"AeroBeams.EigenProblem","text":"@with_kw mutable struct EigenProblem <: Problem\n\nEigenProblem composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_EigenProblem","page":"Public API","title":"AeroBeams.create_EigenProblem","text":"createEigenProblem(;model::Model,systemSolver::SystemSolver=createNewtonRaphson(),getLinearSolution::Bool=false,nModes::Int64=Inf64,frequencyFilterLimits::Vector{Float64}=[0,Inf64],normalizeModeShapes::Bool=true,x0::Vector{Float64}=zeros(0),jacobian::SparseMatrixCSC{Float64,Int64}=spzeros(0,0),inertia::SparseMatrixCSC{Float64,Int64}=spzeros(0,0))\n\nEigen problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\nnModes::Int64=Inf64 = number of modes to be computed\nfrequencyFilterLimits::Vector{Float64} = limits of the frequency filter\nnormalizeModeShapes::Bool = flag to normalize mode shapes\nx0::Vector{Float64} = initial states\njacobian::SparseMatrixCSC{Float64,Int64} = Jacobian matrix\ninertia::SparseMatrixCSC{Float64,Int64} = inertia matrix\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.DynamicProblem","page":"Public API","title":"AeroBeams.DynamicProblem","text":"@with_kw mutable struct DynamicProblem <: Problem\n\nDynamicProblem composite type\n\n\n\n\n\n","category":"type"},{"location":"public/#AeroBeams.create_DynamicProblem","page":"Public API","title":"AeroBeams.create_DynamicProblem","text":"createDynamicProblem(;model::Model,systemSolver::SystemSolver=createNewtonRaphson(),getLinearSolution::Bool=false,initialTime::Number=0.0,Δt::Union{Nothing,Number}=nothing,finalTime::Union{Nothing,Number}=nothing,timeVector::Union{Nothing,Vector{Float64}}=nothing,adaptableΔt::Bool=false,minΔt::Union{Nothing,Number}=nothing,maxΔt::Union{Nothing,Number}=nothing,δb::Float64=-1e-5,skipInitialStatesUpdate::Bool=false,initialVelocitiesUpdateOptions::InitialVelocitiesUpdateOptions=InitialVelocitiesUpdateOptions(),trackingTimeSteps::Bool=true,trackingFrequency::Int64=1,displayProgress::Bool=true,displayFrequency::Int64=0,x0::Vector{Float64}=zeros(0))\n\nDynamic problem constructor\n\nKeyword arguments\n\nmodel::Model = model\nsystemSolver::systemSolver = nonlinear system solver\ngetLinearSolution::Bool = flag to solve for linear structural solution\ninitialTime::Number = initial time\nΔt::Union{Nothing,Number} = time step\nfinalTime::Union{Nothing,Number} = final time\ntimeVector::Union{Nothing,Vector{Float64}} = time vector\nadaptableΔt::Bool = flag for adaptable time step\nminΔt::Union{Nothing,Number} = minimum time step (when adaptable)\nmaxΔt::Union{Nothing,Number} = maximum time step (when adaptable)\nδb::Float64 = discontinuities boundary convergence norm\nskipInitialStatesUpdate::Bool = flag to skip update of initial states\ninitialVelocitiesUpdateOptions::InitialVelocitiesUpdateOptions = options for the initial velocities update\ntrackingTimeSteps::Bool = flag to track time step solutions\ntrackingFrequency::Int64 = frequency of time steps in which to track solution\ndisplayProgress::Bool = flag to display progress\ndisplayFrequency::Int64 = frequency of time steps in which to display progress\nx0::Vector{Float64} = initial states\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.solve!","page":"Public API","title":"AeroBeams.solve!","text":"solve!(problem::Problem)\n\nSolves a problem \n\nArguments\n\nproblem::Problem\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.solve_eigen!","page":"Public API","title":"AeroBeams.solve_eigen!","text":"solve_eigen!(problem::Problem)\n\nSolves an eigenproblem \n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-rotation-constraint","page":"Public API","title":"Creating a rotation constraint","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_RotationConstraint","category":"page"},{"location":"public/#AeroBeams.create_RotationConstraint","page":"Public API","title":"AeroBeams.create_RotationConstraint","text":"create_RotationConstraint(; masterBeam::Beam,slaveBeam::Beam,masterElementLocalID::Int64,slaveElementLocalID::Int64,DOF::Int64,value::Number)\n\nRotation constraint constructor\n\nKeyword arguments\n\nmasterBeam::Beam = master beam\nslaveBeam::Beam = slave beam\nmasterElementLocalID::Int64 = local ID of the master element\nslaveElementLocalID::Int64 = local ID of the slave element\nDOF::Int64 = constrained rotation degree-of-freedom\nvalue::Number = value of the slave DOF relative to the master DOF\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-sample-model","page":"Public API","title":"Creating a sample model","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_Pazy\ncreate_PazyFFWT\nPazy_tip_loss_factor\ncreate_Helios\ncreate_conventional_HALE\ncreate_BWB","category":"page"},{"location":"public/#AeroBeams.create_Pazy","page":"Public API","title":"AeroBeams.create_Pazy","text":"create_Pazy(; p0::Vector{<:Number}=zeros(3),airfoil::Airfoil=NACA0018,aeroSolver::AeroSolver=Indicial(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),derivationMethod::DerivationMethod=AD(),withTipCorrection::Bool=true,GAy::Number=1e16,GAz::Number=GAy)\n\nCreates the Pazy wing\n\nReturns the beam and geometrical properties\n\nArguments\n\np0::Vector{<:Number} = initial rotation parameters\nairfoil::Airfoil=NACA0018 = airfoil section\naeroSolver::AeroSolver=Indicial() = aerodynamic solver\ngustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\") = indicial gust loads solver\nderivationMethod::DerivationMethod=AD() = method for aerodynamic derivatives\nwithTipCorrection::Bool=true = flag for aerodynamic tip correction \nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_PazyFFWT","page":"Public API","title":"AeroBeams.create_PazyFFWT","text":"create_PazyFFWT(; p0::Vector{<:Number}=zeros(3),airfoil::Airfoil=deepcopy(NACA0018),aeroSolver::AeroSolver=Indicial(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),derivationMethod::DerivationMethod=AD(),withTipCorrection::Bool=false,GAy::Number=1e16,GAz::Number=GAy,hingeNode::Int64=14,hingeAngle::Number=0,flareAngle::Number=10,kSpring::Number=1e6,g::Number=0,airspeed::Number)\n\nCreates a version of the Pazy wing with flared folding wingtip (FFWT)\n\nArguments\n\np0::Vector{<:Number} = initial rotation parameters\nairfoil::Airfoil=NACA0018 = airfoil section\naeroSolver::AeroSolver=Indicial() = aerodynamic solver\ngustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\") = indicial gust loads solver\nderivationMethod::DerivationMethod=AD() = method for aerodynamic derivatives\nwithTipCorrection::Bool=true = flag for aerodynamic tip correction \nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\nhingeNode::Int64 = hinge node\nhingeAngle::Number = hinge (fold) angle\nflareAngle::Number = flare angle\nkSpring::Number = stiffness of the hinge\ng::Number=0 = local acceleration of gravity\nairspeed::Number = local airspeed\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.Pazy_tip_loss_factor","page":"Public API","title":"AeroBeams.Pazy_tip_loss_factor","text":"Pazytiploss_factor(αᵣ::Number,U::Number)\n\nComputes the tip loss factor for the Pazy wing's tip correction function\n\nArguments\n\nαᵣ::Number = root pitch angle, in degrees\nU::Number = airspeed\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_Helios","page":"Public API","title":"AeroBeams.create_Helios","text":"create_Helios(;altitude::Number=0,aeroSolver::AeroSolver=Indicial(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),derivationMethod::DerivationMethod=AD(),g::Number=-9.80665,wingAirfoil::Airfoil=HeliosWingAirfoil,podAirfoil::Airfoil=HeliosPodAirfoil,beamPods::Bool=false,stiffnessFactor::Number=1.0,∞::Number=1e12,nElemStraightSemispan::Int64=10,nElemDihedralSemispan::Int64=5,nElemPod::Int64=1,payloadPounds::Number=0,airspeed::Number=0,δIsTrimVariable::Bool=false,thrustIsTrimVariable::Bool=false,δ::Union{Nothing,Number,<:Function}=nothing,thrust::Union{Number,<:Function}=0,reducedChord::Bool,payloadOnWing::Bool=false)\n\nCreates a model based on the flying-wing aircraft described by Patil and Hodges in: Flight Dynamics of Highly Flexible Flying Wings (2006)\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\ng::Number = local acceleration of gravity\nwingAirfoil::Airfoil = airfoil section of the wing\npodAirfoil::Airfoil = airfoil section of the pods\nbeamPods::Bool = flag to include pods\nstiffnessFactor::Number = stiffness factor for the wing structure\n∞::Number = value for rigid structural properties\nnElemStraightSemispan::Int64 = number of elements in the straight section of the semispan\nnElemDihedralSemispan::Int64 = number of elements in the dihedral section of the semispan\nnElemPod::Int64 = number of elements in the pods\npayloadPounds::Number = payload, in pounds\nairspeed::Number = local initial/trim airspeed\nδIsTrimVariable::Bool = flag for flap deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδ::Union{Nothing,Number,<:Function} = flap deflection\nthrust::Union{Number,<:Function} = motors' thrust\nreducedChord::Bool = flag to employ a reduced (7 ft) chord\npayloadOnWing::Bool = flag to set the payload on the wing's reference line\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_conventional_HALE","page":"Public API","title":"AeroBeams.create_conventional_HALE","text":"createconventionalHALE(; altitude::Number=20e3,aeroSolver::AeroSolver=Indicial(),derivationMethod::DerivationMethod=AD(),flapLoadsSolver::FlapAeroSolver=TableLookup(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),stabilizersAero::Bool=true,includeVS::Bool=true,nElemWing::Int64=20,nElemHorzStabilizer::Int64=10,nElemTailBoom::Int64=10,nElemVertStabilizer::Int64=5,∞::Number=1e12,stiffnessFactor::Number=1,k1::Number=0,k2::Number=0,airspeed::Number=0,δElevIsTrimVariable::Bool=false,thrustIsTrimVariable::Bool=false,δElev::Union{Nothing,Number,<:Function}=nothing,thrust::Union{Number,<:Function}=0,g::Number=-9.80665,wingCd0::Number=0,wingcnδ::Number=2.5,wingcmδ::Number=-0.35,wingcdδ::Number=0.15,stabsCd0::Number=0,stabscnδ::Number=2.5,stabscmδ::Number=-0.35,stabscdδ::Number=0.15)\n\nCreates a model based on the conventional HALE aircraft described by Patil, Hodges and Cesnik in: Nonlinear Aeroelasticity and Flight Dynamics of HALE (2001)\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives\nflapLoadsSolver::FlapAeroSolver = aerodynamic solver for flap loads\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nstabilizersAero::Bool = flag for stabilizers with aerodynamic surfaces\nincludeVS::Bool = flag to include a vertical stabilizer in the model   \nnElemWing::Int64 = number of elements of the full wing\nnElemHorzStabilizer::Int64 = number of elements of the horizontal stabilizer\nnElemTailBoom::Int64 = number of elements of the tail boom\nnElemVertStabilizer::Int64 = number of elements of the vertical stabilizer\n∞::Number=1e12 = value of rigid structural properties\nstiffnessFactor::Number = stiffness factor for the wing structure\nk1::Number = undeformed wing torsional curvature\nk2::Number = undeformed wing flapwise bending curvature\nairspeed::Number = local initial/trim airspeed\nδElevIsTrimVariable::Bool = flag for elevator deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Number,<:Function} = elevator deflection\nthrust::Union{Number,<:Function} = motors' thrust\ng::Number = local acceleration of gravity\nwingCd0::Number = parisite drag coefficient for the wing\nwingcnδ::Number = cn vs δ slope for the wing\nwingcmδ::Number = cm vs δ slope for the wing\nwingcdδ::Number = cd vs δ slope for the wing\nstabsCd0::Number = parisite drag coefficient for the stabilizers\nstabscnδ::Number = cn vs δ slope for the stabilizers\nstabscmδ::Number = cm vs δ slope for the stabilizers\nstabscdδ::Number = cd vs δ slope for the stabilizers\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.create_BWB","page":"Public API","title":"AeroBeams.create_BWB","text":"create_BWB(; altitude::Number=0,aeroSolver::AeroSolver=Indicial(),gustLoadsSolver::GustAeroSolver=IndicialGust(\"Kussner\"),derivationMethod::DerivationMethod=AD(),∞::Number=1e12,stiffnessFactor::Number=1,airspeed::Number=0,δElevIsTrimVariable::Bool=false,thrustIsTrimVariable::Bool=false,δElev::Union{Nothing,Number,<:Function}=nothing,thrust::Union{Number,<:Function}=0,g::Number=-9.80665,updateAirfoilParameters::Bool=false,hasTipCorrection::Bool=false,tipLossDecayFactor::Number=40)\n\nCreates a model based on the blended-wing-body described by Weihua Su's PhD thesis\n\nKeyword arguments\n\naltitude::Number = altitude\naeroSolver::AeroSolver = aerodynamic solver\ngustLoadsSolver::GustAeroSolver = indicial gust loads solver\nderivationMethod::DerivationMethod = method for aerodynamic derivatives \n∞::Number=1e12 = value of rigid structural properties\nstiffnessFactor::Number = stiffness factor for the wing structure\nairspeed::Number = local initial/trim airspeed\nδElevIsTrimVariable::Bool = flag for elevator deflection being a trim variable\nthrustIsTrimVariable::Bool = flag for motors' thrust being a trim variable\nδElev::Union{Nothing,Number,<:Function} = elevator deflection\nthrust::Union{Number,<:Function} = motors' thrust\ng::Number = local acceleration of gravity\nupdateAirfoilParameters::Bool = flag to update airfoil parameters with airspeed\nhasTipCorrection::Bool = flag to employ aerodynamic tip correction\ntipLossDecayFactor::Number = tip loss decay factor\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-spring","page":"Public API","title":"Creating a spring","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_Spring","category":"page"},{"location":"public/#AeroBeams.create_Spring","page":"Public API","title":"AeroBeams.create_Spring","text":"create_Spring(; basis::String=\"A\",elementsIDs::Vector{Int64},nodesSides::Vector{Int64},ku::Vector{<:Number}=zeros(3),kp::Vector{<:Number}=zeros(3),kTranslational::Number=0,kTwist::Number=0,kIPBending::Number=0,kOOPBending::Number=0)\n\nCreates a spring\n\nKeyword arguments\n\nbasis::String = basis on which stiffnesses are defined\nelementsIDs::Vector{Int64} = local IDs of the element(s)' node(s) to which the spring is attached\nnodesSides::Vector{Int64} = sides (1 or 2) of the node(s) to which the spring is attached\nku::Vector{<:Number} = translational stiffness vector\nkp::Vector{<:Number} = rotational stiffness vector\nkTranslational::Number = translational stiffness (same in all directions)\nkTwist::Number = twist stiffness (rotation about x1 direction)\nkIPBending::Number = in-plane bending stiffness (rotation about x3 direction)\nkOOPBending::Number = out-of-plane bending stiffness (rotation about x2 direction)\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-system-solver","page":"Public API","title":"Creating a system solver","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_NewtonRaphson","category":"page"},{"location":"public/#AeroBeams.create_NewtonRaphson","page":"Public API","title":"AeroBeams.create_NewtonRaphson","text":"create_NewtonRaphson(; absoluteTolerance::Float64=1e-8,relativeTolerance::Float64=1e-8,maximumIterations::Int64=20,desiredIterations::Int64=5,maximumAbsoluteError::Number=1e6,maximumRelativeError::Number=1e6,initialLoadFactor::Number=1.0,minimumLoadFactor::Float64=0.01,maximumLoadFactorStep::Float64=0.5,minimumLoadFactorStep::Float64=0.01,ρ::Float64=1.0,trackingLoadSteps::Bool=true,displayStatus::Bool=false,minConvRateAeroJacUpdate::Number=2.0,minConvRateJacUpdate::Number=2.0,alwaysUpdateJacobian::Bool=true)\n\nNewton-Raphson nonlinear system solver constructor\n\nKeyword arguments\n\nabsoluteTolerance::Float64 = absolute convergence tolerance\nrelativeTolerance::Float64 = relative convergence tolerance\nmaximumIterations::Int64 = maximum number of iterations\ndesiredIterations::Int64 = desired number of iterations\nmaximumAbsoluteError::Number = maximum absolute error for divergence detection\nmaximumRelativeError::Number = maximum relative error for divergence detection\ninitialLoadFactor::Number = initial load factor\nminimumLoadFactor::Float64 = minimum load factor\nmaximumLoadFactorStep::Float64 = maximum load factor step\nminimumLoadFactorStep::Float64 = minimum load factor step\nρ::Float64 = relaxation factor for trim variables\ntrackingLoadSteps::Bool = flag to track partial load steps solutions\ndisplayStatus::Bool = flag to display status\nminConvRateAeroJacUpdate::Number = minimum convergence rate to skip computation of aerodynamic Jacobians\nminConvRateJacUpdate::Number = minimum convergence rate to skip computation of structural Jacobians\nalwaysUpdateJacobian::Bool = flag to update Jacobians on every iteration\n\n\n\n\n\n","category":"function"},{"location":"public/#Creating-a-units-system","page":"Public API","title":"Creating a units system","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"create_UnitsSystem","category":"page"},{"location":"public/#AeroBeams.create_UnitsSystem","page":"Public API","title":"AeroBeams.create_UnitsSystem","text":"create_UnitsSystem(;length::String=\"m\",force::String=\"N\",angle::String=\"rad\",frequency::String=\"rad/s\",mass::String=\"kg\")\n\nCreates a system composed of length, force, angle, frequency and mass units (this is only for plotting purposes and does not influence calculations)\n\nKeyword arguments\n\nlength::String = length unit\nforce::String = force unit\nangle::String = angle unit\nfrequency::String = frequency unit\nmass::String = mass unit\n\n\n\n\n\n","category":"function"},{"location":"public/#Utilities","page":"Public API","title":"Utilities","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"round_off!\nrms\ntilde\nmul3\nisotropic_stiffness_matrix\ninertia_matrix\nrotation_tensor_E321\nrotation_tensor_E313\nrotation_tensor_WM\ntangent_operator_transpose_WM\ntangent_tensor_transpose_derivatives_extended_parameters\nrotation_parameters_WM\nypr_from_rotation_tensor\nquaternion_from_rotation_tensor\nmode_tracking\nget_FFT_and_PSD","category":"page"},{"location":"public/#AeroBeams.round_off!","page":"Public API","title":"AeroBeams.round_off!","text":"round_off!(x)\n\nRounds the array or number to input tolerance (defaults to machine epsilon)\n\nArguments\n\nx = array / number\ntol = tolerance\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.rms","page":"Public API","title":"AeroBeams.rms","text":"rms(x)\n\nComputes the root mean square of an array\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.tilde","page":"Public API","title":"AeroBeams.tilde","text":"tilde(v::Vector{<:Number})\n\nComputes the skew-symmetric matrix associated with a vector\n\nArguments\n\nv::Vector{<:Number} = three-element vector\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.mul3","page":"Public API","title":"AeroBeams.mul3","text":"mul3(A1,A2,A3,b)\n\nComputes the scalar product of a third-order tensor represented by matrices A1, A2, and A3 with the vector b\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.isotropic_stiffness_matrix","page":"Public API","title":"AeroBeams.isotropic_stiffness_matrix","text":"isotropicstiffnessmatrix(;EA::Number,GAy::Number,GAz::Number,GJ::Number,EIy::Number,EIz::Number)\n\nCreates a 6x6 sectional stiffness matrix\n\nArguments\n\n∞::Number = value for rigid properties\nEA::Number = axial stiffness\nGAy::Number = shear stiffness in the x2 direction\nGAz::Number = shear stiffness in the x3 direction\nGJ::Number = torsional stiffness\nEIy::Number = bending stiffness about the x2 direction\nEIz::Number = bending stiffness about the x3 direction\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.inertia_matrix","page":"Public API","title":"AeroBeams.inertia_matrix","text":"inertia_matrix(;ρA::Number,ρIy::Number=0,ρIz::Number=0,ρIs::Number=ρIy+ρIz,e2::Number=0,e3::Number=0)\n\nCreates a 6x6 sectional inertia matrix\n\nArguments\n\nρA::Number = mass per unit length\nρIy::Number = mass moment of inertia per unit length about the x2-axis\nρIz::Number = mass moment of inertia per unit length about the x3-axis\nρIs::Number = mass moment of inertia per unit length about the x1-axis\ne2::Number = offset of center of gravity in the x2 direction with respect to the local reference line\ne3::Number = offset of center of gravity in the x3 direction with respect to the local reference line\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.rotation_tensor_E321","page":"Public API","title":"AeroBeams.rotation_tensor_E321","text":"rotationtensorE321(p::Vector{<:Number})\n\nComputes the rotation tensor according to Euler parameters sequence 3-2-1\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.rotation_tensor_E313","page":"Public API","title":"AeroBeams.rotation_tensor_E313","text":"rotationtensorE321(p::Vector{<:Number})\n\nComputes the rotation tensor according to Euler parameters sequence 3-1-3\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.rotation_tensor_WM","page":"Public API","title":"AeroBeams.rotation_tensor_WM","text":"rotationtensorWM(p::Vector{<:Number})\n\nComputes the rotation tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{<:Number} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.tangent_operator_transpose_WM","page":"Public API","title":"AeroBeams.tangent_operator_transpose_WM","text":"tangentoperatortranspose_WM(p::Vector{Float64})\n\nComputes the transpose of tangent operator tensor according to Wiener-Milenkovic parameters\n\nArguments\n\np::Vector{Float64} = rotation parameters\n\n\n\n\n\ntangentoperatortranspose_WM(ps::Vector{Float64},ps0::Float64,υ²::Float64)\n\nComputes the transpose of tangent operator tensor according to Wiener-Milenkovic parameters\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.tangent_tensor_transpose_derivatives_extended_parameters","page":"Public API","title":"AeroBeams.tangent_tensor_transpose_derivatives_extended_parameters","text":"tangenttensortransposederivativesextended_parameters(p::Vector{Float64})\n\nComputes the derivatives of the tangent tensor's transpose with respect to the extended rotation parameters\n\nArguments\n\np::Vector{Float64} = rotation parameters\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.rotation_parameters_WM","page":"Public API","title":"AeroBeams.rotation_parameters_WM","text":"rotationparametersWM(R::Matrix{<:Number})\n\nComputes the Wiener-Milenkovic rotation parameters given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.ypr_from_rotation_tensor","page":"Public API","title":"AeroBeams.ypr_from_rotation_tensor","text":"yprfromrotation_tensor(R::Matrix{<:Number},tol::Float64=1e-6)\n\nComputes the Euler angles from the sequence 3-2-1 given the rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\ntol::Float64 = round-off tolerance\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.quaternion_from_rotation_tensor","page":"Public API","title":"AeroBeams.quaternion_from_rotation_tensor","text":"quaternionfromrotation_tensor(R::Matrix{<:Number})\n\nComputes the quaternion (Euler parameters) given a rotation tensor\n\nArguments\n\nR::Matrix{<:Number} = rotation tensor\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.mode_tracking","page":"Public API","title":"AeroBeams.mode_tracking","text":"mode_tracking(controlParam::Vector{<:Number},freqs::Array{Vector{Float64}},damps::Array{Vector{Float64}},eigenvectors::Array{Matrix{ComplexF64}})\n\nApplies mode tracking based on eigenvectors match\n\nArguments\n\ncontrolParam::Vector{<:Number} = vector of control parameter\nfreqs::Array{Vector{Float64}} = frequencies vector\ndamps::Array{Vector{Float64}} = dampings vector\neigenvectors::Array{Matrix{ComplexF64}} = complex-valued eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.get_FFT_and_PSD","page":"Public API","title":"AeroBeams.get_FFT_and_PSD","text":"getFFTand_PSD(t::Vector{<:Number},y::Vector{<:Number},diffTol::Float64=1e3*eps())\n\nComputes the FFT and PSD of signal y(t)\n\nArguments\n\nt::Vector{<:Number} = time signal\ny::Vector{<:Number} = quantity signal\ndiffTol::Float64 = tolerance for time signal being equally spaced\n\n\n\n\n\n","category":"function"},{"location":"public/#Visualizing-the-results","page":"Public API","title":"Visualizing the results","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"plot_undeformed_assembly\nplot_steady_deformation\nplot_steady_outputs\nplot_mode_shapes\nplot_dynamic_deformation\nplot_time_outputs","category":"page"},{"location":"public/#AeroBeams.plot_undeformed_assembly","page":"Public API","title":"AeroBeams.plot_undeformed_assembly","text":"plotundeformedassembly(model::Model)\n\nPlots the nodal coordinates of the assembly of beams\n\nArguments\n\nmodel::Model\nview::Tuple{<:Number,<:Number} = view angles\nequalAspectRatio::Bool = flag to set equal aspect ratio plot\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.plot_steady_deformation","page":"Public API","title":"AeroBeams.plot_steady_deformation","text":"plotsteadydeformation(problem::Problem; plotBCs::Bool=true,view::Union{Nothing,Tuple{Int64,Int64}}=nothing,scale::Number=1,lw::Number=1,colorUndef=:black,colorDef=:blue,grid::Bool=true,legendPos=:best,tolPlane::Number=1e-8,plotAeroSurf::Bool=true,surfα::Float64=0.5,ΔuDef::Vector{<:Number}=zeros(3),save::Bool=false,savePath::String=\"/test/outputs/figures/fig.pdf\")\n\nPlots the initial and final deformed states for the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nplotBCs::Bool = flag to plot BCs\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nscale::Number = displacements and rotations scale\nlw::Number = linewidth\ncolorUndef = color for undeformed assembly\ncolorDef = color for deformed assembly\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nΔuDef::Vector{<:Number} = displacement vector for first node of deformed assembly relative to the undeformed one\nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.plot_steady_outputs","page":"Public API","title":"AeroBeams.plot_steady_outputs","text":"plotsteadyoutputs(problem::Problem; outputs::Vector{String}=[\"u\",\"p\",\"F\",\"M\",\"V\",\"Ω\",\"α\",\"cn\",\"cm\",\"ct\",\"cl\",\"cd\"],beamGroups=1:length(problem.model.beams),lw::Number=1,colorScheme=:rainbow,legendPos=:best,save::Bool=false,saveFolder::String=\"/test/outputs/figures/\",figureExtension::String=\".pdf\")\n\nPlots outputs of a steady problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\noutputs::Vector{String} = list of outputs\nbeamGroups = list of beams in each group for which arclengths are concatenated\nlw::Number = linewidth\ncolorScheme = color scheme\nlegendPos = legend position\nsave::Bool = flag to save figures\nsaveFolder::String = relative path of folder where to save figures\nfigureExtension::String = figure extension\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.plot_mode_shapes","page":"Public API","title":"AeroBeams.plot_mode_shapes","text":"plotmodeshapes(problem::Problem; plotBCs::Bool=true,view::Union{Nothing,Tuple{Int64,Int64}}=nothing,nModes::Union{Nothing,Int64}=nothing,scale::Number=1,frequencyLabel::String=\"frequency&damping\",lw::Number=1,colorSteady=:black,modalColorScheme=:jet1,grid::Bool=true,legendPos=:best,tolPlane::Number=1e-8,plotAeroSurf::Bool=true,surfα::Float64=0.5,save::Bool=false,savePath::String=\"/test/outputs/figures/fig.pdf\")\n\nPlots the mode shapes of the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nplotBCs::Bool = flag to plot BCs\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nnModes::Union{Nothing,Int64} = number of modes to plot\nscale::Number = displacements and rotations scale\nfrequencyLabel::String = option for frequency label (only frequency or frequency and damping)\nlw::Number = linewidth\ncolorSteady = color for steadily deformed assembly\nmodalColorScheme = color scheme for mode shapes\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.plot_dynamic_deformation","page":"Public API","title":"AeroBeams.plot_dynamic_deformation","text":"plotdynamicdeformation(problem::Problem; refBasis::String=\"A\", plotFrequency::Int64=1,plotUndeformed::Bool=false,plotBCs::Bool=true,plotDistLoads::Bool=true,view::Union{Nothing,Tuple{Int64,Int64}}=nothing,fps::Number=30,scale::Number=1,lw::Number=1,colorUndef=:black,colorDef=:blue,grid::Bool=true,legendPos=:best,tolPlane::Number=1e-8,plotAeroSurf::Bool=true,surfα::Float64=0.5,plotLimits::Union{Nothing,Vector{Tuple{T1,T2}}}=nothing,save::Bool=false,savePath::String=\"/test/outputs/figures/fig.gif\",showScale::Bool=true,showTimeStamp::Bool=true,scalePos::Vector{<:Number}=[0.1;0.05;0.05],timeStampPos::Vector{<:Number}=[0.5;0.05;0.05],displayProgress::Bool=false) where {T1<:Number,T2<:Number}\n\nPlots the animated deformation of the model in the given problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nrefBasis::String = reference basis for plot\nplotFrequency::Int64 = frequency of time steps to plot\nplotUndeformed::Bool = flag to plot undeformed assembly\nplotBCs::Bool = flag to plot BCs\nplotDistLoads::Bool = flag to plot distributed loads (includes gravitational and aerodynamic loads)\nview::Union{Nothing,Tuple{Int64,Int64}} = view angles\nfps::Number = frame rate for gif\nscale::Number = displacements and rotations scale\nfrequencyLabel::String = option for frequency label (only frequency or frequency and damping)\nlw::Number = linewidth\ncolorUndef = color for undeformed assembly\ncolorDef = color for deformed assembly\ngrid::Bool = flag for grid\nlegendPos = legend position\ntolPlane::Number = displacement tolerance to plot as plane\nplotAeroSurf = flag to plot aerodynamic surfaces\nsurfα::Float64 = transparency factor of aerodynamic surfaces \nplotLimits::Union{Nothing,Vector{Tuple{T1,T2}}} = plot axis limits\nsave::Bool = flag to save the figure\nsavePath::String = relative path on which to save the figure\nshowScale::Bool = flag to show scale on plot\nshowTimeStamp::Bool = flag to show time stamp on plot\nscalePos::Vector{<:Number} = position of scale on plot\ntimeStampPos::Vector{<:Number} = position of time stamp on plot\ndisplayProgress::Bool = flag to display progress of gif creation\n\n\n\n\n\n","category":"function"},{"location":"public/#AeroBeams.plot_time_outputs","page":"Public API","title":"AeroBeams.plot_time_outputs","text":"plottimeoutputs(problem::Problem; nodes::Vector{Tuple{Int64,Int64}}=Vector{Tuple{Int64,Int64}}(),elements::Vector{Int64}=Vector{Int64}(),nodalOutputs::Vector{String}=[\"u\",\"p\",\"F\",\"M\"],elementalOutputs::Vector{String}=[\"u\",\"p\",\"F\",\"M\",\"V\",\"Ω\",\"α\",\"cn\",\"cm\",\"ct\",\"cl\",\"cd\"],lw::Number=1,colorScheme=:rainbow,showLegend::Bool=true,legendPos=:best,save::Bool=false,saveFolder::String=\"/test/outputs/figures/\",figureExtension::String=\".pdf\")\n\nPlots outputs of a dynamic problem\n\nArguments\n\nproblem::Problem = problem\n\nKeyword arguments\n\nnodes::Vector{Tuple{Int64,Int64}} = global IDs of nodes for which to plot\nelements::Vector{Int64} = global IDs of elements for which to plot\nnodalOutputs::Vector{String} = nodal outputs to plot\nelementalOutputs::Vector{String} = elemental outputs to plot\nlw::Number = linewidth\ncolorScheme = color scheme\nshowLegend::Bool = flag to show legend\nlegendPos = legend position\nsave::Bool = flag to save figures\nsaveFolder::String = relative path of folder where to save figures\nfigureExtension::String = figure extension\n\n\n\n\n\n","category":"function"},{"location":"#AeroBeams","page":"Home","title":"AeroBeams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AeroBeams.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add AeroBeams","category":"page"}]
}
