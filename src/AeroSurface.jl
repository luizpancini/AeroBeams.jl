#

    # AeroSurface composite type

#
@with_kw mutable struct AeroSurface

    # Primary (inputs to aero surface creation)
    # -----------------------------------------
    # Aerodynamic solver for pitch-plunge loads
    solver::AeroSolver
    # Flap loads solver
    flapLoadsSolver::FlapAeroSolver
    # Gust loads solver
    gustLoadsSolver::GustAeroSolver
    # Derivation (Jacobians) method 
    derivationMethod::DerivationMethod
    # Airfoil
    airfoil::Airfoil
    # Airfoil chord (constant or a function of normalized span)
    c::Union{<:Function,Real}
    # Sweep angle (constant or a function of normalized span)
    Λ::Union{<:Function,Real}
    # Twist angle (constant or a function of normalized span)
    φ::Union{<:Function,Real}
    # Spar position normalized by local chord (constant or a function of normalized span)
    normSparPos::Union{<:Function,Float64}
    # Trailing-edge flap span normalized by attached beam length
    normFlapSpan::Union{Nothing,Vector{<:Real}}
    # Trailing-edge flap hinge position normalized by local airfoil chord
    normFlapPos::Union{Nothing,Float64}
    # Flag for flap deflection being a trim variable
    δIsTrimVariable::Bool
    # Flap deflection 
    δ::Union{Nothing,<:Function,Real}
    # Flag to update airfoil parameters over time according to flow parameters in dynamic problems
    updateAirfoilParameters::Bool 
    # Tip loss correction variables
    hasTipCorrection::Bool
    tipLossFunctionIsAirspeedDependent::Bool
    tipLossFunction::Union{Nothing,<:Function}
    tipLossDecayFactor::Real
    # Number of Gauss points for quadrature of tip loss function
    nGaussPoints::Int
    # Flag for small angle of attack approximations
    smallAngles::Bool
    # Flag to include induced drag from the surface
    hasInducedDrag::Bool
    # Flag for symmetric counterpart
    hasSymmetricCounterpart::Bool

    # Secondary (outputs from aero surface creation)
    # ----------------------------------------------
    # Flag for flap deflection being a user input
    δIsInput::Bool
    # Flag for flap deflection being zero over time
    δIsZero::Bool
    # Flap deflection rates as functions of time
    δdot::Function
    δddot::Function
    # Current flap deflection and rates
    δNow::Real
    δdotNow::Real
    δddotNow::Real
    # Flag for independent flap surface
    hasIndependentFlap::Bool
    # Flap deflection multiplier for slave surfaces
    δMultiplier::Real
    # Area and aspect ratio
    area::Real
    AR::Real

end
export AeroSurface


"""
    create_AeroSurface(; kwargs...)

Aerodynamic surface constructor

# Keyword arguments
- `solver::AeroSolver`: aerodynamic solver for pitch-plunge-induced loads
- `flapLoadsSolver::FlapAeroSolver`: aerodynamic solver for flap-induced loads
- `gustLoadsSolver::GustAeroSolver`: aerodynamic solver for gust-induced loads
- `derivationMethod::DerivationMethod`: method for calculation of aerodynamic derivatives
- `airfoil::Airfoil`: airfoil section
- `c::Union{<:Function,Real}`: chord
- `Λ::Union{<:Function,Real}`: sweep angle
- `φ::Union{<:Function,Real}`: twist angle
- `normSparPos::Union{<:Function,Float64}`: normalized position of the spar (beam reference line) on the chord
- `normFlapSpan::Union{Nothing,Vector{<:Real}}`: normalized position of the trailing-edge flap along the span (beam arclength)
- `normFlapPos::Union{Nothing,Float64}`: normalized position of the trailing-edge flap hinge on the chord
- `δIsTrimVariable::Bool`: flag for trailing-edge deflection being a trim variable
- `δ::Union{Nothing,<:Function,Real}`: trailing-edge deflection [rad]
- `updateAirfoilParameters::Bool`: flag to update airfoil parameters with local airspeed
- `hasTipCorrection::Bool`: flag to employ a tip correction on 2D aerodynamic coefficients
- `tipLossFunctionIsAirspeedDependent::Bool`: flag for tip loss function being airspeed dependent
- `tipLossFunction::String`: corresponding tip loss function
- `tipLossDecayFactor::Float64`: corresponding tip loss factor
- `nGaussPoints::Int`: Number of Gauss points for quadrature of tip loss function
- `smallAngles::Bool`: flag to employ small angles approximation on the calculation of the angle of attack
- `hasInducedDrag::Bool`: flag to include induced drag generated by the lifting surface
- `hasSymmetricCounterpart::Bool`: flag to indicate the surface has a symmetric counterpart (for the computation of aspect ratio)
"""
function create_AeroSurface(; solver::AeroSolver=Indicial(),flapLoadsSolver::FlapAeroSolver=ThinAirfoilTheory(),gustLoadsSolver::GustAeroSolver=IndicialGust("Kussner"),derivationMethod::DerivationMethod=AD(),airfoil::Airfoil,c::Union{<:Function,Real},Λ::Union{<:Function,Real}=0.0,φ::Union{<:Function,Real}=0.0,normSparPos::Union{<:Function,Float64},normFlapSpan::Union{Nothing,Vector{<:Real}}=nothing,normFlapPos::Union{Nothing,Float64}=nothing,δIsTrimVariable::Bool=false,δ::Union{Nothing,<:Function,Real}=nothing,updateAirfoilParameters::Bool=true,hasTipCorrection::Bool=false,tipLossFunctionIsAirspeedDependent::Bool=false,tipLossFunction::Union{Nothing,<:Function}=nothing,tipLossDecayFactor::Real=Inf64,nGaussPoints::Int=2,smallAngles::Bool=false,hasInducedDrag::Bool=false,hasSymmetricCounterpart::Bool=true)

    # Validate
    if c isa Real
        @assert c > 0 "chord must be positive"
    end
    if Λ isa Real
        @assert -π/2 < Λ < π/2 "sweep angle too large (input modulus must be in radians and smaller than π/2)"
    end
    if φ isa Real
        @assert -π/4 <= φ <= π/4 "twist angle too large (input modulus must be in radians and smaller than or equal than π/4)"
    end
    if !isnothing(normFlapSpan)
        @assert !isnothing(normFlapPos) "flap span was set, but chord-normalized position was not"
        @assert length(normFlapSpan) == 2 "normFlapSpan must be a vector with 2 entries"
        @assert first(normFlapSpan) >= 0 "first entry of normFlapSpan must be greater to or equal to 0"
        @assert last(normFlapSpan) <= 1 "second entry of normFlapSpan must be smaller to or equal to 1"
        @assert issorted(normFlapSpan) "set normFlapSpan in ascending order"
    end 
    if !isnothing(normFlapPos)
        @assert !isnothing(normFlapSpan) "chord-normalized flap position (normFlapPos) was set, but span (normFlapSpan) was not"
        @assert 0.5 <= normFlapPos <= 1 "normFlapPos must be between 0.5 and 1"
    end
    if !isnothing(δ)
        @assert !δIsTrimVariable "flap deflection cannot be a trim variable and an input"
    end

    # Enforce quasi-steady gust indicial solver if the pitch-plunge solver is quasi-steady
    if typeof(solver) == QuasiSteady
        gustLoadsSolver = IndicialGust("QuasiSteady")
    end

    # Update airfoil flap parameters with known flap position
    if !isnothing(normFlapPos)
        airfoil.flapParameters = FlapParameters(airfoil.name; flapSiteID=round(Int,100*normFlapPos))
    end

    # Set flag for δ being user input
    δIsInput = !isnothing(δ) 

    # Set flag for δ being zero over time
    δIsZero = isnothing(δ) && !δIsTrimVariable

    # Set flap deflection and rates as functions of time
    if isnothing(δ)
        δ = t -> 0
        δdot = t -> 0
        δddot = t -> 0
    elseif δ isa Real
        δconst = deepcopy(δ)
        δ = t -> δconst
        δdot = t -> 0
        δddot = t -> 0
    elseif δ isa Function
        δdot = t -> ForwardDiff.derivative(δ, t)
        δddot = t -> ForwardDiff.derivative(δdot, t)
    end

    # Set current flap deflection and rates
    δNow = δ(0)
    δdotNow = δdot(0)
    δddotNow = δddot(0)

    # Initialize flap deflection multiplier for slave surfaces (updated later on model assembly)
    δMultiplier = 1

    # Initialize area and aspect ratio (updated later on beam creation)
    area = 1
    AR = 1

    return AeroSurface(solver=solver,flapLoadsSolver=flapLoadsSolver,gustLoadsSolver=gustLoadsSolver,derivationMethod=derivationMethod,airfoil=airfoil,c=c,Λ=Λ,φ=φ,normSparPos=normSparPos,normFlapSpan=normFlapSpan,normFlapPos=normFlapPos,δIsInput=δIsInput,δIsTrimVariable=δIsTrimVariable,δIsZero=δIsZero,δ=δ,updateAirfoilParameters=updateAirfoilParameters,hasTipCorrection=hasTipCorrection,tipLossFunctionIsAirspeedDependent=tipLossFunctionIsAirspeedDependent,tipLossFunction=tipLossFunction,tipLossDecayFactor=tipLossDecayFactor,nGaussPoints=nGaussPoints,smallAngles=smallAngles,hasInducedDrag=hasInducedDrag,hasSymmetricCounterpart=hasSymmetricCounterpart,δdot=δdot,δddot=δddot,δNow=δNow,δdotNow=δdotNow,δddotNow=δddotNow,hasIndependentFlap=true,δMultiplier=δMultiplier,area=area,AR=AR)

end
export create_AeroSurface

